!function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var t={};return n.m=e,n.c=t,n.p="./res/",n(0)}([function(module,exports,__webpack_require__){eval("__webpack_require__(39);\n__webpack_require__(42);\n__webpack_require__(41);\n__webpack_require__(40);\n__webpack_require__(38);\n\n__webpack_require__(43);\n\n__webpack_require__(46);\n__webpack_require__(44);\n__webpack_require__(45);\n\n__webpack_require__(51);\n__webpack_require__(50);\n__webpack_require__(52);\n__webpack_require__(47);\n__webpack_require__(49);\n__webpack_require__(48);\n__webpack_require__(54);\n__webpack_require__(53);\n__webpack_require__(55);\n\n__webpack_require__(57);\n__webpack_require__(56);\n\n__webpack_require__(63);\n__webpack_require__(59);\n__webpack_require__(60);\n__webpack_require__(62);\n__webpack_require__(58);\n__webpack_require__(61);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/core-deps.js\n ** module id = 0\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/core-deps.js?")},,function(module,exports,__webpack_require__){eval('var map = {\n	"./cytoscape": 4,\n	"./cytoscape.js": 4,\n	"./cytoscape.min": 6,\n	"./cytoscape.min.js": 6\n};\nfunction webpackContext(req) {\n	return __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n	return map[req] || (function() { throw new Error("Cannot find module \'" + req + "\'.") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n	return Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 2;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/cytoscape/dist ^\\.\\/.*$\n ** module id = 2\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///../~/cytoscape/dist_^\\.\\/.*$?')},,function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * This file is part of Cytoscape.js 2.3.8.\n * \n * Cytoscape.js is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n * \n * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n * \n * You should have received a copy of the GNU Lesser General Public License along with\n * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.\n */\n \n\n// this is put as a global var in the browser\n// or it's just a global to this module if commonjs\n\nvar cytoscape;\n\n(function(window){ 'use strict';\n\n  // the object iteself is a function that init's an instance of cytoscape\n\n  var $$ = cytoscape = function(){ // jshint ignore:line\n    return cytoscape.init.apply(cytoscape, arguments);\n  };\n\n  $$.version = '2.3.8';\n  \n  // allow functional access to cytoscape.js\n  // e.g. var cyto = $.cytoscape({ selector: \"#foo\", ... });\n  //      var nodes = cyto.nodes();\n  $$.init = function( options ){\n    \n    // if no options specified, use default\n    if( options === undefined ){\n      options = {};\n    }\n\n    // create instance\n    if( $$.is.plainObject( options ) ){\n      return new $$.Core( options );\n    } \n    \n    // allow for registration of extensions\n    // e.g. $.cytoscape('renderer', 'svg', SvgRenderer);\n    // e.g. $.cytoscape('renderer', 'svg', 'nodeshape', 'ellipse', SvgEllipseNodeShape);\n    // e.g. $.cytoscape('core', 'doSomething', function(){ /* doSomething code */ });\n    // e.g. $.cytoscape('collection', 'doSomething', function(){ /* doSomething code */ });\n    else if( $$.is.string( options ) ) {\n      return $$.extension.apply($$.extension, arguments);\n    }\n  };\n\n  // define the function namespace here, since it has members in many places\n  $$.fn = {};\n\n  if( typeof module !== 'undefined' && module.exports ){ // expose as a commonjs module\n    module.exports = cytoscape;\n  }\n\n  if( true ){ // expose as an amd/requirejs module\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){\n      return cytoscape;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // make sure we always register in the window just in case (e.g. w/ derbyjs)\n  if( window ){\n    window.cytoscape = cytoscape;\n  }\n  \n})( typeof window === 'undefined' ? null : window );\n\n// type testing utility functions\n\n;(function($$, window){ 'use strict';\n\n  $$.is = {\n    defined: function(obj){\n      return obj != null; // not undefined or null\n    },\n\n    string: function(obj){\n      return obj != null && typeof obj == typeof '';\n    },\n    \n    fn: function(obj){\n      return obj != null && typeof obj === typeof function(){};\n    },\n    \n    array: function(obj){\n      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;\n    },\n    \n    plainObject: function(obj){\n      return obj != null && typeof obj === typeof {} && !$$.is.array(obj) && obj.constructor === Object;\n    },\n    \n    number: function(obj){\n      return obj != null && typeof obj === typeof 1 && !isNaN(obj);\n    },\n\n    integer: function( obj ){\n      return $$.is.number(obj) && Math.floor(obj) === obj;\n    },\n    \n    color: function(obj){\n      return obj != null && typeof obj === typeof '' && $.Color(obj).toString() !== '';\n    },\n    \n    bool: function(obj){\n      return obj != null && typeof obj === typeof true;\n    },\n    \n    elementOrCollection: function(obj){\n      return $$.is.element(obj) || $$.is.collection(obj);\n    },\n    \n    element: function(obj){\n      return obj instanceof $$.Element && obj._private.single;\n    },\n    \n    collection: function(obj){\n      return obj instanceof $$.Collection && !obj._private.single;\n    },\n    \n    core: function(obj){\n      return obj instanceof $$.Core;\n    },\n\n    style: function(obj){\n      return obj instanceof $$.Style;\n    },\n\n    stylesheet: function(obj){\n      return obj instanceof $$.Stylesheet;\n    },\n\n    event: function(obj){\n      return obj instanceof $$.Event;\n    },\n\n    emptyString: function(obj){\n      if( !obj ){ // null is empty\n        return true; \n      } else if( $$.is.string(obj) ){\n        if( obj === '' || obj.match(/^\\s+$/) ){\n          return true; // empty string is empty\n        }\n      }\n      \n      return false; // otherwise, we don't know what we've got\n    },\n    \n    nonemptyString: function(obj){\n      if( obj && $$.is.string(obj) && obj !== '' && !obj.match(/^\\s+$/) ){\n        return true;\n      }\n\n      return false;\n    },\n\n    domElement: function(obj){\n      if( typeof HTMLElement === 'undefined' ){\n        return false; // we're not in a browser so it doesn't matter\n      } else {\n        return obj instanceof HTMLElement;\n      }\n    },\n\n    boundingBox: function(obj){\n      return $$.is.plainObject(obj) && \n        $$.is.number(obj.x1) && $$.is.number(obj.x2) &&\n        $$.is.number(obj.y1) && $$.is.number(obj.y2)\n      ;\n    },\n\n    touch: function(){\n      return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );\n    },\n\n    gecko: function(){\n      return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);\n    },\n\n    webkit: function(){\n      return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);\n    },\n\n    chromium: function(){\n      return typeof chrome !== 'undefined';\n    },\n\n    khtml: function(){\n      return navigator.vendor.match(/kde/i); // TODO probably a better way to detect this...\n    },\n\n    khtmlEtc: function(){\n      return $$.is.khtml() || $$.is.webkit() || $$.is.blink();\n    },\n\n    trident: function(){\n       return typeof ActiveXObject !== 'undefined' || /*@cc_on!@*/false;\n    },\n\n    windows: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Win/i);\n    },\n\n    mac: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Mac/i);\n    },\n\n    linux: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Linux/i);\n    },\n\n    unix: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/X11/i);\n    }\n  };  \n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n;(function($$, window){ 'use strict';\n  \n  // utility functions only for internal use\n\n  $$.util = {\n\n    // the jquery extend() function\n    // NB: modified to use $$.is etc since we can't use jquery functions\n    extend: function() {\n      var options, name, src, copy, copyIsArray, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n      // Handle a deep copy situation\n      if ( typeof target === 'boolean' ) {\n        deep = target;\n        target = arguments[1] || {};\n        // skip the boolean and the target\n        i = 2;\n      }\n\n      // Handle case when target is a string or something (possible in deep copy)\n      if ( typeof target !== 'object' && !$$.is.fn(target) ) {\n        target = {};\n      }\n\n      // extend jQuery itself if only one argument is passed\n      if ( length === i ) {\n        target = this;\n        --i;\n      }\n\n      for ( ; i < length; i++ ) {\n        // Only deal with non-null/undefined values\n        if ( (options = arguments[ i ]) != null ) {\n          // Extend the base object\n          for ( name in options ) {\n            src = target[ name ];\n            copy = options[ name ];\n\n            // Prevent never-ending loop\n            if ( target === copy ) {\n              continue;\n            }\n\n            // Recurse if we're merging plain objects or arrays\n            if ( deep && copy && ( $$.is.plainObject(copy) || (copyIsArray = $$.is.array(copy)) ) ) {\n              if ( copyIsArray ) {\n                copyIsArray = false;\n                clone = src && $$.is.array(src) ? src : [];\n\n              } else {\n                clone = src && $$.is.plainObject(src) ? src : {};\n              }\n\n              // Never move original objects, clone them\n              target[ name ] = $$.util.extend( deep, clone, copy );\n\n            // Don't bring in undefined values\n            } else if ( copy !== undefined ) {\n              target[ name ] = copy;\n            }\n          }\n        }\n      }\n\n      // Return the modified object\n      return target;\n    },\n\n    // require that pulls in module from commonjs, amd, or window (falling back until found)\n    require: function( name, callback, options ){\n      var ret;\n      options = $$.util.extend({\n        msgIfNotFound: true\n      }, options);\n\n      var done = false;\n      var fulfil = function( ret ){\n        done = true;\n        callback( ret );\n      };\n\n      var checkWindow = function( next ){\n        if( window ){ // detected browser/window env\n          ret = window[ name ];\n        }\n\n        if( ret !== undefined ){ fulfil(ret); }\n        if( next ){ next(); }\n      };\n      var onCheckWindowDone = function(){\n        if( !done ){\n          checkCommonJs( onCheckCommonJsDone );\n        }\n      };\n\n      var checkCommonJs = function( next ){\n        if( typeof module !== 'undefined' && module.exports && __webpack_require__(2) ){ // detected commonjs env\n          ret = __webpack_require__(2)(name); // regular require\n        }\n\n        if( ret !== undefined ){ fulfil(ret); }\n        if( next ){ next(); }\n      };\n      var onCheckCommonJsDone = function(){\n        if( !done ){\n          checkAmd( onCheckAmdDone );\n        }\n      };\n\n      var checkAmd = function( next ){\n        if( \"function\" !== 'undefined' && __webpack_require__(5) && __webpack_require__(2) ){ // detected amd env w/ defined module\n          !/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [ __webpack_require__(2)(name) ]; (function( nameImpl ){\n            ret = nameImpl;\n            \n            if( ret !== undefined ){ fulfil(ret); }\n            if( next ){ next(); }\n          }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}());\n        }\n      };\n      var onCheckAmdDone = function(){\n        if( !done && options.msgIfNotFound ){\n          $$.util.error('Cytoscape.js tried to pull in dependency `' + name + '` but no module (i.e. CommonJS, AMD, or window) was found');\n        }\n      };\n\n      // kick off 1st check: window\n      checkWindow( onCheckWindowDone );\n\n    },\n\n    // multiple requires in one callback\n    requires: function( names, callback ){\n      var impls = [];\n      var gotImpl = [];\n\n      var checkDone = function(){\n        for( var i = 0; i < names.length; i++ ){ // check have all impls\n          if( !gotImpl[i] ){ return; }\n        }\n\n        // otherwise, all got all impls => done\n        callback.apply( callback, impls ); \n      };\n\n      for( var i = 0; i < names.length; i++ ){ (function(){ // w/scope\n        var name = names[i];\n        var index = i;\n\n        $$.util.require(name, function(impl){\n          impls[index] = impl;\n          gotImpl[index] = true;\n\n          checkDone();\n        });\n      })(); }\n    },\n\n    // ported lodash throttle function\n    throttle: function(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (options === false) {\n        leading = false;\n      } else if ($$.is.plainObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      options = options || {};\n      options.leading = leading;\n      options.maxWait = wait;\n      options.trailing = trailing;\n\n      return $$.util.debounce(func, wait, options);\n    },\n\n    now: function(){\n      return +new Date();\n    },\n\n    // ported lodash debounce function\n    debounce: function(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!$$.is.fn(func)) {\n        return;\n      }\n      wait = Math.max(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if ($$.is.plainObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - ($$.util.now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = $$.util.now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = $$.util.now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = $$.util.now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    },\n\n    error: function( msg ){\n      if( console ){\n        if( console.error ){\n          console.error.apply( console, arguments );\n        } else if( console.log ){\n          console.log.apply( console, arguments );\n        } else {\n          throw msg;\n        }\n      } else {\n        throw msg;\n      }\n    },    \n\n    clone: function( obj ){\n      var target = {};\n      for (var i in obj) {\n        if ( obj.hasOwnProperty(i) ) { // TODO is this hasOwnProperty() call necessary for our use?\n          target[i] = obj[i];\n        }\n      }\n      return target;\n    },\n\n    // gets a shallow copy of the argument\n    copy: function( obj ){\n      if( obj == null ){\n        return obj;\n      } if( $$.is.array(obj) ){\n        return obj.slice();\n      } else if( $$.is.plainObject(obj) ){\n        return $$.util.clone( obj );\n      } else {\n        return obj;\n      }\n    },\n    \n    // makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n    makeBoundingBox: function( bb ){\n      if( bb.x1 != null && bb.y1 != null ){\n        if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){\n          return {\n            x1: bb.x1,\n            y1: bb.y1,\n            x2: bb.x2,\n            y2: bb.y2,\n            w: bb.x2 - bb.x1,\n            h: bb.y2 - bb.y1\n          };\n        } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){\n          return {\n            x1: bb.x1,\n            y1: bb.y1,\n            x2: bb.x1 + bb.w,\n            y2: bb.y1 + bb.h,\n            w: bb.w,\n            h: bb.h\n          };\n        }\n      } \n    },\n\n    // has anything been set in the map\n    mapEmpty: function( map ){\n      var empty = true;\n\n      if( map != null ){\n        for(var i in map){ // jshint ignore:line\n          empty = false;\n          break;\n        }\n      }\n\n      return empty;\n    },\n\n    // pushes to the array at the end of a map (map may not be built)\n    pushMap: function( options ){\n      var array = $$.util.getMap(options);\n\n      if( array == null ){ // if empty, put initial array\n        $$.util.setMap( $.extend({}, options, {\n          value: [ options.value ]\n        }) );\n      } else {\n        array.push( options.value );\n      }\n    },\n\n    // sets the value in a map (map may not be built)\n    setMap: function( options ){\n      var obj = options.map;\n      var key;\n      var keys = options.keys;\n      var l = keys.length;\n\n      for(var i = 0; i < l; i++){\n        var key = keys[i];\n\n        if( $$.is.plainObject( key ) ){\n          $$.util.error('Tried to set map with object key');\n        }\n\n        if( i < keys.length - 1 ){\n          \n          // extend the map if necessary\n          if( obj[key] == null ){\n            obj[key] = {};\n          }\n          \n          obj = obj[key];\n        } else {\n          // set the value\n          obj[key] = options.value;\n        }\n      }\n    },\n    \n    // gets the value in a map even if it's not built in places\n    getMap: function( options ){\n      var obj = options.map;\n      var keys = options.keys;\n      var l = keys.length;\n      \n      for(var i = 0; i < l; i++){\n        var key = keys[i];\n\n        if( $$.is.plainObject( key ) ){\n          $$.util.error('Tried to get map with object key');\n        }\n\n        obj = obj[key];\n        \n        if( obj == null ){\n          return obj;\n        }\n      }\n      \n      return obj;\n    },\n\n    // deletes the entry in the map\n    deleteMap: function( options ){\n      var obj = options.map;\n      var keys = options.keys;\n      var l = keys.length;\n      var keepChildren = options.keepChildren;\n      \n      for(var i = 0; i < l; i++){\n        var key = keys[i];\n\n        if( $$.is.plainObject( key ) ){\n          $$.util.error('Tried to delete map with object key');\n        }\n\n        var lastKey = i === options.keys.length - 1;\n        if( lastKey ){\n          \n          if( keepChildren ){ // then only delete child fields not in keepChildren\n            for( var child in obj ){\n              if( !keepChildren[child] ){\n                obj[child] = undefined;\n              }\n            }\n          } else {\n            obj[key] = undefined;\n          }\n\n        } else {\n          obj = obj[key];\n        }\n      }\n    },\n    \n    capitalize: function(str){\n      if( $$.is.emptyString(str) ){\n        return str;\n      }\n      \n      return str.charAt(0).toUpperCase() + str.substring(1);\n    },\n\n    camel2dash: function( str ){\n      var ret = [];\n\n      for( var i = 0; i < str.length; i++ ){\n        var ch = str[i];\n        var chLowerCase = ch.toLowerCase();\n        var isUpperCase = ch !== chLowerCase;\n\n        if( isUpperCase ){\n          ret.push( '-' );\n          ret.push( chLowerCase );\n        } else {\n          ret.push( ch );\n        }\n      }\n\n      var noUpperCases = ret.length === str.length;\n      if( noUpperCases ){ return str; } // cheaper than .join()\n\n      return ret.join('');\n    },\n\n    dash2camel: function( str ){\n      var ret = [];\n      var nextIsUpper = false;\n\n      for( var i = 0; i < str.length; i++ ){\n        var ch = str[i];\n        var isDash = ch === '-';\n\n        if( isDash ){\n          nextIsUpper = true;\n        } else {\n          if( nextIsUpper ){\n            ret.push( ch.toUpperCase() );\n          } else {\n            ret.push( ch );\n          }\n\n          nextIsUpper = false;\n        }\n      }\n\n      return ret.join('');\n    },\n\n    // strip spaces from beginning of string and end of string\n    trim: function( str ){\n      var first, last;\n\n      // find first non-space char\n      for( first = 0; first < str.length && str[first] === ' '; first++ ){}\n\n      // find last non-space char\n      for( last = str.length - 1; last > first && str[last] === ' '; last-- ){}\n\n      return str.substring(first, last + 1);\n    },\n\n    // get [r, g, b] from #abc or #aabbcc\n    hex2tuple: function( hex ){\n      if( !(hex.length === 4 || hex.length === 7) || hex[0] !== \"#\" ){ return; }\n\n      var shortHex = hex.length === 4;\n      var r, g, b;\n      var base = 16;\n\n      if( shortHex ){\n        r = parseInt( hex[1] + hex[1], base );\n        g = parseInt( hex[2] + hex[2], base );\n        b = parseInt( hex[3] + hex[3], base );\n      } else {\n        r = parseInt( hex[1] + hex[2], base );\n        g = parseInt( hex[3] + hex[4], base );\n        b = parseInt( hex[5] + hex[6], base );\n      }\n\n      return [r, g, b];\n    },\n\n    // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n    hsl2tuple: function( hsl ){\n      var ret;\n      var h, s, l, a, r, g, b;\n      function hue2rgb(p, q, t){\n        if(t < 0) t += 1;\n        if(t > 1) t -= 1;\n        if(t < 1/6) return p + (q - p) * 6 * t;\n        if(t < 1/2) return q;\n        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n        return p;\n      }\n\n      var m = new RegExp(\"^\" + $$.util.regex.hsla + \"$\").exec(hsl);\n      if( m ){\n\n        // get hue\n        h = parseInt( m[1] ); \n        if( h < 0 ){\n          h = ( 360 - (-1*h % 360) ) % 360;\n        } else if( h > 360 ){\n          h = h % 360;\n        }\n        h /= 360; // normalise on [0, 1]\n\n        s = parseFloat( m[2] );\n        if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]\n        s = s/100; // normalise on [0, 1]\n\n        l = parseFloat( m[3] );\n        if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]\n        l = l/100; // normalise on [0, 1]\n\n        a = m[4];\n        if( a !== undefined ){\n          a = parseFloat( a );\n\n          if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]\n        }\n\n        // now, convert to rgb\n        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n        if( s === 0 ){\n          r = g = b = Math.round(l * 255); // achromatic\n        } else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );\n          g = Math.round( 255 * hue2rgb(p, q, h) );\n          b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );\n        }\n\n        ret = [r, g, b, a];\n      }\n\n      return ret;\n    },\n\n    // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n    rgb2tuple: function( rgb ){\n      var ret;\n\n      var m = new RegExp(\"^\" + $$.util.regex.rgba + \"$\").exec(rgb);\n      if( m ){\n        ret = [];\n\n        var isPct = [];\n        for( var i = 1; i <= 3; i++ ){\n          var channel = m[i];\n\n          if( channel[ channel.length - 1 ] === \"%\" ){\n            isPct[i] = true;\n          }\n          channel = parseFloat( channel );\n\n          if( isPct[i] ){\n            channel = channel/100 * 255; // normalise to [0, 255]\n          }\n\n          if( channel < 0 || channel > 255 ){ return; } // invalid channel value\n\n          ret.push( Math.floor(channel) );\n        }\n\n        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n        var allArePct = isPct[1] && isPct[2] && isPct[3];\n        if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is\n\n        var alpha = m[4];\n        if( alpha !== undefined ){\n          alpha = parseFloat( alpha );\n\n          if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value\n\n          ret.push( alpha );\n        }\n      }\n\n      return ret;\n    },\n\n    colorname2tuple: function( color ){\n      return $$.util.colors[ color.toLowerCase() ];\n    },\n\n    color2tuple: function( color ){\n      return ( $$.is.array(color) ? color : null ) \n        || $$.util.colorname2tuple(color)\n        || $$.util.hex2tuple(color)\n        || $$.util.rgb2tuple(color)\n        || $$.util.hsl2tuple(color);\n    },\n\n    tuple2hex: function( tuple ){\n      var r = tuple[0];\n      var g = tuple[1];\n      var b = tuple[2];\n\n      function ch2hex( ch ){\n        var hex = ch.toString(16);\n\n        if( hex.length === 1 ){\n          hex = '0' + hex;\n        }\n\n        return hex;\n      }\n\n      return '#' + ch2hex(r) + ch2hex(g) + ch2hex(b);\n    },\n\n    colors: {\n      // special colour names\n      transparent:      [0,0,0,0], // NB alpha === 0\n\n      // regular colours\n      aliceblue:        [240,248,255],\n      antiquewhite:      [250,235,215],\n      aqua:          [0,255,255],\n      aquamarine:        [127,255,212],\n      azure:          [240,255,255],\n      beige:          [245,245,220],\n      bisque:          [255,228,196],\n      black:          [0,0,0],\n      blanchedalmond:      [255,235,205],\n      blue:          [0,0,255],\n      blueviolet:        [138,43,226],\n      brown:          [165,42,42],\n      burlywood:        [222,184,135],\n      cadetblue:        [95,158,160],\n      chartreuse:        [127,255,0],\n      chocolate:        [210,105,30],\n      coral:          [255,127,80],\n      cornflowerblue:      [100,149,237],\n      cornsilk:        [255,248,220],\n      crimson:        [220,20,60],\n      cyan:          [0,255,255],\n      darkblue:        [0,0,139],\n      darkcyan:        [0,139,139],\n      darkgoldenrod:      [184,134,11],\n      darkgray:        [169,169,169],\n      darkgreen:        [0,100,0],\n      darkgrey:        [169,169,169],\n      darkkhaki:        [189,183,107],\n      darkmagenta:      [139,0,139],\n      darkolivegreen:      [85,107,47],\n      darkorange:        [255,140,0],\n      darkorchid:        [153,50,204],\n      darkred:        [139,0,0],\n      darksalmon:        [233,150,122],\n      darkseagreen:      [143,188,143],\n      darkslateblue:      [72,61,139],\n      darkslategray:      [47,79,79],\n      darkslategrey:      [47,79,79],\n      darkturquoise:      [0,206,209],\n      darkviolet:        [148,0,211],\n      deeppink:        [255,20,147],\n      deepskyblue:      [0,191,255],\n      dimgray:        [105,105,105],\n      dimgrey:        [105,105,105],\n      dodgerblue:        [30,144,255],\n      firebrick:        [178,34,34],\n      floralwhite:      [255,250,240],\n      forestgreen:      [34,139,34],\n      fuchsia:        [255,0,255],\n      gainsboro:        [220,220,220],\n      ghostwhite:        [248,248,255],\n      gold:          [255,215,0],\n      goldenrod:        [218,165,32],\n      gray:          [128,128,128],\n      grey:          [128,128,128],\n      green:          [0,128,0],\n      greenyellow:      [173,255,47],\n      honeydew:        [240,255,240],\n      hotpink:        [255,105,180],\n      indianred:        [205,92,92],\n      indigo:          [75,0,130],\n      ivory:          [255,255,240],\n      khaki:          [240,230,140],\n      lavender:        [230,230,250],\n      lavenderblush:      [255,240,245],\n      lawngreen:        [124,252,0],\n      lemonchiffon:      [255,250,205],\n      lightblue:        [173,216,230],\n      lightcoral:        [240,128,128],\n      lightcyan:        [224,255,255],\n      lightgoldenrodyellow:  [250,250,210],\n      lightgray:        [211,211,211],\n      lightgreen:        [144,238,144],\n      lightgrey:        [211,211,211],\n      lightpink:        [255,182,193],\n      lightsalmon:      [255,160,122],\n      lightseagreen:      [32,178,170],\n      lightskyblue:      [135,206,250],\n      lightslategray:      [119,136,153],\n      lightslategrey:      [119,136,153],\n      lightsteelblue:      [176,196,222],\n      lightyellow:      [255,255,224],\n      lime:          [0,255,0],\n      limegreen:        [50,205,50],\n      linen:          [250,240,230],\n      magenta:        [255,0,255],\n      maroon:          [128,0,0],\n      mediumaquamarine:    [102,205,170],\n      mediumblue:        [0,0,205],\n      mediumorchid:      [186,85,211],\n      mediumpurple:      [147,112,219],\n      mediumseagreen:      [60,179,113],\n      mediumslateblue:    [123,104,238],\n      mediumspringgreen:    [0,250,154],\n      mediumturquoise:    [72,209,204],\n      mediumvioletred:    [199,21,133],\n      midnightblue:      [25,25,112],\n      mintcream:        [245,255,250],\n      mistyrose:        [255,228,225],\n      moccasin:        [255,228,181],\n      navajowhite:      [255,222,173],\n      navy:          [0,0,128],\n      oldlace:        [253,245,230],\n      olive:          [128,128,0],\n      olivedrab:        [107,142,35],\n      orange:          [255,165,0],\n      orangered:        [255,69,0],\n      orchid:          [218,112,214],\n      palegoldenrod:      [238,232,170],\n      palegreen:        [152,251,152],\n      paleturquoise:      [175,238,238],\n      palevioletred:      [219,112,147],\n      papayawhip:        [255,239,213],\n      peachpuff:        [255,218,185],\n      peru:          [205,133,63],\n      pink:          [255,192,203],\n      plum:          [221,160,221],\n      powderblue:        [176,224,230],\n      purple:          [128,0,128],\n      red:          [255,0,0],\n      rosybrown:        [188,143,143],\n      royalblue:        [65,105,225],\n      saddlebrown:      [139,69,19],\n      salmon:          [250,128,114],\n      sandybrown:        [244,164,96],\n      seagreen:        [46,139,87],\n      seashell:        [255,245,238],\n      sienna:          [160,82,45],\n      silver:          [192,192,192],\n      skyblue:        [135,206,235],\n      slateblue:        [106,90,205],\n      slategray:        [112,128,144],\n      slategrey:        [112,128,144],\n      snow:          [255,250,250],\n      springgreen:      [0,255,127],\n      steelblue:        [70,130,180],\n      tan:          [210,180,140],\n      teal:          [0,128,128],\n      thistle:        [216,191,216],\n      tomato:          [255,99,71],\n      turquoise:        [64,224,208],\n      violet:          [238,130,238],\n      wheat:          [245,222,179],\n      white:          [255,255,255],\n      whitesmoke:        [245,245,245],\n      yellow:          [255,255,0],\n      yellowgreen:      [154,205,50]\n    }\n      \n  };\n\n  $$.util.regex = {};\n  \n  $$.util.regex.number = \"(?:[-]?\\\\d*\\\\.\\\\d+|[-]?\\\\d+|[-]?\\\\d*\\\\.\\\\d+[eE]\\\\d+)\";\n  \n  $$.util.regex.rgba = \"rgb[a]?\\\\((\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%]?)(?:\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"))?\\\\)\";\n  $$.util.regex.rgbaNoBackRefs = \"rgb[a]?\\\\((?:\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%]?)(?:\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"))?\\\\)\";\n  \n  $$.util.regex.hsla = \"hsl[a]?\\\\((\"+ $$.util.regex.number +\")\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%])\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%])(?:\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"))?\\\\)\";\n  $$.util.regex.hslaNoBackRefs = \"hsl[a]?\\\\((?:\"+ $$.util.regex.number +\")\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%])\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%])(?:\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"))?\\\\)\";\n  \n  $$.util.regex.hex3 = \"\\\\#[0-9a-fA-F]{3}\";\n  $$.util.regex.hex6 = \"\\\\#[0-9a-fA-F]{6}\";\n\n  var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||  \n        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );\n\n  raf = raf || function(fn){ if(fn){ setTimeout(fn, 1000/60); } };\n\n  $$.util.requestAnimationFrame = function(fn){\n    raf( fn );\n  };\n\n})( cytoscape, typeof window === 'undefined' ? null : window  );\n\n;(function($$){ 'use strict';\n  \n  $$.math = {};\n  \n  $$.math.signum = function(x){\n    if( x > 0 ){\n      return 1;\n    } else if( x < 0 ){\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n\n  $$.math.distance = function( p1, p2 ){\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n\n    return Math.sqrt( dx*dx + dy*dy );\n  };\n\n  // from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves\n  $$.math.qbezierAt = function(p0, p1, p2, t){\n    return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;\n  };\n\n  $$.math.qbezierPtAt = function(p0, p1, p2, t){\n    return {\n      x: $$.math.qbezierAt( p0.x, p1.x, p2.x, t ),\n      y: $$.math.qbezierAt( p0.y, p1.y, p2.y, t )\n    };\n  };\n\n  $$.math.boundingBoxesIntersect = function( bb1, bb2 ){\n    // case: one bb to right of other\n    if( bb1.x1 > bb2.x2 ){ return false; }\n    if( bb2.x1 > bb1.x2 ){ return false; }\n\n    // case: one bb to left of other\n    if( bb1.x2 < bb2.x1 ){ return false; }\n    if( bb2.x2 < bb1.x1 ){ return false; }\n\n    // case: one bb above other\n    if( bb1.y2 < bb2.y1 ){ return false; }\n    if( bb2.y2 < bb1.y1 ){ return false; }\n\n    // case: one bb below other\n    if( bb1.y1 > bb2.y2 ){ return false; }\n    if( bb2.y1 > bb1.y2 ){ return false; }\n\n    // otherwise, must have some overlap\n    return true;\n  };\n\n  $$.math.inBoundingBox = function( bb, x, y ){\n    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n  };\n\n  $$.math.pointInBoundingBox = function( bb, pt ){\n    return this.inBoundingBox( bb, pt.x, pt.y );\n  };\n\n  $$.math.roundRectangleIntersectLine = function(\n    x, y, nodeX, nodeY, width, height, padding) {\n    \n    var cornerRadius = this.getRoundRectangleRadius(width, height);\n    \n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    \n    // Check intersections with straight line segments\n    var straightLineIntersections;\n    \n    // Top segment, left to right\n    {\n      var topStartX = nodeX - halfWidth + cornerRadius - padding;\n      var topStartY = nodeY - halfHeight - padding;\n      var topEndX = nodeX + halfWidth - cornerRadius + padding;\n      var topEndY = topStartY;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Right segment, top to bottom\n    {\n      var rightStartX = nodeX + halfWidth + padding;\n      var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n      var rightEndX = rightStartX;\n      var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Bottom segment, left to right\n    {\n      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n      var bottomStartY = nodeY + halfHeight + padding;\n      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n      var bottomEndY = bottomStartY;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Left segment, top to bottom\n    {\n      var leftStartX = nodeX - halfWidth - padding;\n      var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n      var leftEndX = leftStartX;\n      var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Check intersections with arc segments\n    var arcIntersections;\n    \n    // Top Left\n    {\n      var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] <= topLeftCenterX\n        && arcIntersections[1] <= topLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    \n    // Top Right\n    {\n      var topRightCenterX = nodeX + halfWidth - cornerRadius;\n      var topRightCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        topRightCenterX, topRightCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] >= topRightCenterX\n        && arcIntersections[1] <= topRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    \n    // Bottom Right\n    {\n      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] >= bottomRightCenterX\n        && arcIntersections[1] >= bottomRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    \n    // Bottom Left\n    {\n      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] <= bottomLeftCenterX\n        && arcIntersections[1] >= bottomLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n\n    return []; // if nothing\n  };\n  \n  $$.math.roundRectangleIntersectBox = function(\n    boxX1, boxY1, boxX2, boxY2, width, height, centerX, centerY, padding) {\n    \n    // We have the following shpae\n    \n    //    _____\n    //  _|     |_\n    // |         |\n    // |_       _|\n    //   |_____|\n    //\n    // With a quarter circle at each corner.\n    \n    var cornerRadius = this.getRoundRectangleRadius(width, height);\n    \n    var hBoxTopLeftX = centerX - width / 2 - padding;\n    var hBoxTopLeftY = centerY - height / 2 + cornerRadius - padding;\n    var hBoxBottomRightX = centerX + width / 2 + padding;\n    var hBoxBottomRightY = centerY + height / 2 - cornerRadius + padding;\n    \n    var vBoxTopLeftX = centerX - width / 2 + cornerRadius - padding;\n    var vBoxTopLeftY = centerY - height / 2 - padding;\n    var vBoxBottomRightX = centerX + width / 2 - cornerRadius + padding;\n    var vBoxBottomRightY = centerY + height / 2 + padding;\n    \n    // Check if the box is out of bounds\n    var boxMinX = Math.min(boxX1, boxX2);\n    var boxMaxX = Math.max(boxX1, boxX2);\n    var boxMinY = Math.min(boxY1, boxY2);\n    var boxMaxY = Math.max(boxY1, boxY2);\n    \n    if (boxMaxX < hBoxTopLeftX) {\n      return false;\n    } else if (boxMinX > hBoxBottomRightX) {\n      return false;\n    }\n    \n    if (boxMaxY < vBoxTopLeftY) {\n      return false;\n    } else if (boxMinY > vBoxBottomRightY) {\n      return false;\n    }\n    \n    // Check if an hBox point is in given box\n    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX\n        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX\n        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX\n        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX\n        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    // Check if a given point box is in the hBox\n    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX\n      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX\n      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX\n      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX\n      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    // Check if an vBox point is in given box\n    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX\n        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX\n        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX\n        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX\n        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    // Check if a given point box is in the vBox\n    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX\n      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX\n      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX\n      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX\n      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    // Lastly, check if one of the ellipses coincide with the box\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {\n      return true;\n    }\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxTopLeftY + padding)) {\n      return true;\n    }\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxBottomRightY - padding)) {\n      return true;\n    }\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxBottomRightY - padding)) {\n      return true;\n    }\n    \n    return false;\n  };\n  \n  // @O Approximate collision functions\n  $$.math.checkInBoundingCircle = function(\n    x, y, farthestPointSqDistance, padding, width, height, centerX, centerY) {\n    \n    x = (x - centerX) / (width + padding);\n    y = (y - centerY) / (height + padding);\n    \n    return (x * x + y * y) <= farthestPointSqDistance;\n  };\n  \n  $$.math.boxInBezierVicinity = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {\n    \n    // Return values:\n    // 0 - curve is not in box\n    // 1 - curve may be in box; needs precise check\n    // 2 - curve is in box\n    \n    // midpoint\n    var midX = 0.25 * x1 + 0.5 * x2 + 0.25 * x3;\n    var midY = 0.25 * y1 + 0.5 * y2 + 0.25 * y3;\n\n    var boxMinX = Math.min(x1box, x2box) - tolerance;\n    var boxMinY = Math.min(y1box, y2box) - tolerance;\n    var boxMaxX = Math.max(x1box, x2box) + tolerance;\n    var boxMaxY = Math.max(y1box, y2box) + tolerance;\n    \n    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) { // (x1, y1) in box\n      return 1;\n    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) { // (x3, y3) in box\n      return 1;\n    } else if (midX >= boxMinX && midX <= boxMaxX && midY >= boxMinY && midY <= boxMaxY) { // (midX, midY) in box\n      return 1;\n    } else if (x2 >= boxMinX && x2 <= boxMaxX && y2 >= boxMinY && y2 <= boxMaxY) { // ctrl pt in box\n      return 1;\n    }\n    \n    var curveMinX = Math.min(x1, midX, x3);\n    var curveMinY = Math.min(y1, midY, y3);\n    var curveMaxX = Math.max(x1, midX, x3);\n    var curveMaxY = Math.max(y1, midY, y3);\n    \n    /*\n    console.log(curveMinX + \", \" + curveMinY + \", \" + curveMaxX \n      + \", \" + curveMaxY);\n    if (curveMinX == undefined) {\n      console.log(\"undefined curveMinX: \" + x1 + \", \" + x2 + \", \" + x3);\n    }\n    */\n    \n    if (curveMinX > boxMaxX\n      || curveMaxX < boxMinX\n      || curveMinY > boxMaxY\n      || curveMaxY < boxMinY) {\n      \n      return 0;  \n    }\n    \n    return 1;\n  };\n\n  $$.math.checkBezierInBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {\n\n    function sampleInBox(t){\n      var x = $$.math.qbezierAt(x1, x2, x3, t);\n      var y = $$.math.qbezierAt(y1, y2, y3, t);\n\n      return x1box <= x && x <= x2box\n        && y1box <= y && y <= y2box\n      ;\n    }\n\n    for( var t = 0; t <= 1; t += 0.25 ){\n      if( !sampleInBox(t) ){\n        return false;\n      }\n    }\n\n    return true;\n  };\n  \n  $$.math.checkStraightEdgeInBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {\n\n    return x1box <= x1 && x1 <= x2box\n      && x1box <= x2 && x2 <= x2box\n      && y1box <= y1 && y1 <= y2box\n      && y1box <= y2 && y2 <= y2box\n    ;\n  };\n\n  $$.math.checkStraightEdgeCrossesBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {\n    \n   //console.log(arguments);\n    \n    var boxMinX = Math.min(x1box, x2box) - tolerance;\n    var boxMinY = Math.min(y1box, y2box) - tolerance;\n    var boxMaxX = Math.max(x1box, x2box) + tolerance;\n    var boxMaxY = Math.max(y1box, y2box) + tolerance;\n    \n    // Check left + right bounds\n    var aX = x2 - x1;\n    var bX = x1;\n    var yValue;\n    \n    // Top and bottom\n    var aY = y2 - y1;\n    var bY = y1;\n    var xValue;\n    \n    if (Math.abs(aX) < 0.0001) {\n      return (x1 >= boxMinX && x1 <= boxMaxX\n        && Math.min(y1, y2) <= boxMinY\n        && Math.max(y1, y2) >= boxMaxY);  \n    }\n    \n    var tLeft = (boxMinX - bX) / aX;\n    if (tLeft > 0 && tLeft <= 1) {\n      yValue = aY * tLeft + bY;\n      if (yValue >= boxMinY && yValue <= boxMaxY) {\n        return true;\n      } \n    }\n    \n    var tRight = (boxMaxX - bX) / aX;\n    if (tRight > 0 && tRight <= 1) {\n      yValue = aY * tRight + bY;\n      if (yValue >= boxMinY && yValue <= boxMaxY) {\n        return true;\n      } \n    }\n    \n    var tTop = (boxMinY - bY) / aY;\n    if (tTop > 0 && tTop <= 1) {\n      xValue = aX * tTop + bX;\n      if (xValue >= boxMinX && xValue <= boxMaxX) {\n        return true;\n      } \n    }\n    \n    var tBottom = (boxMaxY - bY) / aY;\n    if (tBottom > 0 && tBottom <= 1) {\n      xValue = aX * tBottom + bX;\n      if (xValue >= boxMinX && xValue <= boxMaxX) {\n        return true;\n      } \n    }\n    \n    return false;\n  };\n  \n  $$.math.checkBezierCrossesBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {\n    \n    var boxMinX = Math.min(x1box, x2box) - tolerance;\n    var boxMinY = Math.min(y1box, y2box) - tolerance;\n    var boxMaxX = Math.max(x1box, x2box) + tolerance;\n    var boxMaxY = Math.max(y1box, y2box) + tolerance;\n    \n    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) {\n      return true;\n    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) {\n      return true;\n    }\n    \n    var aX = x1 - 2 * x2 + x3;\n    var bX = -2 * x1 + 2 * x2;\n    var cX = x1;\n\n    var xIntervals = [];\n    \n    if (Math.abs(aX) < 0.0001) {\n      var leftParam = (boxMinX - x1) / bX;\n      var rightParam = (boxMaxX - x1) / bX;\n      \n      xIntervals.push(leftParam, rightParam);\n    } else {\n      // Find when x coordinate of the curve crosses the left side of the box\n      var discriminantX1 = bX * bX - 4 * aX * (cX - boxMinX);\n      var tX1, tX2;\n      if (discriminantX1 > 0) {\n        var sqrt = Math.sqrt(discriminantX1);\n        tX1 = (-bX + sqrt) / (2 * aX);\n        tX2 = (-bX - sqrt) / (2 * aX);\n        \n        xIntervals.push(tX1, tX2);\n      }\n      \n      var discriminantX2 = bX * bX - 4 * aX * (cX - boxMaxX);\n      var tX3, tX4;\n      if (discriminantX2 > 0) {\n        var sqrt = Math.sqrt(discriminantX2);\n        tX3 = (-bX + sqrt) / (2 * aX);\n        tX4 = (-bX - sqrt) / (2 * aX);\n        \n        xIntervals.push(tX3, tX4);\n      }\n    }\n    \n    xIntervals.sort(function(a, b) { return a - b; });\n    \n    var aY = y1 - 2 * y2 + y3;\n    var bY = -2 * y1 + 2 * y2;\n    var cY = y1;\n    \n    var yIntervals = [];\n    \n    if (Math.abs(aY) < 0.0001) {\n      var topParam = (boxMinY - y1) / bY;\n      var bottomParam = (boxMaxY - y1) / bY;\n      \n      yIntervals.push(topParam, bottomParam);\n    } else {\n      var discriminantY1 = bY * bY - 4 * aY * (cY - boxMinY);\n      \n      var tY1, tY2;\n      if (discriminantY1 > 0) {\n        var sqrt = Math.sqrt(discriminantY1);\n        tY1 = (-bY + sqrt) / (2 * aY);\n        tY2 = (-bY - sqrt) / (2 * aY);\n        \n        yIntervals.push(tY1, tY2);\n      }\n  \n      var discriminantY2 = bY * bY - 4 * aY * (cY - boxMaxY);\n      \n      var tY3, tY4;\n      if (discriminantY2 > 0) {\n        var sqrt = Math.sqrt(discriminantY2);\n        tY3 = (-bY + sqrt) / (2 * aY);\n        tY4 = (-bY - sqrt) / (2 * aY);\n        \n        yIntervals.push(tY3, tY4);\n      }\n    }\n        \n    yIntervals.sort(function(a, b) { return a - b; });\n\n    for (var index = 0; index < xIntervals.length; index += 2) {\n      for (var yIndex = 1; yIndex < yIntervals.length; yIndex += 2) {\n        \n        // Check if there exists values for the Bezier curve\n        // parameter between 0 and 1 where both the curve's\n        // x and y coordinates are within the bounds specified by the box\n        if (xIntervals[index] < yIntervals[yIndex]\n          && yIntervals[yIndex] >= 0.0\n          && xIntervals[index] <= 1.0\n          && xIntervals[index + 1] > yIntervals[yIndex - 1]\n          && yIntervals[yIndex - 1] <= 1.0\n          && xIntervals[index + 1] >= 0.0) {\n          \n          return true;\n        }\n      }\n    }\n    \n    return false;\n  };\n  \n  $$.math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){\n    var t = tolerance;\n\n    var x1 = Math.min(lx1, lx2);\n    var x2 = Math.max(lx1, lx2);\n    var y1 = Math.min(ly1, ly2);\n    var y2 = Math.max(ly1, ly2);\n\n    return x1 - t <= x && x <= x2 + t\n      && y1 - t <= y && y <= y2 + t;\n  };\n\n  $$.math.inBezierVicinity = function(\n    x, y, x1, y1, x2, y2, x3, y3, toleranceSquared) {\n\n    var bb = {\n      x1: Math.min( x1, x3, x2 ),\n      x2: Math.max( x1, x3, x2 ),\n      y1: Math.min( y1, y3, y2 ),\n      y2: Math.max( y1, y3, y2 )\n    };\n\n    // if outside the rough bounding box for the bezier, then it can't be a hit\n    if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){\n      // console.log('bezier out of rough bb')\n      return false;\n    } else {\n      // console.log('do more expensive check');\n      return true;\n    }\n\n  };\n  \n  $$.math.solveCubic = function(a, b, c, d, result) {\n    \n    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n    // r is the real component, i is the imaginary component\n\n    // An implementation of the Cardano method from the year 1545\n    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n\n    b /= a;\n    c /= a;\n    d /= a;\n    \n    var discriminant, q, r, dum1, s, t, term1, r13;\n\n    q = (3.0 * c - (b * b)) / 9.0;\n    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n    r /= 54.0;\n    \n    discriminant = q * q * q + r * r;\n    result[1] = 0;\n    term1 = (b / 3.0);\n    \n    if (discriminant > 0) {\n      s = r + Math.sqrt(discriminant);\n      s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));\n      t = r - Math.sqrt(discriminant);\n      t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));\n      result[0] = -term1 + s + t;\n      term1 += (s + t) / 2.0;\n      result[4] = result[2] = -term1;\n      term1 = Math.sqrt(3.0) * (-t + s) / 2;\n      result[3] = term1;\n      result[5] = -term1;\n      return;\n    }\n    \n    result[5] = result[3] = 0;\n    \n    if (discriminant === 0) {\n      r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));\n      result[0] = -term1 + 2.0 * r13;\n      result[4] = result[2] = -(r13 + term1);\n      return;\n    }\n    \n    q = -q;\n    dum1 = q * q * q;\n    dum1 = Math.acos(r / Math.sqrt(dum1));\n    r13 = 2.0 * Math.sqrt(q);\n    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n    \n    return;\n  };\n\n  $$.math.sqDistanceToQuadraticBezier = function(\n    x, y, x1, y1, x2, y2, x3, y3) {\n    \n    // Find minimum distance by using the minimum of the distance \n    // function between the given point and the curve\n    \n    // This gives the coefficients of the resulting cubic equation\n    // whose roots tell us where a possible minimum is\n    // (Coefficients are divided by 4)\n    \n    var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3\n      + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;\n    \n    var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3\n      + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;\n    \n    var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x\n      + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;\n      \n    var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x\n      + y1*y2 - y1*y1 + y1*y - y2*y;\n    \n    // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n    \n    var roots = [];\n    \n    // Use the cubic solving algorithm\n    this.solveCubic(a, b, c, d, roots);\n    \n    var zeroThreshold = 0.0000001;\n    \n    var params = [];\n    \n    for (var index = 0; index < 6; index += 2) {\n      if (Math.abs(roots[index + 1]) < zeroThreshold\n          && roots[index] >= 0\n          && roots[index] <= 1.0) {\n        params.push(roots[index]);\n      }\n    }\n    \n    params.push(1.0);\n    params.push(0.0);\n    \n    var minDistanceSquared = -1;\n    var closestParam;\n    \n    var curX, curY, distSquared;\n    for (var i = 0; i < params.length; i++) {\n      curX = Math.pow(1.0 - params[i], 2.0) * x1\n        + 2.0 * (1 - params[i]) * params[i] * x2\n        + params[i] * params[i] * x3;\n        \n      curY = Math.pow(1 - params[i], 2.0) * y1\n        + 2 * (1.0 - params[i]) * params[i] * y2\n        + params[i] * params[i] * y3;\n        \n      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n      // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n      if (minDistanceSquared >= 0) {\n        if (distSquared < minDistanceSquared) {\n          minDistanceSquared = distSquared;\n          closestParam = params[i];\n        }\n      } else {\n        minDistanceSquared = distSquared;\n        closestParam = params[i];\n      }\n    }\n    \n    /*\n    debugStats.clickX = x;\n    debugStats.clickY = y;\n    \n    debugStats.closestX = Math.pow(1.0 - closestParam, 2.0) * x1\n        + 2.0 * (1.0 - closestParam) * closestParam * x2\n        + closestParam * closestParam * x3;\n        \n    debugStats.closestY = Math.pow(1.0 - closestParam, 2.0) * y1\n        + 2.0 * (1.0 - closestParam) * closestParam * y2\n        + closestParam * closestParam * y3;\n    */\n    \n    // debug(\"given: \" \n    //   + \"( \" + x + \", \" + y + \"), \" \n    //   + \"( \" + x1 + \", \" + y1 + \"), \" \n    //   + \"( \" + x2 + \", \" + y2 + \"), \"\n    //   + \"( \" + x3 + \", \" + y3 + \")\");\n    \n    \n    // debug(\"roots: \" + roots);\n    // debug(\"params: \" + params);\n    // debug(\"closest param: \" + closestParam);\n    return minDistanceSquared;\n  };\n  \n  $$.math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {\n    var offset = [x - x1, y - y1];\n    var line = [x2 - x1, y2 - y1];\n    \n    var lineSq = line[0] * line[0] + line[1] * line[1];\n    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n    \n    var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n    var adjSq = dotProduct * dotProduct / lineSq;\n    \n    if (dotProduct < 0) {\n      return hypSq;\n    }\n    \n    if (adjSq > lineSq) {\n      return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n    }\n    \n    return hypSq - adjSq;\n  };\n\n  $$.math.pointInsidePolygon = function(\n    x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n\n    //var direction = arguments[6];\n    var transformedPoints = new Array(basePoints.length);\n\n    // Gives negative angle\n    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] \n      + direction[1] * direction[1])));\n    \n    if (direction[0] < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n        \n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle);\n    \n//    console.log(\"base: \" + basePoints);\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = \n        width / 2 * (basePoints[i * 2] * cos\n          - basePoints[i * 2 + 1] * sin);\n      \n      transformedPoints[i * 2 + 1] = \n        height / 2 * (basePoints[i * 2 + 1] * cos \n          + basePoints[i * 2] * sin);\n\n      transformedPoints[i * 2] += centerX;\n      transformedPoints[i * 2 + 1] += centerY;\n    }\n    \n    var points;\n    \n    if (padding > 0) {\n      var expandedLineSet = this.expandPolygon(\n        transformedPoints,\n        -padding);\n      \n      points = this.joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n    \n    var x1, y1, x2, y2;\n    var y3;\n    \n    // Intersect with vertical line through (x, y)\n    var up = 0;\n    var down = 0;\n    for (var i = 0; i < points.length / 2; i++) {\n      \n      x1 = points[i * 2];\n      y1 = points[i * 2 + 1];\n      \n      if (i + 1 < points.length / 2) {\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n      } else {\n        x2 = points[(i + 1 - points.length / 2) * 2];\n        y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n      }\n      \n//*      console.log(\"line from (\" + x1 + \", \" + y1 + \") to (\" + x2 + \", \" + y2 + \")\");\n\n//&      console.log(x1, x, x2);\n\n      if (x1 == x && x2 == x) {\n        \n      } else if ((x1 >= x && x >= x2)\n        || (x1 <= x && x <= x2)) {\n        \n        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n        \n        if (y3 > y) {\n          up++;\n        }\n        \n        if (y3 < y) {\n          down++;\n        }\n        \n//*        console.log(y3, y);\n        \n      } else {\n//*        console.log('22');\n        continue;\n      }\n      \n    }\n    \n//*    console.log(\"up: \" + up + \", down: \" + down);\n    \n    if (up % 2 === 0) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  $$.math.joinLines = function(lineSet) {\n    \n    var vertices = new Array(lineSet.length / 2);\n    \n    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n    \n    for (var i = 0; i < lineSet.length / 4; i++) {\n      currentLineStartX = lineSet[i * 4];\n      currentLineStartY = lineSet[i * 4 + 1];\n      currentLineEndX = lineSet[i * 4 + 2];\n      currentLineEndY = lineSet[i * 4 + 3];\n      \n      if (i < lineSet.length / 4 - 1) {\n        nextLineStartX = lineSet[(i + 1) * 4];\n        nextLineStartY = lineSet[(i + 1) * 4 + 1];\n        nextLineEndX = lineSet[(i + 1) * 4 + 2];\n        nextLineEndY = lineSet[(i + 1) * 4 + 3];\n      } else {\n        nextLineStartX = lineSet[0];\n        nextLineStartY = lineSet[1];\n        nextLineEndX = lineSet[2];\n        nextLineEndY = lineSet[3];\n      }\n      \n      var intersection = this.finiteLinesIntersect(\n        currentLineStartX, currentLineStartY,\n        currentLineEndX, currentLineEndY,\n        nextLineStartX, nextLineStartY,\n        nextLineEndX, nextLineEndY,\n        true);\n      \n      vertices[i * 2] = intersection[0];\n      vertices[i * 2 + 1] = intersection[1];\n    }\n    \n    return vertices;\n  };\n\n  $$.math.expandPolygon = function(points, pad) {\n    \n    var expandedLineSet = new Array(points.length * 2);\n    \n    var currentPointX, currentPointY, nextPointX, nextPointY;\n    \n    for (var i = 0; i < points.length / 2; i++) {\n      currentPointX = points[i * 2];\n      currentPointY = points[i * 2 + 1];\n      \n      if (i < points.length / 2 - 1) {\n        nextPointX = points[(i + 1) * 2];\n        nextPointY = points[(i + 1) * 2 + 1];\n      } else {\n        nextPointX = points[0];\n        nextPointY = points[1];\n      }\n      \n      // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n      \n      // Assume CCW polygon winding\n      \n      var offsetX = (nextPointY - currentPointY);\n      var offsetY = -(nextPointX - currentPointX);\n      \n      // Normalize\n      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n      var normalizedOffsetX = offsetX / offsetLength;\n      var normalizedOffsetY = offsetY / offsetLength;\n      \n      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n    }\n    \n    return expandedLineSet;\n  };\n\n  $$.math.intersectLineEllipse = function(\n    x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n    \n    var dispX = centerX - x;\n    var dispY = centerY - y;\n    \n    dispX /= ellipseWradius;\n    dispY /= ellipseHradius;\n    \n    var len = Math.sqrt(dispX * dispX + dispY * dispY);\n    \n    var newLength = len - 1;\n    \n    if (newLength < 0) {\n      return [];\n    }\n    \n    var lenProportion = newLength / len;\n    \n    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n  };\n  \n  $$.math.dotProduct = function(\n    vec1, vec2) {\n    \n    if (vec1.length != 2 || vec2.length != 2) {\n      throw 'dot product: arguments are not vectors';\n    }\n    \n    return (vec1[0] * vec2[0] + vec1[1] * vec2[1]);\n  };\n  \n  // Returns intersections of increasing distance from line's start point\n  $$.math.intersectLineCircle = function(\n    x1, y1, x2, y2, centerX, centerY, radius) {\n    \n    // Calculate d, direction vector of line\n    var d = [x2 - x1, y2 - y1]; // Direction vector of line\n    var c = [centerX, centerY]; // Center of circle\n    var f = [x1 - centerX, y1 - centerY];\n    \n    var a = d[0] * d[0] + d[1] * d[1];\n    var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n    var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;\n    \n    var discriminant = b*b-4*a*c;\n    \n    if (discriminant < 0) {\n      return [];\n    }\n    \n    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    \n    var tMin = Math.min(t1, t2);\n    var tMax = Math.max(t1, t2);\n    var inRangeParams = [];\n    \n    if (tMin >= 0 && tMin <= 1) {\n      inRangeParams.push(tMin);\n    }\n    \n    if (tMax >= 0 && tMax <= 1) {\n      inRangeParams.push(tMax);\n    }\n    \n    if (inRangeParams.length === 0) {\n      return [];\n    }\n    \n    var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n    var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n    \n    if (inRangeParams.length > 1) {\n    \n      if (inRangeParams[0] == inRangeParams[1]) {\n        return [nearIntersectionX, nearIntersectionY];\n      } else {\n        \n        var farIntersectionX = inRangeParams[1] * d[0] + x1;\n        var farIntersectionY = inRangeParams[1] * d[1] + y1;\n      \n        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n      }\n      \n    } else {\n      return [nearIntersectionX, nearIntersectionY];\n    }\n    \n  };\n  \n  $$.math.findCircleNearPoint = function(centerX, centerY, \n    radius, farX, farY) {\n    \n    var displacementX = farX - centerX;\n    var displacementY = farY - centerY;\n    var distance = Math.sqrt(displacementX * displacementX \n      + displacementY * displacementY);\n    \n    var unitDisplacementX = displacementX / distance;\n    var unitDisplacementY = displacementY / distance;\n    \n    return [centerX + unitDisplacementX * radius, \n      centerY + unitDisplacementY * radius];\n  };\n  \n  $$.math.findMaxSqDistanceToOrigin = function(points) {\n    var maxSqDistance = 0.000001;\n    var sqDistance;\n    \n    for (var i = 0; i < points.length / 2; i++) {\n      \n      sqDistance = points[i * 2] * points[i * 2] \n        + points[i * 2 + 1] * points[i * 2 + 1];\n      \n      if (sqDistance > maxSqDistance) {\n        maxSqDistance = sqDistance;\n      }\n    }\n    \n    return maxSqDistance;\n  };\n  \n  $$.math.finiteLinesIntersect = function(\n    x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n    \n    var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n      \n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {  \n        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];\n        \n      } else {\n        if (!infiniteLines) {\n          return [];\n        } else {\n          return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];\n        }\n      }\n    } else {\n      if (ua_t === 0 || ub_t === 0) {\n\n        // Parallel, coincident lines. Check if overlap\n\n        // Check endpoint of second line\n        if ([x1, x2, x4].sort()[1] === x4) {\n          return [x4, y4];\n        }\n        \n        // Check start point of second line\n        if ([x1, x2, x3].sort()[1] === x3) {\n          return [x3, y3];\n        }\n        \n        // Endpoint of first line\n        if ([x3, x4, x2].sort()[1] === x2) {\n          return [x2, y2];\n        }\n        \n        return [];\n      } else {\n      \n        // Parallel, non-coincident\n        return [];\n      }\n    }\n  };\n  \n  // (boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n  //      cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {\n  \n  $$.math.boxIntersectEllipse = function(\n    x1, y1, x2, y2, padding, width, height, centerX, centerY) {\n    \n    if (x2 < x1) {\n      var oldX1 = x1;\n      x1 = x2;\n      x2 = oldX1;\n    }\n    \n    if (y2 < y1) {\n      var oldY1 = y1;\n      y1 = y2;\n      y2 = oldY1;\n    }\n    \n    // 4 ortho extreme points\n    var west = [centerX - width / 2 - padding, centerY];\n    var east = [centerX + width / 2 + padding, centerY];\n    var north = [centerX, centerY - height / 2 - padding];\n    var south = [centerX, centerY + height / 2 + padding];\n    \n    // out of bounds: return false\n    if (x2 < west[0]) {\n      return false;\n    }\n    \n    if (x1 > east[0]) {\n      return false;\n    }\n    \n    if (y1 > south[1]) {\n      return false;\n    }\n    \n    if (y2 < north[1]) {\n      return false;\n    }\n    \n    // 1 of 4 ortho extreme points in box: return true\n    if (x1 <= east[0] && east[0] <= x2\n        && y1 <= east[1] && east[1] <= y2) {\n      return true;\n    }\n    \n    if (x1 <= west[0] && west[0] <= x2\n        && y1 <= west[1] && west[1] <= y2) {\n      return true;\n    }\n    \n    if (x1 <= north[0] && north[0] <= x2\n        && y1 <= north[1] && north[1] <= y2) {\n      return true;\n    }\n    \n    if (x1 <= south[0] && south[0] <= x2\n        && y1 <= south[1] && south[1] <= y2) {\n      return true;\n    }\n    \n    // box corner in ellipse: return true    \n    x1 = (x1 - centerX) / (width / 2 + padding);\n    x2 = (x2 - centerX) / (width / 2 + padding);\n    \n    y1 = (y1 - centerY) / (height / 2 + padding);\n    y2 = (y2 - centerY) / (height / 2 + padding);\n    \n    if (x1 * x1 + y1 * y1 <= 1) {\n      return true;\n    }\n    \n    if (x2 * x2 + y1 * y1 <= 1) {\n      return true;\n    }\n    \n    if (x2 * x2 + y2 * y2 <= 1) {\n      return true;\n    }\n    \n    if (x1 * x1 + y2 * y2 <= 1) {\n      return true;\n    }\n    \n    return false;\n  };\n  \n  $$.math.boxIntersectPolygon = function(\n    x1, y1, x2, y2, basePoints, width, height, centerX, centerY, direction, padding) {\n    \n//    console.log(arguments);\n    \n    if (x2 < x1) {\n      var oldX1 = x1;\n      x1 = x2;\n      x2 = oldX1;\n    }\n    \n    if (y2 < y1) {\n      var oldY1 = y1;\n      y1 = y2;\n      y2 = oldY1;\n    }\n    \n    var transformedPoints = new Array(basePoints.length);\n    \n    // Gives negative of angle\n    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] \n      + direction[1] * direction[1])));\n    \n    if (direction[0] < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n    \n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle);\n    \n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = \n        width / 2 * (basePoints[i * 2] * cos\n          - basePoints[i * 2 + 1] * sin);\n      \n      transformedPoints[i * 2 + 1] = \n        height / 2 * (basePoints[i * 2 + 1] * cos \n          + basePoints[i * 2] * sin);\n      \n      transformedPoints[i * 2] += centerX;\n      transformedPoints[i * 2 + 1] += centerY;\n    }\n    \n    // Assume transformedPoints.length > 0, and check if intersection is possible\n    var minTransformedX = transformedPoints[0];\n    var maxTransformedX = transformedPoints[0];\n    var minTransformedY = transformedPoints[1];\n    var maxTransformedY = transformedPoints[1];\n    \n    for (var i = 1; i < transformedPoints.length / 2; i++) {\n      if (transformedPoints[i * 2] > maxTransformedX) {\n        maxTransformedX = transformedPoints[i * 2];\n      }\n      \n      if (transformedPoints[i * 2] < minTransformedX) {\n        minTransformedX = transformedPoints[i * 2];\n      }\n      \n      if (transformedPoints[i * 2 + 1] > maxTransformedY) {\n        maxTransformedY = transformedPoints[i * 2 + 1];\n      }\n      \n      if (transformedPoints[i * 2 + 1] < minTransformedY) {\n        minTransformedY = transformedPoints[i * 2 + 1];\n      }\n    }\n    \n    if (x2 < minTransformedX - padding) {\n      return false;\n    }\n    \n    if (x1 > maxTransformedX + padding) {\n      return false;\n    }\n    \n    if (y2 < minTransformedY - padding) {\n      return false;\n    }\n    \n    if (y1 > maxTransformedY + padding) {\n      return false;\n    }\n    \n    // Continue checking with padding-corrected points\n    var points;\n    \n    if (padding > 0) {\n      var expandedLineSet = $$.math.expandPolygon(\n        transformedPoints,\n        -padding);\n      \n      points = $$.math.joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n    \n    // Check if a point is in box\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      if (x1 <= transformedPoints[i * 2]\n          && transformedPoints[i * 2] <= x2) {\n        \n        if (y1 <= transformedPoints[i * 2 + 1]\n            && transformedPoints[i * 2 + 1] <= y2) {\n          \n          return true;\n        }\n      }\n    }\n    \n    \n    // Check for intersections with the selection box\n    for (var i = 0; i < points.length / 2; i++) {\n      \n      var currentX = points[i * 2];\n      var currentY = points[i * 2 + 1];\n      var nextX;\n      var nextY;\n      \n      if (i < points.length / 2 - 1) {\n        nextX = points[(i + 1) * 2];\n        nextY = points[(i + 1) * 2 + 1];\n      } else {\n        nextX = points[0];\n        nextY = points[1];\n      }\n      \n      // Intersection with top of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x2, y1, false).length > 0) {\n        return true;\n      }\n      \n      // Intersection with bottom of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y2, x2, y2, false).length > 0) {\n        return true;\n      }\n      \n      // Intersection with left side of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x1, y2, false).length > 0) {\n        return true;\n      }\n      \n      // Intersection with right side of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x2, y1, x2, y2, false).length > 0) {\n        return true;\n      }\n    }\n\n    /*\n    // Check if box corner in the polygon\n    if ($$.math.pointInsidePolygon(\n      x1, y1, points, 0, 0, 1, 1, 0, direction)) {\n      \n      return true;\n    } else if ($$.math.pointInsidePolygon(\n      x1, y2, points, 0, 0, 1, 1, 0, direction)) {\n      \n      return true;\n    } else if ($$.math.pointInsidePolygon(\n      x2, y2, points, 0, 0, 1, 1, 0, direction)) {\n       \n      return true; \n    } else if ($$.math.pointInsidePolygon(\n      x2, y1, points, 0, 0, 1, 1, 0, direction)) {\n      \n      return true;\n    }\n    */\n    return false;\n  };\n  \n  $$.math.polygonIntersectLine = function(\n    x, y, basePoints, centerX, centerY, width, height, padding) {\n    \n    var intersections = [];\n    var intersection;\n    \n    var transformedPoints = new Array(basePoints.length);\n    \n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n    }\n    \n    var points;\n    \n    if (padding > 0) {\n      var expandedLineSet = $$.math.expandPolygon(\n        transformedPoints,\n        -padding);\n      \n      points = $$.math.joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n    // var points = transformedPoints;\n    \n    var currentX, currentY, nextX, nextY;\n    \n    for (var i = 0; i < points.length / 2; i++) {\n    \n      currentX = points[i * 2];\n      currentY = points[i * 2 + 1];\n\n      if (i < points.length / 2 - 1) {\n        nextX = points[(i + 1) * 2]; \n        nextY = points[(i + 1) * 2 + 1];\n      } else {\n        nextX = points[0]; \n        nextY = points[1];\n      }\n      \n      intersection = this.finiteLinesIntersect(\n        x, y, centerX, centerY,\n        currentX, currentY,\n        nextX, nextY);\n      \n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n    \n    return intersections;\n  };\n  \n  $$.math.shortenIntersection = function(\n    intersection, offset, amount) {\n    \n    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n    \n    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n    \n    var lenRatio = (length - amount) / length;\n    \n    if (lenRatio < 0) {\n      lenRatio = 0.00001;\n    }\n\n    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n  };\n\n  $$.math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {\n    var points = $$.math.generateUnitNgonPoints(sides, rotationRadians);\n    points = $$.math.fitPolygonToSquare(points);\n\n    return points;\n  };\n\n  $$.math.fitPolygonToSquare = function(points){\n    var x, y;\n    var sides = points.length/2;\n    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n\n    for (var i = 0; i < sides; i++) {\n      x = points[2 * i];\n      y = points[2 * i + 1];\n\n      minX = Math.min( minX, x );\n      maxX = Math.max( maxX, x );\n      minY = Math.min( minY, y );\n      maxY = Math.max( maxY, y );\n    }\n    \n    // stretch factors\n    var sx = 2 / (maxX - minX);\n    var sy = 2 / (maxY - minY);\n\n    for (var i = 0; i < sides; i++){\n      x = points[2 * i] = points[2 * i] * sx;\n      y = points[2 * i + 1] = points[2 * i + 1] * sy;\n\n      minX = Math.min( minX, x );\n      maxX = Math.max( maxX, x );\n      minY = Math.min( minY, y );\n      maxY = Math.max( maxY, y );\n    }\n\n    if( minY < -1 ){\n      for (var i = 0; i < sides; i++){\n        y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);\n      }\n    }\n    \n    return points;\n  };\n\n  $$.math.generateUnitNgonPoints = function(sides, rotationRadians) {\n    \n    var increment = 1.0 / sides * 2 * Math.PI;\n    var startAngle = sides % 2 === 0 ? \n      Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n//    console.log(nodeShapes['square']);\n    startAngle += rotationRadians;\n    \n    var points = new Array(sides * 2);\n\n    var currentAngle, x, y;\n    for (var i = 0; i < sides; i++) {\n      currentAngle = i * increment + startAngle;\n      \n      x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);\n      y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);\n    }\n    \n    return points;\n  };\n\n  $$.math.getRoundRectangleRadius = function(width, height) {\n    \n    // Set the default radius, unless half of width or height is smaller than default\n    return Math.min(width / 4, height / 4, 8);\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // registered extensions to cytoscape, indexed by name\n  var extensions = {};\n  $$.extensions = extensions;\n  \n  // registered modules for extensions, indexed by name\n  var modules = {};\n  $$.modules = modules;\n  \n  function setExtension(type, name, registrant){\n    var impl = {};\n    impl[name] = registrant;\n    \n    switch( type ){\n    case 'core':\n    case 'collection':\n      $$.fn[type]( impl );\n    }\n    \n    // fill in missing layout functions in the prototype\n    if( type === 'layout' ){\n      var layoutProto = registrant.prototype;\n      var optLayoutFns = ['stop'];\n\n      for( var i = 0; i < optLayoutFns.length; i++ ){\n        var fnName = optLayoutFns[i];\n\n        layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };\n      }\n\n      // either .start() or .run() is defined, so autogen the other\n      if( layoutProto.start && !layoutProto.run ){\n        layoutProto.run = function(){ this.start(); return this; };\n      } else if( !layoutProto.start && layoutProto.run ){\n        layoutProto.start = function(){ this.run(); return this; };\n      }\n\n      layoutProto.on = $$.define.on({ layout: true });\n      layoutProto.one = $$.define.on({ layout: true, unbindSelfOnTrigger: true });\n      layoutProto.once = $$.define.on({ layout: true, unbindAllBindersOnTrigger: true });\n      layoutProto.off = $$.define.off({ layout: true });\n      layoutProto.trigger = $$.define.trigger({ layout: true });\n\n      // aliases for those folks who like old stuff:\n      layoutProto.bind = layoutProto.on;\n      layoutProto.unbind = layoutProto.off;\n    }\n\n    return $$.util.setMap({\n      map: extensions,\n      keys: [ type, name ],\n      value: registrant\n    });\n  }\n  \n  function getExtension(type, name){\n    return $$.util.getMap({\n      map: extensions,\n      keys: [ type, name ]\n    });\n  }\n  \n  function setModule(type, name, moduleType, moduleName, registrant){\n    return $$.util.setMap({\n      map: modules,\n      keys: [ type, name, moduleType, moduleName ],\n      value: registrant\n    });\n  }\n  \n  function getModule(type, name, moduleType, moduleName){\n    return $$.util.getMap({\n      map: modules,\n      keys: [ type, name, moduleType, moduleName ]\n    });\n  }\n  \n  $$.extension = function(){\n    // e.g. $$.extension('renderer', 'svg')\n    if( arguments.length == 2 ){\n      return getExtension.apply(this, arguments);\n    }\n    \n    // e.g. $$.extension('renderer', 'svg', { ... })\n    else if( arguments.length == 3 ){\n      return setExtension.apply(this, arguments);\n    }\n    \n    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse')\n    else if( arguments.length == 4 ){\n      return getModule.apply(this, arguments);\n    }\n    \n    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n    else if( arguments.length == 5 ){\n      return setModule.apply(this, arguments);\n    }\n    \n    else {\n      $$.util.error('Invalid extension access syntax');\n    }\n  \n  };\n  \n})( cytoscape );\n\n;(function($, $$){ 'use strict';\n  \n  if( !$ ){ return; } // no jquery => don't need this\n\n  var cyReg = function( $ele ){\n    var d = $ele[0]._cyreg = $ele[0]._cyreg || {};\n\n    return d;\n  };\n\n  // allow calls on a jQuery selector by proxying calls to $.cytoscape\n  // e.g. $(\"#foo\").cytoscape(options) => $.cytoscape(options) on #foo\n  $.fn.cytoscape = function(opts){\n    var $this = $(this);\n\n    // get object\n    if( opts === 'get' ){\n      return cyReg( $this ).cy;\n    }\n    \n    // bind to ready\n    else if( $$.is.fn(opts) ){\n\n      var ready = opts;\n      var cy = cyReg( $this ).cy;\n      \n      if( cy && cy.isReady() ){ // already ready so just trigger now\n        cy.trigger('ready', [], ready);\n\n      } else { // not yet ready, so add to readies list\n        var data = cyReg( $this );\n        var readies = data.readies = data.readies || [];\n\n        readies.push( ready );\n      } \n      \n    }\n    \n    // proxy to create instance\n    else if( $$.is.plainObject(opts) ){\n      return $this.each(function(){\n        var options = $.extend({}, opts, {\n          container: $(this)[0]\n        });\n      \n        cytoscape(options);\n      });\n    }\n  };\n  \n  // allow access to the global cytoscape object under jquery for legacy reasons\n  $.cytoscape = cytoscape;\n  \n  // use short alias (cy) if not already defined\n  if( $.fn.cy == null && $.cy == null ){\n    $.fn.cy = $.fn.cytoscape;\n    $.cy = $.cytoscape;\n  }\n  \n})(typeof jQuery !== 'undefined' ? jQuery : null , cytoscape);\n\n;(function($$){ 'use strict';\n  \n  // shamelessly taken from jQuery\n  // https://github.com/jquery/jquery/blob/master/src/event.js\n\n  $$.Event = function( src, props ) {\n    // Allow instantiation without the 'new' keyword\n    if ( !(this instanceof $$.Event) ) {\n      return new $$.Event( src, props );\n    }\n\n    // Event object\n    if ( src && src.type ) {\n      this.originalEvent = src;\n      this.type = src.type;\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;\n\n    // Event type\n    } else {\n      this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if ( props ) {\n      // $$.util.extend( this, props );\n\n      // more efficient to manually copy fields we use\n      this.type = props.type !== undefined ? props.type : this.type;\n      this.cy = props.cy;\n      this.cyTarget = props.cyTarget;\n      this.cyPosition = props.cyPosition;\n      this.cyRenderedPosition = props.cyRenderedPosition;\n      this.namespace = props.namespace;\n      this.layout = props.layout;\n      this.data = props.data;\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || +new Date();\n  };\n\n  function returnFalse() {\n    return false;\n  }\n  function returnTrue() {\n    return true;\n  }\n\n  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n  $$.Event.prototype = {\n    preventDefault: function() {\n      this.isDefaultPrevented = returnTrue;\n\n      var e = this.originalEvent;\n      if ( !e ) {\n        return;\n      }\n\n      // if preventDefault exists run it on the original event\n      if ( e.preventDefault ) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function() {\n      this.isPropagationStopped = returnTrue;\n\n      var e = this.originalEvent;\n      if ( !e ) {\n        return;\n      }\n      // if stopPropagation exists run it on the original event\n      if ( e.stopPropagation ) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function() {\n      this.isImmediatePropagationStopped = returnTrue;\n      this.stopPropagation();\n    },\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse\n  };\n  \n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // use this module to cherry pick functions into your prototype\n  // (useful for functions shared between the core and collections, for example)\n\n  // e.g.\n  // $$.fn.collection({\n  //   foo: $$.define.foo({ /* params... */ })\n  // });\n\n  $$.define = {\n\n    // access data field\n    data: function( params ){\n      var defaults = { \n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: false,\n        allowSetting: false,\n        allowGetting: false,\n        settingEvent: 'data',\n        settingTriggersEvent: false,\n        triggerFnName: 'trigger',\n        immutableKeys: {}, // key => true if immutable\n        updateStyle: false,\n        onSet: function( self ){},\n        canSet: function( self ){ return true; }\n      };\n      params = $$.util.extend({}, defaults, params);\n\n      return function dataImpl( name, value ){\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var single = selfIsArrayLike ? self[0] : self;\n\n        // .data('foo', ...)\n        if( $$.is.string(name) ){ // set or get property\n\n          // .data('foo')\n          if( p.allowGetting && value === undefined ){ // get\n\n            var ret;\n            if( single ){\n              ret = single._private[ p.field ][ name ];\n            }\n            return ret;\n          \n          // .data('foo', 'bar')\n          } else if( p.allowSetting && value !== undefined ) { // set\n            var valid = !p.immutableKeys[name];\n            if( valid ){\n              for( var i = 0, l = all.length; i < l; i++ ){\n                if( p.canSet( all[i] ) ){\n                  all[i]._private[ p.field ][ name ] = value;\n                }\n              }\n\n              // update mappers if asked\n              if( p.updateStyle ){ self.updateStyle(); }\n\n              // call onSet callback\n              p.onSet( self );\n\n              if( p.settingTriggersEvent ){\n                self[ p.triggerFnName ]( p.settingEvent );\n              }\n            }\n          }\n\n        // .data({ 'foo': 'bar' })\n        } else if( p.allowSetting && $$.is.plainObject(name) ){ // extend\n          var obj = name;\n          var k, v;\n\n          for( k in obj ){\n            v = obj[ k ];\n\n            var valid = !p.immutableKeys[k];\n            if( valid ){\n              for( var i = 0, l = all.length; i < l; i++ ){\n                if( p.canSet( all[i] ) ){\n                  all[i]._private[ p.field ][ k ] = v;\n                }\n              }\n            }\n          }\n          \n          // update mappers if asked\n          if( p.updateStyle ){ self.updateStyle(); }\n\n          // call onSet callback\n          p.onSet( self );\n\n          if( p.settingTriggersEvent ){\n            self[ p.triggerFnName ]( p.settingEvent );\n          }\n        \n        // .data(function(){ ... })\n        } else if( p.allowBinding && $$.is.fn(name) ){ // bind to event\n          var fn = name;\n          self.bind( p.bindingEvent, fn );\n        \n        // .data()\n        } else if( p.allowGetting && name === undefined ){ // get whole object\n          var ret;\n          if( single ){\n            ret = single._private[ p.field ];\n          }\n          return ret;\n        }\n\n        return self; // maintain chainability\n      }; // function\n    }, // data\n\n    // remove data field\n    removeData: function( params ){\n      var defaults = { \n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: false,\n        immutableKeys: {} // key => true if immutable\n      };\n      params = $$.util.extend({}, defaults, params);\n\n      return function removeDataImpl( names ){\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        \n        // .removeData('foo bar')\n        if( $$.is.string(names) ){ // then get the list of keys, and delete them\n          var keys = names.split(/\\s+/);\n          var l = keys.length;\n\n          for( var i = 0; i < l; i++ ){ // delete each non-empty key\n            var key = keys[i];\n            if( $$.is.emptyString(key) ){ continue; }\n\n            var valid = !p.immutableKeys[ key ]; // not valid if immutable\n            if( valid ){\n              for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n                all[ i_a ]._private[ p.field ][ key ] = undefined;\n              }\n            }\n          }\n\n          if( p.triggerEvent ){\n            self[ p.triggerFnName ]( p.event );\n          }\n\n        // .removeData()\n        } else if( names === undefined ){ // then delete all keys\n\n          for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n            var _privateFields = all[ i_a ]._private[ p.field ];\n            \n            for( var key in _privateFields ){\n              var validKeyToDelete = !p.immutableKeys[ key ];\n\n              if( validKeyToDelete ){\n                _privateFields[ key ] = undefined;\n              }\n            }\n          }\n\n          if( p.triggerEvent ){\n            self[ p.triggerFnName ]( p.event );\n          }\n        }\n\n        return self; // maintain chaining\n      }; // function\n    }, // removeData\n\n    // event function reusable stuff\n    event: {\n      regex: /(\\w+)(\\.\\w+)?/, // regex for matching event strings (e.g. \"click.namespace\")\n      optionalTypeRegex: /(\\w+)?(\\.\\w+)?/,\n      falseCallback: function(){ return false; }\n    },\n\n    // event binding\n    on: function( params ){\n      var defaults = {\n        unbindSelfOnTrigger: false,\n        unbindAllBindersOnTrigger: false\n      };\n      params = $$.util.extend({}, defaults, params);\n      \n      return function onImpl(events, selector, data, callback){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var eventsIsString = $$.is.string(events);\n        var p = params;\n\n        if( $$.is.plainObject(selector) ){ // selector is actually data\n          callback = data;\n          data = selector;\n          selector = undefined;\n        } else if( $$.is.fn(selector) || selector === false ){ // selector is actually callback\n          callback = selector;\n          data = undefined;\n          selector = undefined;\n        }\n\n        if( $$.is.fn(data) || data === false ){ // data is actually callback\n          callback = data;\n          data = undefined;\n        }\n\n        // if there isn't a callback, we can't really do anything\n        // (can't speak for mapped events arg version)\n        if( !($$.is.fn(callback) || callback === false) && eventsIsString ){\n          return self; // maintain chaining\n        }\n\n        if( eventsIsString ){ // then convert to map\n          var map = {};\n          map[ events ] = callback;\n          events = map;\n        }\n\n        for( var evts in events ){\n          callback = events[evts];\n          if( callback === false ){\n            callback = $$.define.event.falseCallback;\n          }\n\n          if( !$$.is.fn(callback) ){ continue; }\n\n          evts = evts.split(/\\s+/);\n          for( var i = 0; i < evts.length; i++ ){\n            var evt = evts[i];\n            if( $$.is.emptyString(evt) ){ continue; }\n\n            var match = evt.match( $$.define.event.regex ); // type[.namespace]\n\n            if( match ){\n              var type = match[1];\n              var namespace = match[2] ? match[2] : undefined;\n\n              var listener = {\n                callback: callback, // callback to run\n                data: data, // extra data in eventObj.data\n                delegated: selector ? true : false, // whether the evt is delegated\n                selector: selector, // the selector to match for delegated events\n                selObj: new $$.Selector(selector), // cached selector object to save rebuilding\n                type: type, // the event type (e.g. 'click')\n                namespace: namespace, // the event namespace (e.g. \".foo\")\n                unbindSelfOnTrigger: p.unbindSelfOnTrigger,\n                unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,\n                binders: all // who bound together\n              };\n\n              for( var j = 0; j < all.length; j++ ){\n                all[j]._private.listeners.push( listener );\n              }\n            }\n          } // for events array\n        } // for events map\n        \n        return self; // maintain chaining\n      }; // function\n    }, // on\n\n    off: function offImpl( params ){\n      var defaults = {\n      };\n      params = $$.util.extend({}, defaults, params);\n      \n      return function(events, selector, callback){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var eventsIsString = $$.is.string(events);\n\n        if( arguments.length === 0 ){ // then unbind all\n\n          for( var i = 0; i < all.length; i++ ){\n            all[i]._private.listeners = [];\n          }\n\n          return self; // maintain chaining\n        }\n\n        if( $$.is.fn(selector) || selector === false ){ // selector is actually callback\n          callback = selector;\n          selector = undefined;\n        }\n\n        if( eventsIsString ){ // then convert to map\n          var map = {};\n          map[ events ] = callback;\n          events = map;\n        }\n\n        for( var evts in events ){\n          callback = events[evts];\n\n          if( callback === false ){\n            callback = $$.define.event.falseCallback;\n          }\n\n          evts = evts.split(/\\s+/);\n          for( var h = 0; h < evts.length; h++ ){\n            var evt = evts[h];\n            if( $$.is.emptyString(evt) ){ continue; }\n\n            var match = evt.match( $$.define.event.optionalTypeRegex ); // [type][.namespace]\n            if( match ){\n              var type = match[1] ? match[1] : undefined;\n              var namespace = match[2] ? match[2] : undefined;\n\n              for( var i = 0; i < all.length; i++ ){ //\n                var listeners = all[i]._private.listeners;\n\n                for( var j = 0; j < listeners.length; j++ ){\n                  var listener = listeners[j];\n                  var nsMatches = !namespace || namespace === listener.namespace;\n                  var typeMatches = !type || listener.type === type;\n                  var cbMatches = !callback || callback === listener.callback;\n                  var listenerMatches = nsMatches && typeMatches && cbMatches;\n\n                  // delete listener if it matches\n                  if( listenerMatches ){\n                    listeners.splice(j, 1);\n                    j--;\n                  }\n                } // for listeners\n              } // for all\n            } // if match\n          } // for events array\n\n        } // for events map\n        \n        return self; // maintain chaining\n      }; // function\n    }, // off\n\n    trigger: function( params ){\n      var defaults = {};\n      params = $$.util.extend({}, defaults, params);\n      \n      return function triggerImpl(events, extraParams, fnToTrigger){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var eventsIsString = $$.is.string(events);\n        var eventsIsObject = $$.is.plainObject(events);\n        var eventsIsEvent = $$.is.event(events);\n        var cy = this._private.cy || this;\n        var hasCompounds = cy.hasCompoundNodes();\n\n        if( eventsIsString ){ // then make a plain event object for each event name\n          var evts = events.split(/\\s+/);\n          events = [];\n\n          for( var i = 0; i < evts.length; i++ ){\n            var evt = evts[i];\n            if( $$.is.emptyString(evt) ){ continue; }\n\n            var match = evt.match( $$.define.event.regex ); // type[.namespace]\n            var type = match[1];\n            var namespace = match[2] ? match[2] : undefined;\n\n            events.push( {\n              type: type,\n              namespace: namespace\n            } );\n          }\n        } else if( eventsIsObject ){ // put in length 1 array\n          var eventArgObj = events;\n\n          events = [ eventArgObj ];\n        }\n\n        if( extraParams ){\n          if( !$$.is.array(extraParams) ){ // make sure extra params are in an array if specified\n            extraParams = [ extraParams ];\n          }\n        } else { // otherwise, we've got nothing\n          extraParams = [];\n        }\n\n        for( var i = 0; i < events.length; i++ ){ // trigger each event in order\n          var evtObj = events[i];\n          \n          for( var j = 0; j < all.length; j++ ){ // for each\n            var triggerer = all[j];\n            var listeners = triggerer._private.listeners;\n            var triggererIsElement = $$.is.element(triggerer);\n            var bubbleUp = triggererIsElement || params.layout;\n\n            // create the event for this element from the event object\n            var evt;\n\n            if( eventsIsEvent ){ // then just get the object\n              evt = evtObj;\n              \n              evt.cyTarget = evt.cyTarget || triggerer;\n              evt.cy = evt.cy || cy;\n\n            } else { // then we have to make one\n              evt = new $$.Event( evtObj, {\n                cyTarget: triggerer,\n                cy: cy,\n                namespace: evtObj.namespace\n              } );\n            }\n\n            // if a layout was specified, then put it in the typed event\n            if( evtObj.layout ){\n              evt.layout = evtObj.layout;\n            }\n\n            // if triggered by layout, put in event\n            if( params.layout ){\n              evt.layout = triggerer;\n            }\n\n            // create a rendered position based on the passed position\n            if( evt.cyPosition ){\n              var pos = evt.cyPosition;\n              var zoom = cy.zoom();\n              var pan = cy.pan();\n\n              evt.cyRenderedPosition = {\n                x: pos.x * zoom + pan.x,\n                y: pos.y * zoom + pan.y\n              };\n            }\n\n            if( fnToTrigger ){ // then override the listeners list with just the one we specified\n              listeners = [{\n                namespace: evt.namespace,\n                type: evt.type,\n                callback: fnToTrigger\n              }];\n            }\n\n            for( var k = 0; k < listeners.length; k++ ){ // check each listener\n              var lis = listeners[k];\n              var nsMatches = !lis.namespace || lis.namespace === evt.namespace;\n              var typeMatches = lis.type === evt.type;\n              var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && $$.is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive\n              var listenerMatches = nsMatches && typeMatches && targetMatches;\n\n              if( listenerMatches ){ // then trigger it\n                var args = [ evt ];\n                args = args.concat( extraParams ); // add extra params to args list\n\n                if( lis.data ){ // add on data plugged into binding\n                  evt.data = lis.data;\n                } else { // or clear it in case the event obj is reused\n                  evt.data = undefined;\n                }\n\n                if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener\n                  listeners.splice(k, 1);\n                  k--;\n                }\n\n                if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders\n                  var binders = lis.binders;\n                  for( var l = 0; l < binders.length; l++ ){\n                    var binder = binders[l];\n                    if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it\n\n                    var binderListeners = binder._private.listeners;\n                    for( var m = 0; m < binderListeners.length; m++ ){\n                      var binderListener = binderListeners[m];\n\n                      if( binderListener === lis ){ // delete listener from list\n                        binderListeners.splice(m, 1);\n                        m--;\n                      }\n                    }\n                  }\n                }\n\n                // run the callback\n                var context = lis.delegated ? evt.cyTarget : triggerer;\n                var ret = lis.callback.apply( context, args );\n\n                if( ret === false || evt.isPropagationStopped() ){\n                  // then don't bubble\n                  bubbleUp = false;\n\n                  if( ret === false ){\n                    // returning false is a shorthand for stopping propagation and preventing the def. action\n                    evt.stopPropagation();\n                    evt.preventDefault();\n                  }\n                }\n              } // if listener matches\n            } // for each listener\n\n            // bubble up event for elements\n            if( bubbleUp ){\n              var parent = hasCompounds ? triggerer._private.parent : null;\n              var hasParent = parent != null && parent.length !== 0;\n\n              if( hasParent ){ // then bubble up to parent\n                parent = parent[0];\n                parent.trigger(evt);\n              } else { // otherwise, bubble up to the core\n                cy.trigger(evt);\n              }\n            }\n\n          } // for each of all\n        } // for each event\n        \n        return self; // maintain chaining\n      }; // function\n    }, // trigger\n\n\n    animated: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function animatedImpl(){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return false; }\n\n        var ele = all[0];\n\n        if( ele ){\n          return ele._private.animation.current.length > 0;\n        }\n      };\n    }, // animated\n\n    clearQueue: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function clearQueueImpl(){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        for( var i = 0; i < all.length; i++ ){\n          var ele = all[i];\n          ele._private.animation.queue = [];\n        }\n\n        return this;\n      };\n    }, // clearQueue\n\n    delay: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function delayImpl( time, complete ){\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        this.animate({\n          delay: time\n        }, {\n          duration: time,\n          complete: complete\n        });\n\n        return this;\n      };\n    }, // delay\n\n    animate: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function animateImpl( properties, params ){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n        var isCore = !selfIsArrayLike;\n        var isEles = !isCore;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        var callTime = +new Date();\n        var style = cy.style();\n        var q;\n        \n        if( params === undefined ){\n          params = {};\n        }\n\n        if( params.duration === undefined ){\n          params.duration = 400;\n        }\n        \n        switch( params.duration ){\n        case 'slow':\n          params.duration = 600;\n          break;\n        case 'fast':\n          params.duration = 200;\n          break;\n        }\n        \n        var propertiesEmpty = true;\n        if( properties ){ for( var i in properties ){\n          propertiesEmpty = false;\n          break;\n        } }\n\n        if( propertiesEmpty ){\n          return this; // nothing to animate\n        }\n\n        if( properties.css && isEles ){\n          properties.css = style.getValueStyle( properties.css, { array: true } );\n        }\n\n        if( properties.renderedPosition && isEles ){\n          var rpos = properties.renderedPosition;\n          var pan = cy.pan();\n          var zoom = cy.zoom();\n\n          properties.position = {\n            x: ( rpos.x - pan.x ) /zoom,\n            y: ( rpos.y - pan.y ) /zoom\n          };\n        }\n\n        // override pan w/ panBy if set\n        if( properties.panBy && isCore ){\n          var panBy = properties.panBy;\n          var cyPan = cy.pan();\n\n          properties.pan = {\n            x: cyPan.x + panBy.x,\n            y: cyPan.y + panBy.y\n          };\n        }\n\n        // override pan w/ center if set\n        var center = properties.center || properties.centre;\n        if( center && isCore ){\n          var centerPan = cy.getCenterPan( center.eles, properties.zoom );\n\n          if( centerPan ){\n            properties.pan = centerPan;\n          }\n        }\n\n        // override pan & zoom w/ fit if set\n        if( properties.fit && isCore ){\n          var fit = properties.fit;\n          var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );\n\n          if( fitVp ){\n            properties.pan = fitVp.pan; //{ x: fitVp.pan.x, y: fitVp.pan.y };\n            properties.zoom = fitVp.zoom;\n          }\n        }\n\n        for( var i = 0; i < all.length; i++ ){\n          var ele = all[i];\n         \n          if( ele.animated() && (params.queue === undefined || params.queue) ){\n            q = ele._private.animation.queue;\n          } else {\n            q = ele._private.animation.current;\n          }\n\n          q.push({\n            properties: properties,\n            duration: params.duration,\n            params: params,\n            callTime: callTime\n          });\n        }\n\n        if( isEles ){\n          cy.addToAnimationPool( this );\n        }\n\n        return this; // chaining\n      };\n    }, // animate\n\n    stop: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function stopImpl( clearQueue, jumpToEnd ){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        for( var i = 0; i < all.length; i++ ){\n          var ele = all[i];\n          var anis = ele._private.animation.current;\n\n          for( var j = 0; j < anis.length; j++ ){\n            var animation = anis[j];    \n            if( jumpToEnd ){\n              // next iteration of the animation loop, the animation\n              // will go straight to the end and be removed\n              animation.duration = 0; \n            }\n          }\n          \n          // clear the queue of future animations\n          if( clearQueue ){\n            ele._private.animation.queue = [];\n          }\n\n          if( !jumpToEnd ){\n            ele._private.animation.current = [];\n          }\n        }\n        \n        // we have to notify (the animation loop doesn't do it for us on `stop`)\n        cy.notify({\n          collection: this,\n          type: 'draw'\n        });\n        \n        return this;\n      };\n    } // stop\n\n  }; // define\n\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.selector = function(map, options){\n    for( var name in map ){\n      var fn = map[name];\n      $$.Selector.prototype[ name ] = fn;\n    }\n  };\n\n  $$.Selector = function(onlyThisGroup, selector){\n    \n    if( !(this instanceof $$.Selector) ){\n      return new $$.Selector(onlyThisGroup, selector);\n    }\n  \n    if( selector === undefined && onlyThisGroup !== undefined ){\n      selector = onlyThisGroup;\n      onlyThisGroup = undefined;\n    }\n    \n    var self = this;\n    \n    self._private = {\n      selectorText: null,\n      invalid: true\n    };\n    \n    if( !selector || ( $$.is.string(selector) && selector.match(/^\\s*$/) ) ){\n      \n      if( onlyThisGroup == null ){\n        // ignore\n        self.length = 0;\n      } else {\n        self[0] = newQuery();\n        self[0].group = onlyThisGroup;\n        self.length = 1;\n      }\n              \n    } else if( $$.is.element( selector ) ){\n      var collection = new $$.Collection(self.cy(), [ selector ]);\n      \n      self[0] = newQuery();\n      self[0].collection = collection;\n      self.length = 1;\n      \n    } else if( $$.is.collection( selector ) ){\n      self[0] = newQuery();\n      self[0].collection = selector;\n      self.length = 1;\n      \n    } else if( $$.is.fn( selector ) ) {\n      self[0] = newQuery();\n      self[0].filter = selector;\n      self.length = 1;\n      \n    } else if( $$.is.string( selector ) ){\n\n      // the current subject in the query\n      var currentSubject = null;\n      \n      // storage for parsed queries\n      var newQuery = function(){\n        return {\n          classes: [], \n          colonSelectors: [],\n          data: [],\n          group: null,\n          ids: [],\n          meta: [],\n\n          // fake selectors\n          collection: null, // a collection to match against\n          filter: null, // filter function\n\n          // these are defined in the upward direction rather than down (e.g. child)\n          // because we need to go up in Selector.filter()\n          parent: null, // parent query obj\n          ancestor: null, // ancestor query obj\n          subject: null, // defines subject in compound query (subject query obj; points to self if subject)\n\n          // use these only when subject has been defined\n          child: null,\n          descendant: null\n        };\n      };\n\n      // tokens in the query language\n      var tokens = {\n        metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]', // chars we need to escape in var names, etc\n        comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=', // binary comparison op (used in data selectors)\n        boolOp: '\\\\?|\\\\!|\\\\^', // boolean (unary) operators (used in data selectors)\n        string: '\"(?:\\\\\\\\\"|[^\"])+\"' + '|' + \"'(?:\\\\\\\\'|[^'])+'\", // string literals (used in data selectors) -- doublequotes | singlequotes\n        number: $$.util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from $$.Collection)\n        separator: '\\\\s*,\\\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n        descendant: '\\\\s+',\n        child: '\\\\s+>\\\\s+',\n        subject: '\\\\$'\n      };\n      tokens.variable = '(?:[\\\\w-]|(?:\\\\\\\\'+ tokens.metaChar +'))+'; // a variable name\n      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n      tokens.className = tokens.variable; // a class name (follows variable conventions)\n      tokens.id = tokens.variable; // an element id (follows variable conventions)\n\n      // when a token like a variable has escaped meta characters, we need to clean the backslashes out\n      // so that values get compared properly in Selector.filter()\n      var cleanMetaChars = function(str){\n        return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){\n          return $1;\n        });\n      };\n      \n      // add @ variants to comparatorOp\n      var ops = tokens.comparatorOp.split('|');\n      for( var i = 0; i < ops.length; i++ ){\n        var op = ops[i];\n        tokens.comparatorOp += '|@' + op;\n      }\n\n      // add ! variants to comparatorOp\n      var ops = tokens.comparatorOp.split('|');\n      for( var i = 0; i < ops.length; i++ ){\n        var op = ops[i];\n\n        if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !\n        if( op === '=' ){ continue; } // skip = b/c != is explicitly defined\n\n        tokens.comparatorOp += '|\\\\!' + op;\n      }\n\n      // NOTE: add new expression syntax here to have it recognised by the parser;\n      // - a query contains all adjacent (i.e. no separator in between) expressions;\n      // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;\n      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward\n      // - when you add something here, also add to Selector.toString()\n      var exprs = {\n        group: {\n          query: true,\n          regex: '(node|edge|\\\\*)',\n          populate: function( group ){\n            this.group = group == \"*\" ? group : group + 's';\n          }\n        },\n        \n        state: {\n          query: true,\n          // NB: if one colon selector is a substring of another from its start, place the longer one first\n          // e.g. :foobar|:foo\n          regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch)',\n          populate: function( state ){\n            this.colonSelectors.push( state );\n          }\n        },\n        \n        id: {\n          query: true,\n          regex: '\\\\#('+ tokens.id +')',\n          populate: function( id ){\n            this.ids.push( cleanMetaChars(id) );\n          }\n        },\n        \n        className: {\n          query: true,\n          regex: '\\\\.('+ tokens.className +')',\n          populate: function( className ){\n            this.classes.push( cleanMetaChars(className) );\n          }\n        },\n        \n        dataExists: {\n          query: true,\n          regex: '\\\\[\\\\s*('+ tokens.variable +')\\\\s*\\\\]',\n          populate: function( variable ){\n            this.data.push({\n              field: cleanMetaChars(variable)\n            });\n          }\n        },\n        \n        dataCompare: {\n          query: true,\n          regex: '\\\\[\\\\s*('+ tokens.variable +')\\\\s*('+ tokens.comparatorOp +')\\\\s*('+ tokens.value +')\\\\s*\\\\]',\n          populate: function( variable, comparatorOp, value ){ \n            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n\n            if( valueIsString ){\n              value = value.substring(1, value.length - 1);\n            } else {\n              value = parseFloat(value);\n            }\n\n            this.data.push({\n              field: cleanMetaChars(variable),\n              operator: comparatorOp,\n              value: value\n            });\n          }\n        },\n        \n        dataBool: {\n          query: true,\n          regex: '\\\\[\\\\s*('+ tokens.boolOp +')\\\\s*('+ tokens.variable +')\\\\s*\\\\]',\n          populate: function( boolOp, variable ){\n            this.data.push({\n              field: cleanMetaChars(variable),\n              operator: boolOp\n            });\n          }\n        },\n        \n        metaCompare: {\n          query: true,\n          regex: '\\\\[\\\\[\\\\s*('+ tokens.meta +')\\\\s*('+ tokens.comparatorOp +')\\\\s*('+ tokens.number +')\\\\s*\\\\]\\\\]',\n          populate: function( meta, comparatorOp, number ){\n            this.meta.push({\n              field: cleanMetaChars(meta),\n              operator: comparatorOp,\n              value: parseFloat(number)\n            });\n          }\n        },\n\n        nextQuery: {\n          separator: true,\n          regex: tokens.separator,\n          populate: function(){\n            // go on to next query\n            self[++i] = newQuery();\n            currentSubject = null;\n          }\n        },\n\n        child: {\n          separator: true,\n          regex: tokens.child,\n          populate: function(){\n            // this query is the parent of the following query\n            var childQuery = newQuery();\n            childQuery.parent = this;\n            childQuery.subject = currentSubject;\n\n            // we're now populating the child query with expressions that follow\n            self[i] = childQuery;\n          }\n        },\n\n        descendant: {\n          separator: true,\n          regex: tokens.descendant,\n          populate: function(){\n            // this query is the ancestor of the following query\n            var descendantQuery = newQuery();\n            descendantQuery.ancestor = this;\n            descendantQuery.subject = currentSubject;\n\n            // we're now populating the descendant query with expressions that follow\n            self[i] = descendantQuery;\n          }\n        },\n\n        subject: {\n          modifier: true,\n          regex: tokens.subject,\n          populate: function(){\n            if( currentSubject != null && this.subject != this ){\n              $$.util.error('Redefinition of subject in selector `' + selector + '`');\n              return false;\n            }\n\n            currentSubject = this;\n            this.subject = this;\n          }\n\n        }\n      };\n\n      var j = 0;\n      for( var name in exprs ){\n        exprs[j] = exprs[name];\n        exprs[j].name = name;\n\n        j++;\n      }\n      exprs.length = j;\n\n      self._private.selectorText = selector;\n      var remaining = selector;\n      var i = 0;\n      \n      // of all the expressions, find the first match in the remaining text\n      var consumeExpr = function( expectation ){\n        var expr;\n        var match;\n        var name;\n        \n        for( var j = 0; j < exprs.length; j++ ){\n          var e = exprs[j];\n          var n = e.name;\n\n          // ignore this expression if it doesn't meet the expectation function\n          if( $$.is.fn( expectation ) && !expectation(n, e) ){ continue; }\n\n          var m = remaining.match(new RegExp( '^' + e.regex ));\n          \n          if( m != null ){\n            match = m;\n            expr = e;\n            name = n;\n            \n            var consumed = m[0];\n            remaining = remaining.substring( consumed.length );                \n            \n            break; // we've consumed one expr, so we can return now\n          }\n        }\n        \n        return {\n          expr: expr,\n          match: match,\n          name: name\n        };\n      };\n      \n      // consume all leading whitespace\n      var consumeWhitespace = function(){\n        var match = remaining.match(/^\\s+/);\n        \n        if( match ){\n          var consumed = match[0];\n          remaining = remaining.substring( consumed.length );\n        }\n      };\n      \n      self[0] = newQuery(); // get started\n\n      consumeWhitespace(); // get rid of leading whitespace\n      for(;;){        \n        var check = consumeExpr();\n        \n        if( check.expr == null ){\n          $$.util.error('The selector `'+ selector +'`is invalid');\n          return;\n        } else {\n          var args = [];\n          for(var j = 1; j < check.match.length; j++){\n            args.push( check.match[j] );\n          }\n          \n          // let the token populate the selector object (i.e. in self[i])\n          var ret = check.expr.populate.apply( self[i], args );\n\n          if( ret === false ){ return; } // exit if population failed\n        }\n        \n        // we're done when there's nothing left to parse\n        if( remaining.match(/^\\s*$/) ){\n          break;\n        }\n      }\n      \n      self.length = i + 1;\n\n      // adjust references for subject\n      for(j = 0; j < self.length; j++){\n        var query = self[j];\n\n        if( query.subject != null ){\n          // go up the tree until we reach the subject\n          for(;;){\n            if( query.subject == query ){ break; } // done if subject is self\n\n            if( query.parent != null ){ // swap parent/child reference\n              var parent = query.parent;\n              var child = query;\n\n              child.parent = null;\n              parent.child = child;\n\n              query = parent; // go up the tree\n            } else if( query.ancestor != null ){ // swap ancestor/descendant\n              var ancestor = query.ancestor;\n              var descendant = query;\n\n              descendant.ancestor = null;\n              ancestor.descendant = descendant;\n\n              query = ancestor; // go up the tree\n            } else {\n              $$.util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');\n              break;\n            }\n          } // for\n\n          self[j] = query.subject; // subject should be the root query\n        } // if\n      } // for\n\n      // make sure for each query that the subject group matches the implicit group if any\n      if( onlyThisGroup != null ){\n        for(var j = 0; j < self.length; j++){\n          if( self[j].group != null && self[j].group != onlyThisGroup ){\n            $$.util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');\n            return;\n          }\n\n          self[j].group = onlyThisGroup; // set to implicit group\n        }\n      }\n      \n    } else {\n      $$.util.error('A selector must be created from a string; found ' + selector);\n      return;\n    }\n\n    self._private.invalid = false;\n    \n  };\n\n  $$.selfn = $$.Selector.prototype;\n  \n  $$.selfn.size = function(){\n    return this.length;\n  };\n  \n  $$.selfn.eq = function(i){\n    return this[i];\n  };\n  \n  // get elements from the core and then filter them\n  $$.selfn.find = function(){\n    // TODO impl if we decide to use a DB for storing elements\n  };\n  \n  var queryMatches = function(query, element){\n    // check group\n    if( query.group != null && query.group != '*' && query.group != element._private.group ){\n      return false;\n    }\n\n    var cy = element.cy();\n    \n    // check colon selectors\n    var allColonSelectorsMatch = true;\n    for(var k = 0; k < query.colonSelectors.length; k++){\n      var sel = query.colonSelectors[k];\n      \n      switch(sel){\n      case ':selected':\n        allColonSelectorsMatch = element.selected();\n        break;\n      case ':unselected':\n        allColonSelectorsMatch = !element.selected();\n        break;\n      case ':selectable':\n        allColonSelectorsMatch = element.selectable();\n        break;\n      case ':unselectable':\n        allColonSelectorsMatch = !element.selectable();\n        break;\n      case ':locked':\n        allColonSelectorsMatch = element.locked();\n        break;\n      case ':unlocked':\n        allColonSelectorsMatch = !element.locked();\n        break;\n      case ':visible':\n        allColonSelectorsMatch = element.visible();\n        break;\n      case ':hidden':\n        allColonSelectorsMatch = !element.visible();\n        break;\n      case ':transparent':\n        allColonSelectorsMatch = element.transparent();\n        break;\n      case ':grabbed':\n        allColonSelectorsMatch = element.grabbed();\n        break;\n      case ':free':\n        allColonSelectorsMatch = !element.grabbed();\n        break;\n      case ':removed':\n        allColonSelectorsMatch = element.removed();\n        break;\n      case ':inside':\n        allColonSelectorsMatch = !element.removed();\n        break;\n      case ':grabbable':\n        allColonSelectorsMatch = element.grabbable();\n        break;\n      case ':ungrabbable':\n        allColonSelectorsMatch = !element.grabbable();\n        break;\n      case ':animated':\n        allColonSelectorsMatch = element.animated();\n        break;\n      case ':unanimated':\n        allColonSelectorsMatch = !element.animated();\n        break;\n      case ':parent':\n        allColonSelectorsMatch = element.isNode() && element.children().nonempty();\n        break;\n      case ':child':\n      case ':nonorphan':\n        allColonSelectorsMatch = element.isNode() && element.parent().nonempty();\n        break;\n      case ':orphan':\n        allColonSelectorsMatch = element.isNode() && element.parent().empty();\n        break;\n      case ':loop':\n        allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');\n        break;\n      case ':simple':\n        allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');\n        break;\n      case ':active':\n        allColonSelectorsMatch = element.active();\n        break;\n      case ':inactive':\n        allColonSelectorsMatch = !element.active();\n        break;\n      case ':touch':\n        allColonSelectorsMatch = $$.is.touch();\n        break;\n      }\n      \n      if( !allColonSelectorsMatch ) break;\n    }\n    if( !allColonSelectorsMatch ) return false;\n    \n    // check id\n    var allIdsMatch = true;\n    for(var k = 0; k < query.ids.length; k++){\n      var id = query.ids[k];\n      var actualId = element._private.data.id;\n      \n      allIdsMatch = allIdsMatch && (id == actualId);\n      \n      if( !allIdsMatch ) break;\n    }\n    if( !allIdsMatch ) return false;\n    \n    // check classes\n    var allClassesMatch = true;\n    for(var k = 0; k < query.classes.length; k++){\n      var cls = query.classes[k];\n      \n      allClassesMatch = allClassesMatch && element.hasClass(cls);\n      \n      if( !allClassesMatch ) break;\n    }\n    if( !allClassesMatch ) return false;\n    \n    // generic checking for data/metadata\n    var operandsMatch = function(params){\n      var allDataMatches = true;\n      for(var k = 0; k < query[params.name].length; k++){\n        var data = query[params.name][k];\n        var operator = data.operator;\n        var value = data.value;\n        var field = data.field;\n        var matches;\n        \n        if( operator != null && value != null ){\n          \n          var fieldVal = params.fieldValue(field);\n          var fieldStr = !$$.is.string(fieldVal) && !$$.is.number(fieldVal) ? '' : '' + fieldVal;\n          var valStr = '' + value;\n          \n          var caseInsensitive = false;\n          if( operator.indexOf('@') >= 0 ){\n            fieldStr = fieldStr.toLowerCase();\n            valStr = valStr.toLowerCase();\n            \n            operator = operator.replace('@', '');\n            caseInsensitive = true;\n          }\n\n          var notExpr = false;\n          var handledNotExpr = false;\n          if( operator.indexOf('!') >= 0 ){\n            operator = operator.replace('!', '');\n            notExpr = true;\n          }\n          \n          // if we're doing a case insensitive comparison, then we're using a STRING comparison\n          // even if we're comparing numbers\n          if( caseInsensitive ){\n            value = valStr.toLowerCase();\n            fieldVal = fieldStr.toLowerCase();\n          }\n\n          switch(operator){\n          case '*=':\n            matches = fieldStr.search(valStr) >= 0;\n            break;\n          case '$=':\n            matches = new RegExp(valStr + '$').exec(fieldStr) != null;\n            break;\n          case '^=':\n            matches = new RegExp('^' + valStr).exec(fieldStr) != null;\n            break;\n          case '=':\n            matches = fieldVal === value;\n            break;\n          case '!=':\n            matches = fieldVal !== value;\n            break;\n          case '>':\n            matches = !notExpr ? fieldVal > value : fieldVal <= value;\n            handledNotExpr = true;\n            break;\n          case '>=':\n            matches = !notExpr ? fieldVal >= value : fieldVal < value;\n            handledNotExpr = true;\n            break;\n          case '<':\n            matches = !notExpr ? fieldVal < value : fieldVal >= value;\n            handledNotExpr = true;\n            break;\n          case '<=':\n            matches = !notExpr ? fieldVal <= value : fieldVal > value;\n            handledNotExpr = true;\n            break;\n          default:\n            matches = false;\n            break;\n            \n          }\n        } else if( operator != null ){\n          switch(operator){\n          case '?':\n            matches = params.fieldTruthy(field);\n            break;\n          case '!':\n            matches = !params.fieldTruthy(field);\n            break;\n          case '^':\n            matches = params.fieldUndefined(field);\n            break;\n          }\n        } else {   \n          matches = !params.fieldUndefined(field);\n        }\n\n        if( notExpr && !handledNotExpr ){\n          matches = !matches;\n          handledNotExpr = true;\n        }\n        \n        if( !matches ){\n          allDataMatches = false;\n          break;\n        }\n      } // for\n      \n      return allDataMatches;\n    }; // operandsMatch\n    \n    // check data matches\n    var allDataMatches = operandsMatch({\n      name: 'data',\n      fieldValue: function(field){\n        return element._private.data[field];\n      },\n      fieldRef: function(field){\n        return 'element._private.data.' + field;\n      },\n      fieldUndefined: function(field){\n        return element._private.data[field] === undefined;\n      },\n      fieldTruthy: function(field){\n        if( element._private.data[field] ){\n          return true;\n        }\n        return false;\n      }\n    });\n    \n    if( !allDataMatches ){\n      return false;\n    }\n    \n    // check metadata matches\n    var allMetaMatches = operandsMatch({\n      name: 'meta',\n      fieldValue: function(field){\n        return element[field]();\n      },\n      fieldRef: function(field){\n        return 'element.' + field + '()';\n      },\n      fieldUndefined: function(field){\n        return element[field]() == null;\n      },\n      fieldTruthy: function(field){\n        if( element[field]() ){\n          return true;\n        }\n        return false;\n      }\n    });\n    \n    if( !allMetaMatches ){\n      return false;\n    }\n    \n    // check collection\n    if( query.collection != null ){\n      var matchesAny = query.collection._private.ids[ element.id() ] != null;\n      \n      if( !matchesAny ){\n        return false;\n      }\n    }\n    \n    // check filter function\n    if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){\n      return false;\n    }\n    \n\n    // check parent/child relations\n    var confirmRelations = function( query, elements ){\n      if( query != null ){\n        var matches = false;\n\n        if( !cy.hasCompoundNodes() ){\n          return false;\n        }\n\n        elements = elements(); // make elements functional so we save cycles if query == null\n\n        // query must match for at least one element (may be recursive)\n        for(var i = 0; i < elements.length; i++){\n          if( queryMatches( query, elements[i] ) ){\n            matches = true;\n            break;\n          }\n        }\n\n        return matches;\n      } else {\n        return true;\n      }\n    };\n\n    if (! confirmRelations(query.parent, function(){\n      return element.parent();\n    }) ){ return false; }\n\n    if (! confirmRelations(query.ancestor, function(){\n      return element.parents();\n    }) ){ return false; }\n\n    if (! confirmRelations(query.child, function(){\n      return element.children();\n    }) ){ return false; }\n\n    if (! confirmRelations(query.descendant, function(){\n      return element.descendants();\n    }) ){ return false; }\n\n    // we've reached the end, so we've matched everything for this query\n    return true;\n  }; // queryMatches\n\n  // filter an existing collection\n  $$.selfn.filter = function(collection){\n    var self = this;\n    var cy = collection.cy();\n    \n    // don't bother trying if it's invalid\n    if( self._private.invalid ){\n      return new $$.Collection( cy );\n    }\n  \n    var selectorFunction = function(i, element){\n      for(var j = 0; j < self.length; j++){\n        var query = self[j];\n        \n        if( queryMatches(query, element) ){\n          return true;\n        }\n      }\n      \n      return false;\n    };\n    \n    if( self._private.selectorText == null ){\n      selectorFunction = function(){ return true; };\n    }\n    \n    var filteredCollection = collection.filter( selectorFunction );\n    \n    return filteredCollection;\n  }; // filter\n\n  // does selector match a single element?\n  $$.selfn.matches = function(ele){\n    var self = this;\n    \n    // don't bother trying if it's invalid\n    if( self._private.invalid ){\n      return false;\n    }\n  \n    for(var j = 0; j < self.length; j++){\n      var query = self[j];\n      \n      if( queryMatches(query, ele) ){\n        return true;\n      }\n    }\n    \n    return false;\n  }; // filter\n  \n  // ith query to string\n  $$.selfn.toString = $$.selfn.selector = function(){\n    \n    var str = '';\n    \n    var clean = function(obj){\n      if( $$.is.string(obj) ){\n        return obj;\n      } \n      return '';\n    };\n    \n    var queryToString = function(query){\n      var str = '';\n\n      var group = clean(query.group);\n      str += group.substring(0, group.length - 1);\n      \n      for(var j = 0; j < query.data.length; j++){\n        var data = query.data[j];\n        \n        if( data.value ){\n          str += '[' + data.field + clean(data.operator) + clean(data.value) + ']';\n        } else {\n          str += '[' + clean(data.operator) + data.field + ']';\n        }\n      }\n\n      for(var j = 0; j < query.meta.length; j++){\n        var meta = query.meta[j];\n        str += '[[' + meta.field + clean(meta.operator) + clean(meta.value) + ']]';\n      }\n      \n      for(var j = 0; j < query.colonSelectors.length; j++){\n        var sel = query.colonSelectors[i];\n        str += sel;\n      }\n      \n      for(var j = 0; j < query.ids.length; j++){\n        var sel = '#' + query.ids[i];\n        str += sel;\n      }\n      \n      for(var j = 0; j < query.classes.length; j++){\n        var sel = '.' + query.classes[i];\n        str += sel;\n      }\n\n      if( query.parent != null ){\n        str = queryToString( query.parent ) + ' > ' + str; \n      }\n\n      if( query.ancestor != null ){\n        str = queryToString( query.ancestor ) + ' ' + str; \n      }\n\n      if( query.child != null ){\n        str += ' > ' + queryToString( query.child ); \n      }\n\n      if( query.descendant != null ){\n        str += ' ' + queryToString( query.descendant ); \n      }\n\n      return str;\n    };\n\n    for(var i = 0; i < this.length; i++){\n      var query = this[i];\n      \n      str += queryToString( query );\n      \n      if( this.length > 1 && i < this.length - 1 ){\n        str += ', ';\n      }\n    }\n    \n    return str;\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.Style = function( cy ){\n\n    if( !(this instanceof $$.Style) ){\n      return new $$.Style(cy);\n    }\n\n    if( !$$.is.core(cy) ){\n      $$.util.error('A style must have a core reference');\n      return;\n    }\n\n    this._private = {\n      cy: cy,\n      coreStyle: {},\n      newStyle: true\n    };\n    \n    this.length = 0;\n\n    this.addDefaultStylesheet();\n  };\n\n  // nice-to-have aliases\n  $$.style = $$.Style;\n  $$.styfn = $$.Style.prototype;\n\n  // define functions in the Style prototype\n  $$.fn.style = function( fnMap, options ){\n    for( var fnName in fnMap ){\n      var fn = fnMap[ fnName ];\n      $$.Style.prototype = fn;\n    }\n  };\n\n  (function(){\n    var number = $$.util.regex.number;\n    var rgba = $$.util.regex.rgbaNoBackRefs;\n    var hsla = $$.util.regex.hslaNoBackRefs;\n    var hex3 = $$.util.regex.hex3;\n    var hex6 = $$.util.regex.hex6;\n    var data = function( prefix ){ return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$'; };\n    var mapData = function( prefix ){ return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\\\s*\\\\,\\\\s*(' + number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\\\)$'; };\n\n    // each visual style property has a type and needs to be validated according to it\n    $$.style.types = {\n      time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },\n      percent: { number: true, min: 0, max: 100, units: '%' },\n      zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },\n      nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },\n      nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },\n      position: { enums: ['parent', 'origin'] },\n      autoSize: { number: true, min: 0, enums: ['auto'] },\n      number: { number: true },\n      size: { number: true, min: 0 },\n      bgSize: { number: true, min: 0, allowPercent: true },\n      bgPos: { number: true, allowPercent: true },\n      bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },\n      bgFit: { enums: ['none', 'contain', 'cover'] },\n      bgClip: { enums: ['none', 'node'] },\n      color: { color: true },\n      lineStyle: { enums: ['solid', 'dotted', 'dashed'] },\n      borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },\n      curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack'] },\n      fontFamily: { regex: '^([\\\\w- ]+(?:\\\\s*,\\\\s*[\\\\w- ]+)*)$' },\n      fontVariant: { enums: ['small-caps', 'normal'] },\n      fontStyle: { enums: ['italic', 'normal', 'oblique'] },\n      fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },\n      textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },\n      textTransform: { enums: ['none', 'uppercase', 'lowercase'] },\n      nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star'] },\n      arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'square', 'circle', 'diamond', 'none'] },\n      arrowFill: { enums: ['filled', 'hollow'] },\n      display: { enums: ['element', 'none'] },\n      visibility: { enums: ['hidden', 'visible'] },\n      valign: { enums: ['top', 'center', 'bottom'] },\n      halign: { enums: ['left', 'center', 'right'] },\n      text: { string: true },\n      data: { mapping: true, regex: data('data') },\n      layoutData: { mapping: true, regex: data('layoutData') },\n      mapData: { mapping: true, regex: mapData('mapData') },\n      mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },\n      url: { regex: '^url\\\\s*\\\\(\\\\s*([^\\\\s]+)\\\\s*\\\\s*\\\\)|none|(.+)$' },\n      propList: { propList: true },\n      angle: { number: true, units: 'deg|rad' }\n    };\n\n    // define visual style properties\n    var t = $$.style.types;\n    var props = $$.style.properties = [\n      // labels\n      { name: 'text-valign', type: t.valign },\n      { name: 'text-halign', type: t.halign },\n      { name: 'color', type: t.color },\n      { name: 'content', type: t.text },\n      { name: 'text-outline-color', type: t.color },\n      { name: 'text-outline-width', type: t.size },\n      { name: 'text-outline-opacity', type: t.zeroOneNumber },\n      { name: 'text-opacity', type: t.zeroOneNumber },\n      // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas\n      { name: 'text-transform', type: t.textTransform },\n      // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes\n      { name: 'font-family', type: t.fontFamily },\n      { name: 'font-style', type: t.fontStyle },\n      // { name: 'font-variant', type: t.fontVariant }, // not useful\n      { name: 'font-weight', type: t.fontWeight },\n      { name: 'font-size', type: t.size },\n      { name: 'min-zoomed-font-size', type: t.size },\n\n      // visibility\n      { name: 'display', type: t.display },\n      { name: 'visibility', type: t.visibility },\n      { name: 'opacity', type: t.zeroOneNumber },\n      { name: 'z-index', type: t.nonNegativeInt },\n\n      // overlays\n      { name: 'overlay-padding', type: t.size },\n      { name: 'overlay-color', type: t.color },\n      { name: 'overlay-opacity', type: t.zeroOneNumber },\n\n      // transition anis\n      { name: 'transition-property', type: t.propList },\n      { name: 'transition-duration', type: t.time },\n      { name: 'transition-delay', type: t.time },\n\n      // node body\n      { name: 'height', type: t.autoSize },\n      { name: 'width', type: t.autoSize },\n      { name: 'shape', type: t.nodeShape },\n      { name: 'background-color', type: t.color },\n      { name: 'background-opacity', type: t.zeroOneNumber },\n      { name: 'background-blacken', type: t.nOneOneNumber },\n\n      // node border\n      { name: 'border-color', type: t.color },\n      { name: 'border-opacity', type: t.zeroOneNumber },\n      { name: 'border-width', type: t.size },\n      { name: 'border-style', type: t.borderStyle },\n      \n      // node background images\n      { name: 'background-image', type: t.url },\n      { name: 'background-image-opacity', type: t.zeroOneNumber },\n      { name: 'background-position-x', type: t.bgPos },\n      { name: 'background-position-y', type: t.bgPos },\n      { name: 'background-repeat', type: t.bgRepeat },\n      { name: 'background-fit', type: t.bgFit },\n      { name: 'background-clip', type: t.bgClip },\n\n      // compound props\n      { name: 'padding-left', type: t.size },\n      { name: 'padding-right', type: t.size },\n      { name: 'padding-top', type: t.size },\n      { name: 'padding-bottom', type: t.size },\n      { name: 'position', type: t.position },\n\n      // edge line\n      { name: 'line-style', type: t.lineStyle },\n      { name: 'line-color', type: t.color },\n      { name: 'control-point-step-size', type: t.size },\n      { name: 'control-point-distance', type: t.number },\n      { name: 'control-point-weight', type: t.zeroOneNumber },\n      { name: 'curve-style', type: t.curveStyle },\n      { name: 'haystack-radius', type: t.zeroOneNumber },\n\n      // edge arrows\n      { name: 'source-arrow-shape', type: t.arrowShape },\n      { name: 'target-arrow-shape', type: t.arrowShape },\n      { name: 'mid-source-arrow-shape', type: t.arrowShape },\n      { name: 'mid-target-arrow-shape', type: t.arrowShape },\n      { name: 'source-arrow-color', type: t.color },\n      { name: 'target-arrow-color', type: t.color },\n      { name: 'mid-source-arrow-color', type: t.color },\n      { name: 'mid-target-arrow-color', type: t.color },\n      { name: 'source-arrow-fill', type: t.arrowFill },\n      { name: 'target-arrow-fill', type: t.arrowFill },\n      { name: 'mid-source-arrow-fill', type: t.arrowFill },\n      { name: 'mid-target-arrow-fill', type: t.arrowFill },\n\n      // these are just for the core\n      { name: 'selection-box-color', type: t.color },\n      { name: 'selection-box-opacity', type: t.zeroOneNumber },\n      { name: 'selection-box-border-color', type: t.color },\n      { name: 'selection-box-border-width', type: t.size },\n      { name: 'active-bg-color', type: t.color },\n      { name: 'active-bg-opacity', type: t.zeroOneNumber },\n      { name: 'active-bg-size', type: t.size },\n      { name: 'outside-texture-bg-color', type: t.color },\n      { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }\n    ];\n\n    // pie backgrounds for nodes\n    $$.style.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n    props.push({ name: 'pie-size', type: t.bgSize });\n    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){\n      props.push({ name: 'pie-'+i+'-background-color', type: t.color });\n      props.push({ name: 'pie-'+i+'-background-size', type: t.percent });\n      props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });\n    }\n\n    // allow access of properties by name ( e.g. $$.style.properties.height )\n    for( var i = 0; i < props.length; i++ ){\n      var prop = props[i];\n      \n      props[ prop.name ] = prop; // allow lookup by name\n    }\n  })();\n\n  // adds the default stylesheet to the current style\n  $$.styfn.addDefaultStylesheet = function(){\n    // to be nice, we build font related style properties from the core container\n    // so that cytoscape matches the style of its container by default\n    // \n    // unfortunately, this doesn't seem work consistently and can grab the default stylesheet values\n    // instead of the developer's values so let's just make it explicit for the dev for now\n    //\n    // delaying the read of these val's is not an opt'n: that would delay init'l load time\n    var fontFamily = 'Helvetica' || this.containerPropertyAsString('font-family') || 'sans-serif';\n    var fontStyle = 'normal' || this.containerPropertyAsString('font-style') || 'normal';\n    // var fontVariant = 'normal' || this.containerPropertyAsString('font-variant') || 'normal';\n    var fontWeight = 'normal' || this.containerPropertyAsString('font-weight') || 'normal';\n    var color = '#000' || this.containerPropertyAsString('color') || '#000';\n    var textTransform = 'none' || this.containerPropertyAsString('text-transform') || 'none';\n    var fontSize = 16 || this.containerPropertyAsString('font-size') || 16;\n\n    // fill the style with the default stylesheet\n    this\n      .selector('node, edge') // common properties\n        .css({\n          'text-valign': 'top',\n          'text-halign': 'center',\n          'color': color,\n          'text-outline-color': '#000',\n          'text-outline-width': 0,\n          'text-outline-opacity': 1,\n          'text-opacity': 1,\n          'text-decoration': 'none',\n          'text-transform': textTransform,\n          'font-family': fontFamily,\n          'font-style': fontStyle,\n          // 'font-variant': fontVariant,\n          'font-weight': fontWeight,\n          'font-size': fontSize,\n          'min-zoomed-font-size': 0,\n          'visibility': 'visible',\n          'display': 'element',\n          'opacity': 1,\n          'z-index': 0,\n          'content': '',\n          'overlay-opacity': 0,\n          'overlay-color': '#000',\n          'overlay-padding': 10,\n          'transition-property': 'none',\n          'transition-duration': 0,\n          'transition-delay': 0,\n\n          // node props\n          'background-blacken': 0,\n          'background-color': '#888',\n          'background-opacity': 1,\n          'background-image': 'none',\n          'background-image-opacity': 1,\n          'background-position-x': '50%',\n          'background-position-y': '50%',\n          'background-repeat': 'no-repeat',\n          'background-fit': 'none',\n          'background-clip': 'node',\n          'border-color': '#000',\n          'border-opacity': 1,\n          'border-width': 0,\n          'border-style': 'solid',\n          'height': 30,\n          'width': 30,\n          'shape': 'ellipse',\n\n          // compound props\n          'padding-top': 0,\n          'padding-bottom': 0,\n          'padding-left': 0,\n          'padding-right': 0,\n          'position': 'origin',\n          \n\n          // node pie bg\n          'pie-size': '100%',\n          'pie-1-background-color': 'black',\n          'pie-2-background-color': 'black',\n          'pie-3-background-color': 'black',\n          'pie-4-background-color': 'black',\n          'pie-5-background-color': 'black',\n          'pie-6-background-color': 'black',\n          'pie-7-background-color': 'black',\n          'pie-8-background-color': 'black',\n          'pie-9-background-color': 'black',\n          'pie-10-background-color': 'black',\n          'pie-11-background-color': 'black',\n          'pie-12-background-color': 'black',\n          'pie-13-background-color': 'black',\n          'pie-14-background-color': 'black',\n          'pie-15-background-color': 'black',\n          'pie-16-background-color': 'black',\n          'pie-1-background-size': '0%',\n          'pie-2-background-size': '0%',\n          'pie-3-background-size': '0%',\n          'pie-4-background-size': '0%',\n          'pie-5-background-size': '0%',\n          'pie-6-background-size': '0%',\n          'pie-7-background-size': '0%',\n          'pie-8-background-size': '0%',\n          'pie-9-background-size': '0%',\n          'pie-10-background-size': '0%',\n          'pie-11-background-size': '0%',\n          'pie-12-background-size': '0%',\n          'pie-13-background-size': '0%',\n          'pie-14-background-size': '0%',\n          'pie-15-background-size': '0%',\n          'pie-16-background-size': '0%',\n          'pie-1-background-opacity': 1,\n          'pie-2-background-opacity': 1,\n          'pie-3-background-opacity': 1,\n          'pie-4-background-opacity': 1,\n          'pie-5-background-opacity': 1,\n          'pie-6-background-opacity': 1,\n          'pie-7-background-opacity': 1,\n          'pie-8-background-opacity': 1,\n          'pie-9-background-opacity': 1,\n          'pie-10-background-opacity': 1,\n          'pie-11-background-opacity': 1,\n          'pie-12-background-opacity': 1,\n          'pie-13-background-opacity': 1,\n          'pie-14-background-opacity': 1,\n          'pie-15-background-opacity': 1,\n          'pie-16-background-opacity': 1,\n\n          // edge props\n          'source-arrow-shape': 'none',\n          'mid-source-arrow-shape': 'none',\n          'target-arrow-shape': 'none',\n          'mid-target-arrow-shape': 'none',\n          'source-arrow-color': '#ddd',\n          'mid-source-arrow-color': '#ddd',\n          'target-arrow-color': '#ddd',\n          'mid-target-arrow-color': '#ddd',\n          'source-arrow-fill': 'filled',\n          'mid-source-arrow-fill': 'filled',\n          'target-arrow-fill': 'filled',\n          'mid-target-arrow-fill': 'filled',\n          'line-style': 'solid',\n          'line-color': '#ddd',\n          'control-point-step-size': 40,\n          'control-point-weight': 0.5,\n          'curve-style': 'bezier',\n          'haystack-radius': 0.8\n        })\n      .selector('$node > node') // compound (parent) node properties\n        .css({\n          'width': 'auto',\n          'height': 'auto',\n          'shape': 'rectangle',\n          'background-opacity': 0.5,\n          'padding-top': 10,\n          'padding-right': 10,\n          'padding-left': 10,\n          'padding-bottom': 10\n        })\n      .selector('edge') // just edge properties\n        .css({\n          'width': 1\n        })\n      .selector(':active')\n        .css({\n          'overlay-color': 'black',\n          'overlay-padding': 10,\n          'overlay-opacity': 0.25\n        })\n      .selector('core') // just core properties\n        .css({\n          'selection-box-color': '#ddd',\n          'selection-box-opacity': 0.65,\n          'selection-box-border-color': '#aaa',\n          'selection-box-border-width': 1,\n          'active-bg-color': 'black',\n          'active-bg-opacity': 0.15,\n          'active-bg-size': $$.is.touch() ? 40 : 15,\n          'outside-texture-bg-color': '#000',\n          'outside-texture-bg-opacity': 0.125\n        })\n    ;\n  };\n\n  // remove all contexts\n  $$.styfn.clear = function(){\n    for( var i = 0; i < this.length; i++ ){\n      this[i] = undefined;\n    }\n    this.length = 0;\n    this._private.newStyle = true;\n\n    return this; // chaining\n  };\n\n  $$.styfn.resetToDefault = function(){\n    this.clear();\n    this.addDefaultStylesheet();\n\n    return this;\n  };\n\n  // builds a style object for the 'core' selector\n  $$.styfn.core = function(){\n    return this._private.coreStyle;\n  };\n\n  // parse a property; return null on invalid; return parsed property otherwise\n  // fields :\n  // - name : the name of the property\n  // - value : the parsed, native-typed value of the property\n  // - strValue : a string value that represents the property value in valid css\n  // - bypass : true iff the property is a bypass property\n  $$.styfn.parse = function( name, value, propIsBypass, propIsFlat ){\n    \n    name = $$.util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n    var property = $$.style.properties[ name ];\n    var passedValue = value;\n    \n    if( !property ){ return null; } // return null on property of unknown name\n    if( value === undefined || value === null ){ return null; } // can't assign null\n\n    var valueIsString = $$.is.string(value);\n    if( valueIsString ){ // trim the value to make parsing easier\n      value = $$.util.trim( value );\n    }\n\n    var type = property.type;\n    if( !type ){ return null; } // no type, no luck\n\n    // check if bypass is null or empty string (i.e. indication to delete bypass property)\n    if( propIsBypass && (value === '' || value === null) ){\n      return {\n        name: name,\n        value: value,\n        bypass: true,\n        deleteBypass: true\n      };\n    }\n\n    // check if value is mapped\n    var data, mapData, layoutData, mapLayoutData;\n    if( !valueIsString || propIsFlat ){\n      // then don't bother to do the expensive regex checks\n\n    } else if(\n      ( data = new RegExp( $$.style.types.data.regex ).exec( value ) ) ||\n      ( layoutData = new RegExp( $$.style.types.layoutData.regex ).exec( value ) )\n    ){\n      if( propIsBypass ){ return false; } // mappers not allowed in bypass\n      \n      var isLayout = layoutData !== undefined;\n      data = data || layoutData;\n\n      return {\n        name: name,\n        value: data,\n        strValue: '' + value,\n        mapped: isLayout ? $$.style.types.layoutData : $$.style.types.data,\n        field: data[1],\n        bypass: propIsBypass,\n        hasPie: name.match(/pie-(\\d+)-background-size/)\n      };\n\n    } else if(\n      ( mapData = new RegExp( $$.style.types.mapData.regex ).exec( value ) ) ||\n      ( mapLayoutData = new RegExp( $$.style.types.mapLayoutData.regex ).exec( value ) )\n    ){\n      if( propIsBypass ){ return false; } // mappers not allowed in bypass\n\n      var isLayout = mapLayoutData !== undefined;\n      mapData = mapData || mapLayoutData;\n\n      // we can map only if the type is a colour or a number\n      if( !(type.color || type.number) ){ return false; }\n\n      var valueMin = this.parse( name, mapData[4]); // parse to validate\n      if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped\n\n      var valueMax = this.parse( name, mapData[5]); // parse to validate\n      if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped\n\n      // check if valueMin and valueMax are the same\n      if( valueMin.value === valueMax.value ){\n        return false; // can't make much of a mapper without a range\n      \n      } else if( type.color ){\n        var c1 = valueMin.value;\n        var c2 = valueMax.value;\n        \n        var same = c1[0] === c2[0] // red\n          && c1[1] === c2[1] // green\n          && c1[2] === c2[2] // blue\n          && ( // optional alpha\n            c1[3] === c2[3] // same alpha outright\n            || (\n              (c1[3] == null || c1[3] === 1) // full opacity for colour 1?\n              &&\n              (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n            )\n          )\n        ;\n\n        if( same ){ return false; } // can't make a mapper without a range\n      }\n\n      return {\n        name: name,\n        value: mapData,\n        strValue: '' + value,\n        mapped: isLayout ? $$.style.types.mapLayoutData : $$.style.types.mapData,\n        field: mapData[1],\n        fieldMin: parseFloat( mapData[2] ), // min & max are numeric\n        fieldMax: parseFloat( mapData[3] ),\n        valueMin: valueMin.value,\n        valueMax: valueMax.value,\n        bypass: propIsBypass,\n        hasPie: name.match(/pie-(\\d+)-background-size/)\n      };\n    }\n\n    // check the type and return the appropriate object\n    if( type.number ){ \n      var units;\n      var implicitUnits = 'px'; // not set => px\n\n      if( type.units ){ // use specified units if set\n        units = type.units;\n      }\n\n      if( type.implicitUnits ){\n        implicitUnits = type.implicitUnits;\n      }\n\n      if( !type.unitless ){\n        if( valueIsString ){\n          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n          if( units ){ unitsRegex = units; } // only allow explicit units if so set \n          var match = value.match( '^(' + $$.util.regex.number + ')(' + unitsRegex + ')?' + '$' );\n          \n          if( match ){\n            value = match[1];\n            units = match[2] || implicitUnits;\n          }\n          \n        } else if( !units || type.implicitUnits ) {\n          units = implicitUnits; // implicitly px if unspecified\n        }\n      }\n\n      value = parseFloat( value );\n\n      // if not a number and enums not allowed, then the value is invalid\n      if( isNaN(value) && type.enums === undefined ){\n        return null;\n      }\n\n      // check if this number type also accepts special keywords in place of numbers\n      // (i.e. `left`, `auto`, etc)\n      if( isNaN(value) && type.enums !== undefined ){\n        value = passedValue;\n\n        for( var i = 0; i < type.enums.length; i++ ){\n          var en = type.enums[i];\n\n          if( en === value ){\n            return {\n              name: name,\n              value: value,\n              strValue: '' + value,\n              bypass: propIsBypass\n            };\n          }\n        }\n\n        return null; // failed on enum after failing on number\n      }\n\n      // check if value must be an integer\n      if( type.integer && !$$.is.integer(value) ){\n        return null;\n      }\n\n      // check value is within range\n      if( (type.min !== undefined && value < type.min) \n      || (type.max !== undefined && value > type.max)\n      ){\n        return null;\n      }\n\n      var ret = {\n        name: name,\n        value: value,\n        strValue: '' + value + (units ? units : ''),\n        units: units,\n        bypass: propIsBypass,\n        hasPie: name.match(/pie-(\\d+)-background-size/) && value != null && value !== 0 && value !== ''\n      };\n\n      // normalise value in pixels\n      if( type.unitless || (units !== 'px' && units !== 'em') ){\n        // then pxValue does not apply\n      } else {\n        ret.pxValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );\n      }\n\n      // normalise value in ms\n      if( units === 'ms' || units === 's' ){\n        ret.msValue = units === 'ms' ? value : 1000 * value;\n      }\n\n      return ret;\n\n    } else if( type.propList ) {\n\n      var props = [];\n      var propsStr = '' + value;      \n \n      if( propsStr === 'none' ){\n        // leave empty\n\n      } else { // go over each prop\n\n        var propsSplit = propsStr.split(',');\n        for( var i = 0; i < propsSplit.length; i++ ){\n          var propName = $$.util.trim( propsSplit[i] );\n\n          if( $$.style.properties[propName] ){\n            props.push( propName );\n          }\n        }\n\n        if( props.length === 0 ){ return null; }\n\n      }\n\n      return {\n        name: name,\n        value: props,\n        strValue: props.length === 0 ? 'none' : props.join(', '),\n        bypass: propIsBypass\n      };\n\n    } else if( type.color ){\n      var tuple = $$.util.color2tuple( value );\n\n      if( !tuple ){ return null; }\n\n      return {\n        name: name,\n        value: tuple,\n        strValue: '' + value,\n        bypass: propIsBypass\n      };\n\n    } else if( type.enums ){\n      for( var i = 0; i < type.enums.length; i++ ){\n        var en = type.enums[i];\n\n        if( en === value ){\n          return {\n            name: name,\n            value: value,\n            strValue: '' + value,\n            bypass: propIsBypass\n          };\n        }\n      }\n\n      return null;\n\n    } else if( type.regex ){\n      var regex = new RegExp( type.regex ); // make a regex from the type\n      var m = regex.exec( value );\n\n      if( m ){ // regex matches\n        return {\n          name: name,\n          value: m,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      } else { // regex doesn't match\n        return null; // didn't match the regex so the value is bogus\n      }\n\n    } else if( type.string ){\n      // just return\n      return {\n        name: name,\n        value: value,\n        strValue: '' + value,\n        bypass: propIsBypass\n      };\n\n    } else {\n      return null; // not a type we can handle\n    }\n\n  };\n\n  // create a new context from the specified selector string and switch to that context\n  $$.styfn.selector = function( selectorStr ){\n    // 'core' is a special case and does not need a selector\n    var selector = selectorStr === 'core' ? null : new $$.Selector( selectorStr );\n\n    var i = this.length++; // new context means new index\n    this[i] = {\n      selector: selector,\n      properties: [],\n      mappedProperties: [],\n      index: i\n    };\n\n    return this; // chaining\n  };\n\n  // add one or many css rules to the current context\n  $$.styfn.css = function(){\n    var args = arguments;\n\n    switch( args.length ){\n    case 1:\n      var map = args[0];\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var mapVal = map[ prop.name ];\n\n        if( mapVal === undefined ){\n          mapVal = map[ $$.util.dash2camel(prop.name) ];\n        }\n\n        if( mapVal !== undefined ){\n          this.cssRule( prop.name, mapVal );\n        }\n      }\n\n      break;\n\n    case 2:\n      this.cssRule( args[0], args[1] );\n      break;\n\n    default:\n      break; // do nothing if args are invalid\n    }\n\n    return this; // chaining\n  };\n\n  // add a single css rule to the current context\n  $$.styfn.cssRule = function( name, value ){ \n    // name-value pair\n    var property = this.parse( name, value );\n\n    // add property to current context if valid\n    if( property ){\n      var i = this.length - 1;\n      this[i].properties.push( property );\n      this[i].properties[ property.name ] = property; // allow access by name as well\n\n      if( property.hasPie ){\n        this._private.hasPie = true;\n      }\n\n      if( property.mapped ){\n        this[i].mappedProperties.push( property );\n      }\n\n      // add to core style if necessary\n      var currentSelectorIsCore = !this[i].selector;\n      if( currentSelectorIsCore ){\n        this._private.coreStyle[ property.name ] = property;\n      }\n    }\n\n    return this; // chaining\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  // (potentially expensive calculation)\n  // apply the style to the element based on\n  // - its bypass\n  // - what selectors match it\n  $$.styfn.apply = function( eles ){\n    var self = this;\n\n    if( self._private.newStyle ){ // clear style caches\n      this._private.contextStyles = {};\n      this._private.propDiffs = {};\n    }\n\n    for( var ie = 0; ie < eles.length; ie++ ){\n      var ele = eles[ie];\n      var cxtMeta = self.getContextMeta( ele );\n      var cxtStyle = self.getContextStyle( cxtMeta );\n      var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );\n\n      self.updateTransitions( ele, app.diffProps );\n      self.updateStyleHints( ele );\n\n    } // for elements\n\n    self._private.newStyle = false;\n  };\n\n  $$.styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){\n    var self = this;\n    var cache = self._private.propDiffs = self._private.propDiffs || {};\n    var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n    var cachedVal = cache[dualCxtKey];\n\n    if( cachedVal ){\n      return cachedVal;\n    }\n\n    var diffProps = [];\n    var addedProp = {};\n\n    for( var i = 0; i < self.length; i++ ){\n      var cxt = self[i];\n      var oldHasCxt = oldCxtKey[i] === 't';\n      var newHasCxt = newCxtKey[i] === 't';\n      var cxtHasDiffed = oldHasCxt !== newHasCxt;\n      var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n      if( cxtHasDiffed || cxtHasMappedProps ){\n        var props;\n\n        if( cxtHasDiffed && cxtHasMappedProps ){\n          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n        } else if( cxtHasDiffed ){\n          props = cxt.properties; // need to check them all\n        } else if( cxtHasMappedProps ){\n          props = cxt.mappedProperties; // only need to check mapped\n        }\n\n        for( var j = 0; j < props.length; j++ ){\n          var prop = props[j];\n          var name = prop.name;\n\n          // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n          // is cached)\n          var laterCxtOverrides = false; \n          for( var k = i + 1; k < self.length; k++ ){\n            var laterCxt = self[k];\n            var hasLaterCxt = newCxtKey[k] === 't';\n\n            if( !hasLaterCxt ){ continue; } // can't override unless the context is active\n\n            laterCxtOverrides = laterCxt.properties[ prop.name ] != null;\n\n            if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides\n          }\n\n          if( !addedProp[name] && !laterCxtOverrides ){\n            addedProp[name] = true;\n            diffProps.push( name );\n          }\n        } // for props\n      } // if\n\n    } // for contexts\n\n    cache[ dualCxtKey ] = diffProps;\n    return diffProps;\n  };\n\n  $$.styfn.getContextMeta = function( ele ){\n    var self = this;\n    var cxtKey = '';\n    var diffProps;\n    var prevKey = ele._private.styleCxtKey || '';\n\n    if( self._private.newStyle ){\n      prevKey = ''; // since we need to apply all style if a fresh stylesheet\n    }\n\n    // get the cxt key\n    for( var i = 0; i < self.length; i++ ){\n      var context = self[i];\n      var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'\n\n      if( contextSelectorMatches ){\n        cxtKey += 't';\n      } else {\n        cxtKey += 'f';\n      }\n    } // for context\n\n    diffProps = self.getPropertiesDiff( prevKey, cxtKey );\n\n    ele._private.styleCxtKey = cxtKey;\n\n    return {\n      key: cxtKey,\n      diffPropNames: diffProps\n    };\n  };\n\n  // gets a computed ele style object based on matched contexts\n  $$.styfn.getContextStyle = function( cxtMeta ){\n    var cxtKey = cxtMeta.key;\n    var self = this;\n    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n\n    // if already computed style, returned cached copy\n    if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }\n\n    var style = {\n      _private: {\n        key: cxtKey\n      }\n    };\n\n    for( var i = 0; i < self.length; i++ ){\n      var cxt = self[i];\n      var hasCxt = cxtKey[i] === 't';\n\n      if( !hasCxt ){ continue; }\n\n      for( var j = 0; j < cxt.properties.length; j++ ){\n        var prop = cxt.properties[j];\n        var styProp = style[ prop.name ] = prop;\n\n        styProp.context = cxt;\n      }\n    }\n\n    cxtStyles[cxtKey] = style;\n    return style;\n  };\n\n  $$.styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){\n    var self = this;\n    var diffProps = cxtMeta.diffPropNames;\n    var retDiffProps = {};\n\n    for( var i = 0; i < diffProps.length; i++ ){\n      var diffPropName = diffProps[i];\n      var cxtProp = cxtStyle[ diffPropName ];\n      var eleProp = ele._private.style[ diffPropName ];\n\n      // save cycles when the context prop doesn't need to be applied\n      if( !cxtProp || eleProp === cxtProp ){ continue; }\n\n      var retDiffProp = retDiffProps[ diffPropName ] = {\n        prev: eleProp\n      };\n\n      self.applyParsedProperty( ele, cxtProp );\n\n      retDiffProp.next = ele._private.style[ diffPropName ];\n\n      if( retDiffProp.next.bypass ){\n        retDiffProp.next = retDiffProp.next.bypassed;\n      }\n    }\n\n    return {\n      diffProps: retDiffProps\n    };\n  };\n\n  $$.styfn.updateStyleHints = function(ele){\n    var _p = ele._private;\n    var self = this;\n    var style = _p.style;\n\n    // set whether has pie or not; for greater efficiency\n    var hasPie = false;\n    if( _p.group === 'nodes' && self._private.hasPie ){\n      for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N\n        var size = _p.style['pie-' + i + '-background-size'].value;\n\n        if( size > 0 ){\n          hasPie = true;\n          break;\n        }\n      }\n    }\n\n    _p.hasPie = hasPie;\n\n    var transform = style['text-transform'].strValue;\n    var content = style['content'].strValue;\n    var fStyle = style['font-style'].strValue;\n    var size = style['font-size'].pxValue + 'px';\n    var family = style['font-family'].strValue;\n    // var variant = style['font-variant'].strValue;\n    var weight = style['font-weight'].strValue;\n    var valign = style['text-valign'].strValue;\n    var halign = style['text-valign'].strValue;\n    var oWidth = style['text-outline-width'].pxValue;\n    _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth;\n    _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;\n\n    var width = style['width'].pxValue;\n    var height = style['height'].pxValue;\n    var borderW = style['border-width'].pxValue;\n    _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;\n\n    if( ele._private.group === 'edges' ){\n      var cpss = style['control-point-step-size'].pxValue;\n      var cpd = style['control-point-distance'] ? style['control-point-distance'].pxValue : undefined;\n      var cpw = style['control-point-weight'].value;\n      var curve = style['curve-style'].strValue;\n      \n      _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ curve;\n    }\n\n    _p.styleKey = Date.now(); // probably safe to use applied time and much faster\n    // for( var i = 0; i < $$.style.properties.length; i++ ){\n    //   var prop = $$.style.properties[i];\n    //   var eleProp = _p.style[ prop.name ];\n    //   var val = eleProp && eleProp.strValue ? eleProp.strValue : 'undefined';\n\n    //   _p.styleKey += '$' + val;\n    // }\n  };\n\n  // apply a property to the style (for internal use)\n  // returns whether application was successful\n  //\n  // now, this function flattens the property, and here's how:\n  //\n  // for parsedProp:{ bypass: true, deleteBypass: true }\n  // no property is generated, instead the bypass property in the\n  // element's style is replaced by what's pointed to by the `bypassed`\n  // field in the bypass property (i.e. restoring the property the\n  // bypass was overriding)\n  //\n  // for parsedProp:{ mapped: truthy }\n  // the generated flattenedProp:{ mapping: prop }\n  // \n  // for parsedProp:{ bypass: true }\n  // the generated flattenedProp:{ bypassed: parsedProp } \n  $$.styfn.applyParsedProperty = function( ele, parsedProp ){\n    var prop = parsedProp;\n    var style = ele._private.style;\n    var fieldVal, flatProp;\n    var type = $$.style.properties[ prop.name ].type;\n    var propIsBypass = prop.bypass;\n    var origProp = style[ prop.name ];\n    var origPropIsBypass = origProp && origProp.bypass;\n\n    // can't apply auto to width or height unless it's a parent node\n    if( (parsedProp.name === 'height' || parsedProp.name === 'width') && parsedProp.value === 'auto' && ele.isNode() && !ele.isParent() ){\n      return false;\n    }\n\n    // check if we need to delete the current bypass\n    if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete\n      var currentProp = style[ prop.name ];\n\n      // can only delete if the current prop is a bypass and it points to the property it was overriding\n      if( !currentProp ){\n        return true; // property is already not defined\n      } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original\n        \n        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n        style[ prop.name ] = currentProp.bypassed;\n        return true;\n      \n      } else {\n        return false; // we're unsuccessful deleting the bypass\n      }\n    }\n\n    var printMappingErr = function(){\n      $$.util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');\n    };\n\n    // put the property in the style objects\n    switch( prop.mapped ){ // flatten the property if mapped\n    case $$.style.types.mapData:\n    case $$.style.types.mapLayoutData:\n      \n      var isLayout = prop.mapped === $$.style.types.mapLayoutData;\n\n      // flatten the field (e.g. data.foo.bar)\n      var fields = prop.field.split(\".\");\n      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;\n      for( var i = 0; i < fields.length && fieldVal; i++ ){\n        var field = fields[i];\n        fieldVal = fieldVal[ field ];\n      }\n\n      var percent;\n      if( !$$.is.number(fieldVal) ){ // then keep the mapping but assume 0% for now\n        percent = 0;\n      } else {\n        percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);\n      }\n\n      // make sure to bound percent value\n      if( percent < 0 ){\n        percent = 0;\n      } else if( percent > 1 ){\n        percent = 1;\n      }\n\n      if( type.color ){\n        var r1 = prop.valueMin[0];\n        var r2 = prop.valueMax[0];\n        var g1 = prop.valueMin[1];\n        var g2 = prop.valueMax[1];\n        var b1 = prop.valueMin[2];\n        var b2 = prop.valueMax[2];\n        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n\n        var clr = [\n          Math.round( r1 + (r2 - r1)*percent ),\n          Math.round( g1 + (g2 - g1)*percent ),\n          Math.round( b1 + (b2 - b1)*percent ),\n          Math.round( a1 + (a2 - a1)*percent )\n        ];\n\n        flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing\n          bypass: prop.bypass, // we're a bypass if the mapping property is a bypass\n          name: prop.name,\n          value: clr,\n          strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n        };\n      \n      } else if( type.number ){\n        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n        flatProp = this.parse( prop.name, calcValue, prop.bypass, true );\n      \n      } else {\n        return false; // can only map to colours and numbers\n      }\n\n      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n        flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );\n      } \n\n      if( !flatProp ){ printMappingErr(); }\n      flatProp.mapping = prop; // keep a reference to the mapping\n      prop = flatProp; // the flattened (mapped) property is the one we want\n\n      break;\n\n    // direct mapping  \n    case $$.style.types.data: \n    case $$.style.types.layoutData: \n\n      var isLayout = prop.mapped === $$.style.types.layoutData;\n\n      // flatten the field (e.g. data.foo.bar)\n      var fields = prop.field.split(\".\");\n      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;\n      for( var i = 0; i < fields.length && fieldVal; i++ ){\n        var field = fields[i];\n        fieldVal = fieldVal[ field ];\n      }\n\n      flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );\n\n      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n        var flatPropVal = origProp ? origProp.strValue : '';\n\n        flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );\n      }\n\n      if( !flatProp ){ printMappingErr(); }\n      flatProp.mapping = prop; // keep a reference to the mapping\n      prop = flatProp; // the flattened (mapped) property is the one we want\n      break;\n\n    case undefined:\n      break; // just set the property\n\n    default: \n      return false; // not a valid mapping\n    }\n\n    // if the property is a bypass property, then link the resultant property to the original one\n    if( propIsBypass ){\n      if( origPropIsBypass ){ // then this bypass overrides the existing one\n        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n      } else { // then link the orig prop to the new bypass\n        prop.bypassed = origProp;\n      }\n\n      style[ prop.name ] = prop; // and set\n    \n    } else { // prop is not bypass\n      if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop\n        origProp.bypassed = prop;\n      } else { // then just replace the old prop with the new one\n        style[ prop.name ] = prop; \n      }\n    }\n\n    return true;\n  };\n\n  // updates the visual style for all elements (useful for manual style modification after init)\n  $$.styfn.update = function(){\n    var cy = this._private.cy;\n    var eles = cy.elements();\n\n    eles.updateStyle();\n  };\n\n  // just update the functional properties (i.e. mappings) in the elements'\n  // styles (less expensive than recalculation)\n  $$.styfn.updateMappers = function( eles ){\n    for( var i = 0; i < eles.length; i++ ){ // for each ele\n      var ele = eles[i];\n      var style = ele._private.style;\n\n      for( var j = 0; j < $$.style.properties.length; j++ ){ // for each prop\n        var prop = $$.style.properties[j];\n        var propInStyle = style[ prop.name ];\n\n        if( propInStyle && propInStyle.mapping ){\n          var mapping = propInStyle.mapping;\n          this.applyParsedProperty( ele, mapping ); // reapply the mapping property\n        }\n      }\n\n      this.updateStyleHints( ele );\n    }\n  };\n\n  // diffProps : { name => { prev, next } }\n  $$.styfn.updateTransitions = function( ele, diffProps, isBypass ){\n    var self = this;\n    var style = ele._private.style;\n\n    var props = style['transition-property'].value;\n    var duration = style['transition-duration'].msValue;\n    var delay = style['transition-delay'].msValue;\n    var css = {};\n\n    if( props.length > 0 && duration > 0 ){\n\n      // build up the style to animate towards\n      var anyPrev = false;\n      for( var i = 0; i < props.length; i++ ){\n        var prop = props[i];\n        var styProp = style[ prop ];\n        var diffProp = diffProps[ prop ];\n\n        if( !diffProp ){ continue; }\n\n        var prevProp = diffProp.prev;\n        var fromProp = prevProp;\n        var toProp = diffProp.next != null ? diffProp.next : styProp;\n        var diff = false;\n\n        if( !fromProp ){ continue; } \n\n        // consider px values\n        if( $$.is.number( fromProp.pxValue ) && $$.is.number( toProp.pxValue ) ){\n          diff = fromProp.pxValue !== toProp.pxValue;\n\n        // consider numerical values\n        } else if( $$.is.number( fromProp.value ) && $$.is.number( toProp.value ) ){\n          diff = fromProp.value !== toProp.value;\n\n        // consider colour values\n        } else if( $$.is.array( fromProp.value ) && $$.is.array( toProp.value ) ){\n          diff = fromProp.value[0] !== toProp.value[0]\n            || fromProp.value[1] !== toProp.value[1]\n            || fromProp.value[2] !== toProp.value[2]\n          ;\n        }\n\n        // the previous value is good for an animation only if it's different\n        if( diff ){\n          css[ prop ] = toProp.strValue; // to val\n          this.applyBypass(ele, prop, fromProp.strValue); // from val\n          anyPrev = true;\n        }\n        \n      } // end if props allow ani\n\n      // can't transition if there's nothing previous to transition from\n      if( !anyPrev ){ return; }\n      \n      ele._private.transitioning = true;\n\n      ele.stop();\n\n      if( delay > 0 ){\n        ele.delay( delay );\n      }\n\n      ele.animate({\n        css: css\n      }, {\n        duration: duration,\n        queue: false,\n        complete: function(){ \n          if( !isBypass ){\n            self.removeBypasses( ele, props );\n          }\n\n          ele._private.transitioning = false;\n        }\n      });\n\n    } else if( ele._private.transitioning ){\n      ele.stop();\n\n      this.removeBypasses( ele, props );\n\n      ele._private.transitioning = false;\n    }\n  }; \n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  // bypasses are applied to an existing style on an element, and just tacked on temporarily\n  // returns true iff application was successful for at least 1 specified property\n  $$.styfn.applyBypass = function( eles, name, value, updateTransitions ){\n    var props = [];\n    var isBypass = true;\n    \n    // put all the properties (can specify one or many) in an array after parsing them\n    if( name === \"*\" || name === \"**\" ){ // apply to all property names\n\n      if( value !== undefined ){\n        for( var i = 0; i < $$.style.properties.length; i++ ){\n          var prop = $$.style.properties[i];\n          var name = prop.name;\n\n          var parsedProp = this.parse(name, value, true);\n          \n          if( parsedProp ){\n            props.push( parsedProp );\n          }\n        }\n      }\n\n    } else if( $$.is.string(name) ){ // then parse the single property\n      var parsedProp = this.parse(name, value, true);\n\n      if( parsedProp ){\n        props.push( parsedProp );\n      }\n    } else if( $$.is.plainObject(name) ){ // then parse each property\n      var specifiedProps = name;\n      updateTransitions = value;\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var name = prop.name;\n        var value = specifiedProps[ name ];\n\n        if( value === undefined ){ // try camel case name too\n          value = specifiedProps[ $$.util.dash2camel(name) ];\n        }\n\n        if( value !== undefined ){\n          var parsedProp = this.parse(name, value, true);\n          \n          if( parsedProp ){\n            props.push( parsedProp );\n          }\n        }\n      }\n    } else { // can't do anything without well defined properties\n      return false;\n    }\n\n    // we've failed if there are no valid properties\n    if( props.length === 0 ){ return false; }\n\n    // now, apply the bypass properties on the elements\n    var ret = false; // return true if at least one succesful bypass applied\n    for( var i = 0; i < eles.length; i++ ){ // for each ele\n      var ele = eles[i];\n      var style = ele._private.style;\n      var diffProps = {};\n      var diffProp;\n\n      for( var j = 0; j < props.length; j++ ){ // for each prop\n        var prop = props[j];\n\n        if( updateTransitions ){\n          var prevProp = style[ prop.name ];\n          diffProp = diffProps[ prop.name ] = { prev: prevProp };\n        }\n\n        ret = this.applyParsedProperty( ele, prop ) || ret;\n\n        if( updateTransitions ){\n          diffProp.next = style[ prop.name ];\n        }\n\n      } // for props\n\n      if( updateTransitions ){\n        this.updateTransitions( ele, diffProps, isBypass );\n      }\n    } // for eles\n\n    return ret;\n  };\n\n  // only useful in specific cases like animation\n  $$.styfn.overrideBypass = function( eles, name, value ){\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[i];\n      var prop = ele._private.style[ $$.util.camel2dash(name) ];\n\n      if( !prop.bypass ){ // need a bypass if one doesn't exist\n        this.applyBypass( ele, name, value );\n        continue;\n      }\n\n      prop.value = value;\n      prop.pxValue = value;\n    }\n  };\n\n  $$.styfn.removeAllBypasses = function( eles, updateTransitions ){\n    var isBypass = true;\n\n    for( var j = 0; j < eles.length; j++ ){\n      var ele = eles[j];\n      var diffProps = {};\n      var style = ele._private.style;\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var name = prop.name;\n        var value = ''; // empty => remove bypass\n        var parsedProp = this.parse(name, value, true);\n        var prevProp = style[ prop.name ];\n        var diffProp = diffProps[ prop.name ] = { prev: prevProp };\n\n        this.applyParsedProperty(ele, parsedProp);\n\n        diffProp.next = style[ prop.name ];\n      } // for props\n\n      if( updateTransitions ){\n        this.updateTransitions( ele, diffProps, isBypass );\n      }\n    } // for eles\n  };\n\n  $$.styfn.removeBypasses = function( eles, props, updateTransitions ){\n    var isBypass = true;\n\n    for( var j = 0; j < eles.length; j++ ){\n      var ele = eles[j];\n      var diffProps = {};\n      var style = ele._private.style;\n\n      for( var i = 0; i < props.length; i++ ){\n        var name = props[i];\n        var prop = $$.style.properties[ name ];\n        var value = ''; // empty => remove bypass\n        var parsedProp = this.parse(name, value, true);\n        var prevProp = style[ prop.name ];\n        var diffProp = diffProps[ prop.name ] = { prev: prevProp };\n\n        this.applyParsedProperty(ele, parsedProp);\n\n        diffProp.next = style[ prop.name ];\n      } // for props\n\n      if( updateTransitions ){\n        this.updateTransitions( ele, diffProps, isBypass );\n      }\n    } // for eles\n  };\n\n})( cytoscape );\n;(function($$, window){ 'use strict';\n\n  // gets what an em size corresponds to in pixels relative to a dom element\n  $$.styfn.getEmSizeInPixels = function(){\n    var cy = this._private.cy;\n    var domElement = cy.container();\n\n    if( window && domElement && window.getComputedStyle ){\n      var pxAsStr = window.getComputedStyle(domElement).getPropertyValue('font-size');\n      var px = parseFloat( pxAsStr );\n      return px;\n    } else {\n      return 1; // in case we're running outside of the browser\n    }\n  };\n\n  // gets css property from the core container\n  $$.styfn.containerCss = function( propName ){\n    var cy = this._private.cy;\n    var domElement = cy.container();\n\n    if( window && domElement && window.getComputedStyle ){\n      return window.getComputedStyle(domElement).getPropertyValue( propName );\n    }\n  };\n\n  $$.styfn.containerProperty = function( propName ){\n    var propStr = this.containerCss( propName );\n    var prop = this.parse( propName, propStr );\n    return prop;\n  };\n\n  $$.styfn.containerPropertyAsString = function( propName ){\n    var prop = this.containerProperty( propName );\n\n    if( prop ){\n      return prop.strValue;\n    }\n  };\n\n})( cytoscape, typeof window === 'undefined' ? null : window );\n;(function($$){ 'use strict';\n\n  // gets the rendered style for an element\n  $$.styfn.getRenderedStyle = function( ele ){\n    var ele = ele[0]; // insure it's an element\n\n    if( ele ){\n      var rstyle = {};\n      var style = ele._private.style;\n      var cy = this._private.cy;\n      var zoom = cy.zoom();\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var styleProp = style[ prop.name ];\n\n        if( styleProp ){\n          var val = styleProp.unitless ? styleProp.strValue : (styleProp.pxValue * zoom) + 'px';\n          rstyle[ prop.name ] = val;\n          rstyle[ $$.util.dash2camel(prop.name) ] = val;\n        }\n      }\n\n      return rstyle;\n    }\n  };\n\n  // gets the raw style for an element\n  $$.styfn.getRawStyle = function( ele ){\n    var ele = ele[0]; // insure it's an element\n\n    if( ele ){\n      var rstyle = {};\n      var style = ele._private.style;\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var styleProp = style[ prop.name ];\n\n        if( styleProp ){\n          rstyle[ prop.name ] = styleProp.strValue;\n          rstyle[ $$.util.dash2camel(prop.name) ] = styleProp.strValue;\n        }\n      }\n\n      return rstyle;\n    }\n  };\n\n  // gets the value style for an element (useful for things like animations)\n  $$.styfn.getValueStyle = function( ele, opts ){\n    opts = opts || {};\n\n    var rstyle = opts.array ? [] : {}; \n    var style;\n\n    if( $$.is.element(ele) ){\n      style = ele._private.style;    \n    } else {\n      style = ele; // just passed the style itself\n    }\n\n    if( style ){\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var styleProp = style[ prop.name ] || style[ $$.util.dash2camel(prop.name) ];\n\n        if( styleProp !== undefined && !$$.is.plainObject( styleProp ) ){ // then make a prop of it\n          styleProp = this.parse(prop.name, styleProp);\n        }\n\n        if( styleProp ){\n          if( opts.array ){\n            rstyle.push( styleProp );\n          } else {\n            rstyle[ prop.name ] = styleProp;\n            rstyle[ $$.util.dash2camel(prop.name) ] = styleProp;\n          }\n        }\n      }\n    }\n\n    return rstyle;\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  $$.style.applyFromJson = function( style, json ){\n    for( var i = 0; i < json.length; i++ ){\n      var context = json[i];\n      var selector = context.selector;\n      var props = context.css;\n\n      style.selector(selector); // apply selector\n\n      for( var name in props ){\n        var value = props[name];\n\n        style.css( name, value ); // apply property\n      }\n    }\n\n    return style;\n  };\n\n  // static function\n  $$.style.fromJson = function( cy, json ){\n    var style = new $$.Style(cy);\n\n    $$.style.applyFromJson( style, json );\n\n    return style;\n  };\n\n  // accessible cy.style() function\n  $$.styfn.fromJson = function( json ){\n    var style = this;\n\n    style.resetToDefault();\n\n    $$.style.applyFromJson( style, json );\n\n    return style;\n  };\n\n  // get json from cy.style() api\n  $$.styfn.json = function(){\n    var json = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var cxt = this[i];\n      var selector = cxt.selector;\n      var props = cxt.properties;\n      var css = {};\n\n      for( var j = 0; j < props.length; j++ ){\n        var prop = props[j];\n        css[ prop.name ] = prop.strValue;\n      }\n\n      json.push({\n        selector: !selector ? 'core' : selector.toString(),\n        css: css\n      });\n    }\n\n    return json;\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  $$.style.applyFromString = function( style, string ){\n    var remaining = '' + string;\n    var selAndBlockStr;\n    var blockRem;\n    var propAndValStr;\n\n    // remove comments from the style string\n    remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\n    function removeSelAndBlockFromRemaining(){\n      // remove the parsed selector and block from the remaining text to parse\n      if( remaining.length > selAndBlockStr.length ){\n        remaining = remaining.substr( selAndBlockStr.length );\n      } else {\n        remaining = '';\n      }\n    }\n\n    function removePropAndValFromRem(){\n      // remove the parsed property and value from the remaining block text to parse\n      if( blockRem.length > propAndValStr.length ){\n        blockRem = blockRem.substr( propAndValStr.length );\n      } else {\n        blockRem = '';\n      }\n    }\n\n    while(true){\n      var nothingLeftToParse = remaining.match(/^\\s*$/);\n      if( nothingLeftToParse ){ break; }\n\n      var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\n      if( !selAndBlock ){\n        $$.util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n        break;\n      }\n\n      selAndBlockStr = selAndBlock[0];\n\n      // parse the selector\n      var selectorStr = selAndBlock[1];\n      var selector = new $$.Selector( selectorStr );\n      if( selector._private.invalid && selectorStr !== 'core' ){\n        $$.util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);\n\n        // skip this selector and block\n        removeSelAndBlockFromRemaining();\n        continue; \n      }\n\n      // parse the block of properties and values\n      var blockStr = selAndBlock[2];\n      var invalidBlock = false;\n      blockRem = blockStr;\n      var props = [];\n\n      while(true){\n        var nothingLeftToParse = blockRem.match(/^\\s*$/);\n        if( nothingLeftToParse ){ break; }\n\n        var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/);\n\n        if( !propAndVal ){\n          $$.util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n          invalidBlock = true;\n          break;\n        }\n\n        propAndValStr = propAndVal[0];\n        var propStr = propAndVal[1];\n        var valStr = propAndVal[2];\n\n        var prop = $$.style.properties[ propStr ];\n        if( !prop ){\n          $$.util.error('Skipping property: Invalid property name in: ' + propAndValStr);\n\n          // skip this property in the block\n          removePropAndValFromRem();\n          continue;\n        }\n\n        var parsedProp = style.parse( propStr, valStr );\n\n        if( !parsedProp ){\n          $$.util.error('Skipping property: Invalid property definition in: ' + propAndValStr);\n\n          // skip this property in the block\n          removePropAndValFromRem();\n          continue;\n        }\n\n        props.push({\n          name: propStr,\n          val: valStr\n        });\n        removePropAndValFromRem();\n      }\n\n      if( invalidBlock ){\n        removeSelAndBlockFromRemaining();\n        break;\n      }\n\n      // put the parsed block in the style\n      style.selector( selectorStr );\n      for( var i = 0; i < props.length; i++ ){\n        var prop = props[i];\n        style.css( prop.name, prop.val );\n      }\n\n      removeSelAndBlockFromRemaining();\n    }\n\n    return style;\n  };\n\n  $$.style.fromString = function( cy, string ){\n    var style = new $$.Style(cy);\n    \n    $$.style.applyFromString( style, string );\n\n    return style;\n  };\n\n  $$.styfn.fromString = function( string ){\n    var style = this;\n\n    style.resetToDefault();\n\n    $$.style.applyFromString( style, string );\n\n    return style;\n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // a dummy stylesheet object that doesn't need a reference to the core\n  // (useful for init)\n  $$.stylesheet = $$.Stylesheet = function(){\n    if( !(this instanceof $$.Stylesheet) ){\n      return new $$.Stylesheet();\n    }\n\n    this.length = 0;\n  };\n\n  // just store the selector to be parsed later\n  $$.Stylesheet.prototype.selector = function( selector ){\n    var i = this.length++;\n\n    this[i] = {\n      selector: selector,\n      properties: []\n    };\n\n    return this; // chaining\n  };\n\n  // just store the property to be parsed later\n  $$.Stylesheet.prototype.css = function( name, value ){\n    var i = this.length - 1;\n\n    if( $$.is.string(name) ){\n      this[i].properties.push({\n        name: name,\n        value: value\n      });\n    } else if( $$.is.plainObject(name) ){\n      var map = name;\n\n      for( var j = 0; j < $$.style.properties.length; j++ ){\n        var prop = $$.style.properties[j];\n        var mapVal = map[ prop.name ];\n\n        if( mapVal === undefined ){ // also try camel case name\n          mapVal = map[ $$.util.dash2camel(prop.name) ];\n        }\n\n        if( mapVal !== undefined ){\n          var name = prop.name;\n          var value = mapVal;\n\n          this[i].properties.push({\n            name: name,\n            value: value\n          });\n        }\n      }\n    }\n\n    return this; // chaining\n  };\n\n  // generate a real style object from the dummy stylesheet\n  $$.Stylesheet.prototype.generateStyle = function( cy ){\n    var style = new $$.Style(cy);\n\n    for( var i = 0; i < this.length; i++ ){\n      var context = this[i];\n      var selector = context.selector;\n      var props = context.properties;\n\n      style.selector(selector); // apply selector\n\n      for( var j = 0; j < props.length; j++ ){\n        var prop = props[j];\n\n        style.css( prop.name, prop.value ); // apply property\n      }\n    }\n\n    return style;\n  };\n\n})( cytoscape );\n;(function($$, window){ 'use strict';\n\n  var isTouch = $$.is.touch();\n\n  var defaults = {\n  };\n  \n  var origDefaults = $$.util.copy( defaults );\n\n  $$.defaults = function( opts ){\n    defaults = $$.util.extend({}, origDefaults, opts);\n  };\n\n  $$.fn.core = function( fnMap, options ){\n    for( var name in fnMap ){\n      var fn = fnMap[name];\n      $$.Core.prototype[ name ] = fn;\n    }\n  };\n  \n  $$.Core = function( opts ){\n    if( !(this instanceof $$.Core) ){\n      return new $$.Core(opts);\n    }\n    var cy = this;\n\n    opts = $$.util.extend({}, defaults, opts);\n\n    var container = opts.container;\n    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n    reg = reg || {};\n\n    if( reg && reg.cy ){ \n      if( container ){\n        while( container.firstChild ){ // clean the container\n          container.removeChild( container.firstChild );\n        }\n      }\n      \n      reg.cy.notify({ type: 'destroy' }); // destroy the renderer\n\n      reg = {}; // old instance => replace reg completely\n    }\n\n    var readies = reg.readies = reg.readies || [];\n    \n    if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy\n    reg.cy = cy;\n\n    var head = window !== undefined && container !== undefined && !opts.headless;\n    var options = opts;\n    options.layout = $$.util.extend( { name: head ? 'grid' : 'null' }, options.layout );\n    options.renderer = $$.util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );\n    \n    var defVal = function( def, val, altVal ){\n      if( val !== undefined ){\n        return val;\n      } else if( altVal !== undefined ){\n        return altVal;\n      } else {\n        return def;\n      }\n    };\n\n    var _p = this._private = {\n      container: options.container, // html dom ele container\n      ready: false, // whether ready has been triggered\n      initrender: false, // has initrender has been triggered\n      options: options, // cached options\n      elements: [], // array of elements\n      id2index: {}, // element id => index in elements array\n      listeners: [], // list of listeners\n      aniEles: $$.Collection(this), // elements being animated\n      scratch: {}, // scratch object for core\n      layout: null,\n      renderer: null,\n      notificationsEnabled: true, // whether notifications are sent to the renderer\n      minZoom: 1e-50,\n      maxZoom: 1e50,\n      zoomingEnabled: defVal(true, options.zoomingEnabled),\n      userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n      panningEnabled: defVal(true, options.panningEnabled),\n      userPanningEnabled: defVal(true, options.userPanningEnabled),\n      boxSelectionEnabled: defVal(false, options.boxSelectionEnabled),\n      autolock: defVal(false, options.autolock, options.autolockNodes),\n      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n      autounselectify: defVal(false, options.autounselectify),\n      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n      zoom: $$.is.number(options.zoom) ? options.zoom : 1,\n      pan: {\n        x: $$.is.plainObject(options.pan) && $$.is.number(options.pan.x) ? options.pan.x : 0,\n        y: $$.is.plainObject(options.pan) && $$.is.number(options.pan.y) ? options.pan.y : 0\n      },\n      animation: { // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      hasCompoundNodes: false,\n      deferredExecQueue: []\n    };\n\n    // set selection type\n    var selType = options.selectionType;\n    if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){\n      // then set default\n\n      if( isTouch ){\n        _p.selectionType = 'additive';\n      } else {\n        _p.selectionType = 'single';\n      }\n    } else {\n      _p.selectionType = selType;\n    }\n\n    // init zoom bounds\n    if( $$.is.number(options.minZoom) && $$.is.number(options.maxZoom) && options.minZoom < options.maxZoom ){\n      _p.minZoom = options.minZoom;\n      _p.maxZoom = options.maxZoom;\n    } else if( $$.is.number(options.minZoom) && options.maxZoom === undefined ){\n      _p.minZoom = options.minZoom;\n    } else if( $$.is.number(options.maxZoom) && options.minZoom === undefined ){\n      _p.maxZoom = options.maxZoom;\n    }\n\n    // init style\n    if( _p.styleEnabled ){\n      this.setStyle( options.style );\n    }\n\n    // create the renderer\n    cy.initRenderer( $$.util.extend({\n      hideEdgesOnViewport: options.hideEdgesOnViewport,\n      hideLabelsOnViewport: options.hideLabelsOnViewport,\n      textureOnViewport: options.textureOnViewport,\n      wheelSensitivity: $$.is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,\n      motionBlur: options.motionBlur,\n      pixelRatio: $$.is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : (options.pixelRatio === 'auto' ? undefined : 1),\n      tapThreshold: defVal( $$.is.touch() ? 8 : 4, $$.is.touch() ? options.touchTapThreshold : options.desktopTapThreshold )\n    }, options.renderer) );\n\n    // trigger the passed function for the `initrender` event\n    if( options.initrender ){\n      cy.on('initrender', options.initrender);\n      cy.on('initrender', function(){\n        cy._private.initrender = true;\n      });\n    }\n\n    // initial load\n    cy.load(options.elements, function(){ // onready\n      cy.startAnimationLoop();\n      cy._private.ready = true;\n\n      // if a ready callback is specified as an option, the bind it\n      if( $$.is.fn( options.ready ) ){\n        cy.on('ready', options.ready);\n      }\n\n      // bind all the ready handlers registered before creating this instance\n      for( var i = 0; i < readies.length; i++ ){\n        var fn = readies[i];\n        cy.on('ready', fn);\n      }\n      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n      \n      cy.trigger('ready');\n    }, options.done);\n  };\n\n  $$.corefn = $$.Core.prototype; // short alias\n  \n\n  $$.fn.core({\n    isReady: function(){\n      return this._private.ready;\n    },\n\n    ready: function( fn ){\n      if( this.isReady() ){\n        this.trigger('ready', [], fn); // just calls fn as though triggered via ready event\n      } else {\n        this.on('ready', fn);\n      }\n    },\n\n    initrender: function(){\n      return this._private.initrender;\n    },\n\n    destroy: function(){\n      this.notify({ type: 'destroy' }); // destroy the renderer\n\n      var domEle = this.container();\n      var parEle = domEle.parentNode;\n      if( parEle ){\n        parEle.removeChild( domEle );\n      }\n\n      return this;\n    },\n\n    getElementById: function( id ){\n      var index = this._private.id2index[ id ];\n      if( index !== undefined ){\n        return this._private.elements[ index ];\n      }\n\n      // worst case, return an empty collection\n      return new $$.Collection( this );\n    },\n\n    selectionType: function(){\n      return this._private.selectionType;\n    },\n\n    hasCompoundNodes: function(){\n      return this._private.hasCompoundNodes;\n    },\n\n    styleEnabled: function(){\n      return this._private.styleEnabled;\n    },\n\n    addToPool: function( eles ){\n      var elements = this._private.elements;\n      var id2index = this._private.id2index;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n\n        var id = ele._private.data.id;\n        var index = id2index[ id ];\n        var alreadyInPool = index !== undefined;\n\n        if( !alreadyInPool ){\n          index = elements.length;\n          elements.push( ele );\n          id2index[ id ] = index;\n          ele._private.index = index;\n        }\n      }\n\n      return this; // chaining\n    },\n\n    removeFromPool: function( eles ){\n      var elements = this._private.elements;\n      var id2index = this._private.id2index;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n\n        var id = ele._private.data.id;\n        var index = id2index[ id ];\n        var inPool = index !== undefined;\n\n        if( inPool ){\n          this._private.id2index[ id ] = undefined;\n          elements.splice(index, 1);\n\n          // adjust the index of all elements past this index\n          for( var j = index; j < elements.length; j++ ){\n            var jid = elements[j]._private.data.id;\n            id2index[ jid ]--;\n          }\n        }\n      }\n    },\n\n    container: function(){\n      return this._private.container;\n    },\n\n    options: function(){\n      return $$.util.copy( this._private.options );\n    },\n    \n    json: function(params){\n      var json = {};\n      var cy = this;\n      \n      json.elements = {};\n      cy.elements().each(function(i, ele){\n        var group = ele.group();\n        \n        if( !json.elements[group] ){\n          json.elements[group] = [];\n        }\n        \n        json.elements[group].push( ele.json() );\n      });\n\n      if( this._private.styleEnabled ){\n        json.style = cy.style().json();\n      }\n\n      json.zoomingEnabled = cy._private.zoomingEnabled;\n      json.userZoomingEnabled = cy._private.userZoomingEnabled;\n      json.zoom = cy._private.zoom;\n      json.minZoom = cy._private.minZoom;\n      json.maxZoom = cy._private.maxZoom;\n      json.panningEnabled = cy._private.panningEnabled;\n      json.userPanningEnabled = cy._private.userPanningEnabled;\n      json.pan = cy._private.pan;\n      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;\n      json.layout = cy._private.options.layout;\n      json.renderer = cy._private.options.renderer;\n      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;\n      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;\n      json.textureOnViewport = cy._private.options.textureOnViewport;\n      json.wheelSensitivity = cy._private.options.wheelSensitivity;\n      json.motionBlur = cy._private.options.motionBlur;\n      \n      return json;\n    },\n\n    // defer execution until not busy and guarantee relative execution order of deferred functions\n    defer: function( fn ){\n      var cy = this;\n      var _p = cy._private;\n      var q = _p.deferredExecQueue;\n\n      q.push( fn );\n\n      if( !_p.deferredTimeout ){\n        _p.deferredTimeout = setTimeout(function(){\n          while( q.length > 0 ){\n            ( q.shift() )();\n          }\n\n          _p.deferredTimeout = null;\n        }, 0);\n      }\n    }\n    \n  });  \n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n(function($$, window){ 'use strict';\n\n  function ready(f) {\n    var fn = ( document && (document.readyState === 'interactive' || document.readyState === 'complete') )  ? f : ready;\n\n    setTimeout(fn, 9, f);\n  }\n\n  $$.fn.core({\n    add: function(opts){\n      \n      var elements;\n      var cy = this;\n      \n      // add the elements\n      if( $$.is.elementOrCollection(opts) ){\n        var eles = opts;\n\n        if( eles._private.cy === cy ){ // same instance => just restore\n          elements = eles.restore();\n\n        } else { // otherwise, copy from json\n          var jsons = [];\n\n          for( var i = 0; i < eles.length; i++ ){\n            var ele = eles[i];\n            jsons.push( ele.json() );\n          }\n\n          elements = new $$.Collection( cy, jsons );\n        }\n      }\n      \n      // specify an array of options\n      else if( $$.is.array(opts) ){\n        var jsons = opts;\n\n        elements = new $$.Collection(cy, jsons);\n      }\n      \n      // specify via opts.nodes and opts.edges\n      else if( $$.is.plainObject(opts) && ($$.is.array(opts.nodes) || $$.is.array(opts.edges)) ){\n        var elesByGroup = opts;\n        var jsons = [];\n\n        var grs = ['nodes', 'edges'];\n        for( var i = 0, il = grs.length; i < il; i++ ){\n          var group = grs[i];\n          var elesArray = elesByGroup[group];\n\n          if( $$.is.array(elesArray) ){\n\n            for( var j = 0, jl = elesArray.length; j < jl; j++ ){\n              var json = elesArray[j];\n              json.group = group;\n\n              jsons.push( json );\n            }\n          } \n        }\n\n        elements = new $$.Collection(cy, jsons);\n      }\n      \n      // specify options for one element\n      else {\n        var json = opts;\n        elements = (new $$.Element( cy, json )).collection();\n      }\n      \n      return elements;\n    },\n    \n    remove: function(collection){\n      if( $$.is.elementOrCollection(collection) ){\n        collection = collection;\n      } else if( $$.is.string(collection) ){\n        var selector = collection;\n        collection = this.$( selector );\n      }\n      \n      return collection.remove();\n    },\n    \n    load: function(elements, onload, ondone){\n      var cy = this;\n      \n      // remove old elements\n      var oldEles = cy.elements();\n      if( oldEles.length > 0 ){\n        oldEles.remove();\n      }\n\n      cy.notifications(false);\n      \n      if( elements != null ){\n        if( $$.is.plainObject(elements) || $$.is.array(elements) ){\n          cy.add( elements );\n        } \n      }\n      \n      function callback(){        \n        cy.one('layoutready', function(e){\n          cy.notifications(true);\n          cy.trigger(e); // we missed this event by turning notifications off, so pass it on\n\n          cy.notify({\n            type: 'load',\n            collection: cy.elements()\n          });\n\n          cy.one('load', onload);\n          cy.trigger('load');\n        }).one('layoutstop', function(){\n          cy.one('done', ondone);\n          cy.trigger('done');\n        });\n        \n        var layoutOpts = $$.util.extend({}, cy._private.options.layout);\n        layoutOpts.eles = cy.$();\n\n        cy.layout( layoutOpts );\n\n      }\n\n      if( window ){\n        ready( callback );\n      } else {\n        callback();\n      }\n\n      return this;\n    }\n  });\n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n;(function($$, window){ 'use strict';\n  \n  $$.fn.core({\n    \n    // pull in animation functions\n    animated: $$.define.animated(),\n    clearQueue: $$.define.clearQueue(),\n    delay: $$.define.delay(),\n    animate: $$.define.animate(),\n    stop: $$.define.stop(),\n\n    addToAnimationPool: function( eles ){\n      var cy = this;\n\n      if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n      \n      cy._private.aniEles.merge( eles );\n    },\n\n    startAnimationLoop: function(){\n      var cy = this;\n\n      if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n\n      // don't execute the animation loop in headless environments\n      if( !window ){\n        return;\n      }\n      \n      function globalAnimationStep(){\n        $$.util.requestAnimationFrame(function(now){\n          handleElements(now);\n          globalAnimationStep();\n        });\n      }\n      \n      globalAnimationStep(); // first call\n      \n      function handleElements(now){\n        now = +new Date();\n\n        var eles = cy._private.aniEles;\n        var doneEles = [];\n\n        function handleElement( ele, isCore ){\n          var current = ele._private.animation.current;\n          var queue = ele._private.animation.queue;\n          var ranAnis = false;\n          \n          // if nothing currently animating, get something from the queue\n          if( current.length === 0 ){\n            var next = queue.length > 0 ? queue.shift() : null;\n            \n            if( next ){\n              next.callTime = now; // was queued, so update call time\n              current.push( next );\n            }\n          }\n          \n          // step and remove if done\n          var completes = [];\n          for(var i = current.length - 1; i >= 0; i--){\n            var ani = current[i];\n\n            // start if need be\n            if( !ani.started ){ startAnimation( ele, ani ); }\n            \n            step( ele, ani, now, isCore );\n\n            if( ani.done ){\n              completes.push( ani );\n              \n              // remove current[i]\n              current.splice(i, 1);\n            }\n\n            ranAnis = true;\n          }\n          \n          // call complete callbacks\n          for( var i = 0; i < completes.length; i++ ){\n            var ani = completes[i];\n            var complete = ani.params.complete;\n\n            if( $$.is.fn(complete) ){\n              complete.apply( ele, [ now ] );\n            }\n          }\n\n          if( !isCore && current.length === 0 && queue.length === 0 ){\n            doneEles.push( ele );\n          }\n\n          return ranAnis;\n        } // handleElements\n\n        // handle all eles\n        for( var e = 0; e < eles.length; e++ ){\n          var ele = eles[e];\n          \n          handleElement( ele );\n        } // each element\n\n        var ranCoreAni = handleElement( cy, true );\n        \n        // notify renderer\n        if( eles.length > 0 || ranCoreAni ){\n          var toNotify;\n\n          if( eles.length > 0 ){\n            var updatedEles = eles.updateCompoundBounds();\n            toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;\n          }\n\n          cy.notify({\n            type: 'draw',\n            collection: toNotify\n          });\n        }\n\n        // remove elements from list of currently animating if its queues are empty\n        eles.unmerge( doneEles );\n\n      } // handleElements\n      \n      function startAnimation( self, ani ){\n        var isCore = $$.is.core( self );\n        var isEles = !isCore;\n        var ele = self;\n        var style = cy._private.style;\n\n        if( isEles ){\n          var pos = ele._private.position;\n          var startPosition = {\n            x: pos.x,\n            y: pos.y\n          };\n          var startStyle = style.getValueStyle( ele );\n        }\n\n        if( isCore ){\n          var pan = cy._private.pan;\n          var startPan = {\n            x: pan.x,\n            y: pan.y\n          };\n\n          var startZoom = cy._private.zoom;\n        }\n\n        ani.started = true;\n        ani.startTime = Date.now();\n        ani.startPosition = startPosition;\n        ani.startStyle = startStyle;\n        ani.startPan = startPan;\n        ani.startZoom = startZoom;\n      }\n\n      function step( self, animation, now, isCore ){\n        var style = cy._private.style;\n        var properties = animation.properties;\n        var params = animation.params;\n        var startTime = animation.startTime;\n        var percent;\n        var isEles = !isCore;\n        \n        if( animation.duration === 0 ){\n          percent = 1;\n        } else {\n          percent = Math.min(1, (now - startTime)/animation.duration);\n        }\n\n        if( percent < 0 ){\n          percent = 0;\n        } else if( percent > 1 ){\n          percent = 1;\n        }\n        \n        if( properties.delay == null ){ // then update\n\n          var startPos = animation.startPosition;\n          var endPos = properties.position;\n          var pos = self._private.position;\n          if( endPos && isEles ){\n            if( valid( startPos.x, endPos.x ) ){\n              pos.x = ease( startPos.x, endPos.x, percent );\n            }\n\n            if( valid( startPos.y, endPos.y ) ){\n              pos.y = ease( startPos.y, endPos.y, percent );\n            }\n          }\n\n          var startPan = animation.startPan;\n          var endPan = properties.pan;\n          var pan = self._private.pan;\n          var animatingPan = endPan != null && isCore;\n          if( animatingPan ){\n            if( valid( startPan.x, endPan.x ) ){\n              pan.x = ease( startPan.x, endPan.x, percent );\n            }\n\n            if( valid( startPan.y, endPan.y ) ){\n              pan.y = ease( startPan.y, endPan.y, percent );\n            }\n\n            self.trigger('pan');\n          }\n\n          var startZoom = animation.startZoom;\n          var endZoom = properties.zoom;\n          var animatingZoom = endZoom != null && isCore;\n          if( animatingZoom ){\n            if( valid( startZoom, endZoom ) ){\n              self._private.zoom = ease( startZoom, endZoom, percent );\n            }\n\n            self.trigger('zoom');\n          }\n\n          if( animatingPan || animatingZoom ){\n            self.trigger('viewport');\n          }\n\n          if( properties.css && isEles ){\n            var props = properties.css;\n\n            for( var i = 0; i < props.length; i++ ){\n              var name = props[i].name;\n              var prop = props[i];\n              var end = prop;\n\n              var start = animation.startStyle[ name ];\n              var easedVal = ease( start, end, percent );\n              \n              style.overrideBypass( self, name, easedVal );\n            } // for props\n          } // if \n\n        }\n        \n        if( $$.is.fn(params.step) ){\n          params.step.apply( self, [ now ] );\n        }\n        \n        if( percent >= 1 ){\n          animation.done = true;\n        }\n        \n        return percent;\n      }\n      \n      function valid(start, end){\n        if( start == null || end == null ){\n          return false;\n        }\n        \n        if( $$.is.number(start) && $$.is.number(end) ){\n          return true;\n        } else if( (start) && (end) ){\n          return true;\n        }\n        \n        return false;\n      }\n      \n      function ease(startProp, endProp, percent){\n        if( percent < 0 ){\n          percent = 0;\n        } else if( percent > 1 ){\n          percent = 1;\n        }\n\n        var start, end;\n\n        if( startProp.pxValue != null || startProp.value != null ){\n          start = startProp.pxValue != null ? startProp.pxValue : startProp.value;\n        } else {\n          start = startProp;\n        }\n\n        if( endProp.pxValue != null || endProp.value != null ){\n          end = endProp.pxValue != null ? endProp.pxValue : endProp.value;\n        } else {\n          end = endProp;\n        }\n\n        if( $$.is.number(start) && $$.is.number(end) ){\n          return start + (end - start) * percent;\n\n        } else if( $$.is.number(start[0]) && $$.is.number(end[0]) ){ // then assume a colour\n          var c1 = start;\n          var c2 = end;\n\n          var ch = function(ch1, ch2){\n            var diff = ch2 - ch1;\n            var min = ch1;\n            return Math.round( percent * diff + min );\n          };\n          \n          var r = ch( c1[0], c2[0] );\n          var g = ch( c1[1], c2[1] );\n          var b = ch( c1[2], c2[2] );\n          \n          return [r, g, b];\n        }\n        \n        return undefined;\n      }\n      \n    }\n    \n  });\n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n\n  \n    \n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    data: $$.define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true\n    }),\n\n    removeData: $$.define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true\n    }),\n\n    scratch: $$.define.data({\n      field: 'scratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n\n    removeScratch: $$.define.removeData({\n      field: 'scratch',\n      triggerEvent: false\n    })\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.core({\n    on: $$.define.on(), // .on( events [, selector] [, data], handler)\n    one: $$.define.on({ unbindSelfOnTrigger: true }),\n    once: $$.define.on({ unbindAllBindersOnTrigger: true }),\n    off: $$.define.off(), // .off( events [, selector] [, handler] )\n    trigger: $$.define.trigger() // .trigger( events [, extraParams] )\n  });\n\n  // aliases for those folks who like old stuff:\n  $$.corefn.bind = $$.corefn.on;\n  $$.corefn.unbind = $$.corefn.off;\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    png: function( options ){\n      var renderer = this._private.renderer;\n      options = options || {};\n\n      return renderer.png( options );      \n    }\n    \n  });\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    layout: function( params ){\n      var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.initLayout( params ) );\n\n      layout.run();\n\n      return this; // chaining\n    },\n\n    makeLayout: function( params ){\n      return this.initLayout( params );\n    },\n    \n    initLayout: function( options ){\n      if( options == null ){\n        $$.util.error('Layout options must be specified to make a layout');\n        return;\n      }\n      \n      if( options.name == null ){\n        $$.util.error('A `name` must be specified to make a layout');\n        return;\n      }\n      \n      var name = options.name;\n      var LayoutProto = $$.extension('layout', name);\n      \n      if( LayoutProto == null ){\n        $$.util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');\n        return;\n      }\n\n      options.eles = options.eles != null ? options.eles : this.$();\n\n      if( $$.is.string( options.eles ) ){\n        options.eles = this.$( options.eles );\n      }\n      \n      var layout = new LayoutProto( $$.util.extend({}, options, {\n        cy: this\n      }) );\n\n      // make sure layout has _private for use w/ std apis like .on()\n      if( !$$.is.plainObject(layout._private) ){\n        layout._private = {};\n      }\n\n      layout._private.cy = this;\n      layout._private.listeners = [];\n      \n      return layout;\n    }\n    \n  });\n  \n})( cytoscape );\n(function($$){ 'use strict';\n  \n  $$.fn.core({\n    notify: function( params ){\n      if( this._private.batchingNotify ){\n        var bEles = this._private.batchNotifyEles;\n        var bTypes = this._private.batchNotifyTypes;\n\n        if( params.collection ){ for( var i = 0; i < params.collection.length; i++ ){\n          var ele = params.collection[i];\n\n          if( !bEles.ids[ ele._private.id ] ){\n            bEles.push( ele );\n          }\n        } }\n\n        if( !bTypes.ids[ params.type ] ){\n          bTypes.push( params.type );\n        }\n\n        return; // notifications are disabled during batching\n      }\n\n      if( !this._private.notificationsEnabled ){ return; } // exit on disabled\n\n      var renderer = this.renderer();\n      \n      renderer.notify(params);\n    },\n    \n    notifications: function( bool ){\n      var p = this._private;\n      \n      if( bool === undefined ){\n        return p.notificationsEnabled;\n      } else {\n        p.notificationsEnabled = bool ? true : false;\n      }\n    },\n    \n    noNotifications: function( callback ){\n      this.notifications(false);\n      callback();\n      this.notifications(true);\n    },\n\n    startBatch: function(){\n      var _p = this._private;\n\n      _p.batchingStyle = _p.batchingNotify = true;\n      _p.batchStyleEles = [];\n      _p.batchNotifyEles = [];\n      _p.batchNotifyTypes = [];\n\n      _p.batchStyleEles.ids = {};\n      _p.batchNotifyEles.ids = {};\n      _p.batchNotifyTypes.ids = {};\n\n      return this;\n    },\n\n    endBatch: function(){\n      var _p = this._private;\n\n      // update style for dirty eles\n      _p.batchingStyle = false;\n      new $$.Collection(this, _p.batchStyleEles).updateStyle();\n\n      // notify the renderer of queued eles and event types\n      _p.batchingNotify = false;\n      this.notify({\n        type: _p.batchNotifyTypes,\n        collection: _p.batchNotifyEles\n      });\n\n      return this;\n    },\n\n    batch: function( callback ){\n      this.startBatch();\n      callback();\n      this.endBatch();\n\n      return this;\n    },\n\n    // for backwards compatibility\n    batchData: function( map ){\n      var cy = this;\n\n      return this.batch(function(){\n        for( var id in map ){\n          var data = map[id];\n          var ele = cy.getElementById( id );\n          \n          ele.data( data );\n        }\n      });\n    }\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    renderTo: function( context, zoom, pan, pxRatio ){\n      var r = this._private.renderer;\n\n      r.renderTo( context, zoom, pan, pxRatio );\n      return this;\n    },\n\n    renderer: function(){\n      return this._private.renderer;\n    },\n\n    forceRender: function(){\n      this.notify({\n        type: 'draw'\n      });\n\n      return this;\n    },\n\n    resize: function(){\n      this.notify({\n        type: 'resize'\n      });\n\n      this.trigger('resize');\n\n      return this;\n    },\n    \n    initRenderer: function( options ){\n      var cy = this;\n\n      var RendererProto = $$.extension('renderer', options.name);\n      if( RendererProto == null ){\n        $$.util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);\n        return;\n      }\n      \n      this._private.renderer = new RendererProto(\n        $$.util.extend({}, options, {\n          cy: cy,\n          style: cy._private.style\n        })\n      );\n       \n    }\n    \n  });  \n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n\n    // get a collection\n    // - empty collection on no args\n    // - collection of elements in the graph on selector arg\n    // - guarantee a returned collection when elements or collection specified\n    collection: function( eles ){\n\n      if( $$.is.string( eles ) ){\n        return this.$( eles );\n\n      } else if( $$.is.elementOrCollection( eles ) ){\n        return eles.collection();\n\n      } else if( $$.is.array( eles ) ){\n        return new $$.Collection( this, eles );\n      }\n\n      return new $$.Collection( this );\n    },\n    \n    nodes: function( selector ){\n      var nodes = this.$(function(){\n        return this.isNode();\n      });\n\n      if( selector ){\n        return nodes.filter( selector );\n      } \n\n      return nodes;\n    },\n    \n    edges: function( selector ){\n      var edges = this.$(function(){\n        return this.isEdge();\n      });\n\n      if( selector ){\n        return edges.filter( selector );\n      }\n\n      return edges;\n    },\n      \n    // search the graph like jQuery\n    $: function( selector ){\n      var eles = new $$.Collection( this, this._private.elements );\n\n      if( selector ){\n        return eles.filter( selector );\n      }\n\n      return eles;\n    }\n    \n  });  \n\n  // aliases\n  $$.corefn.elements = $$.corefn.filter = $$.corefn.$;  \n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    style: function( newStyle ){\n      if( newStyle ){\n        var s = this.setStyle( newStyle );\n\n        s.update();\n      }\n\n      return this._private.style;\n    },\n\n    setStyle: function( style ){\n      var _p = this._private;\n\n      if( $$.is.stylesheet(style) ){\n        _p.style = style.generateStyle(this);\n      \n      } else if( $$.is.array(style) ) {\n        _p.style = $$.style.fromJson(this, style);\n      \n      } else if( $$.is.string(style) ){\n        _p.style = $$.style.fromString(this, style);\n      \n      } else {\n        _p.style = new $$.Style( this );\n      }\n\n      return _p.style;\n    }\n  });\n  \n})( cytoscape );\n\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n\n    autolock: function(bool){\n      if( bool !== undefined ){\n        this._private.autolock = bool ? true : false;\n      } else {\n        return this._private.autolock;\n      }\n      \n      return this; // chaining\n    },\n\n    autoungrabify: function(bool){\n      if( bool !== undefined ){\n        this._private.autoungrabify = bool ? true : false;\n      } else {\n        return this._private.autoungrabify;\n      }\n      \n      return this; // chaining\n    },\n\n    autounselectify: function(bool){\n      if( bool !== undefined ){\n        this._private.autounselectify = bool ? true : false;\n      } else {\n        return this._private.autounselectify;\n      }\n      \n      return this; // chaining\n    },\n\n    panningEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.panningEnabled = bool ? true : false;\n      } else {\n        return this._private.panningEnabled;\n      }\n      \n      return this; // chaining\n    },\n\n    userPanningEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.userPanningEnabled = bool ? true : false;\n      } else {\n        return this._private.userPanningEnabled;\n      }\n      \n      return this; // chaining\n    },\n    \n    zoomingEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.zoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.zoomingEnabled;\n      }\n      \n      return this; // chaining\n    },\n\n    userZoomingEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.userZoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.userZoomingEnabled;\n      }\n      \n      return this; // chaining\n    },\n\n    boxSelectionEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.boxSelectionEnabled = bool ? true : false;\n      } else {\n        return this._private.boxSelectionEnabled;\n      }\n      \n      return this; // chaining\n    },\n    \n    pan: function(){\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      switch( args.length ){\n      case 0: // .pan()\n        return pan;\n\n      case 1: \n\n        if( $$.is.string( args[0] ) ){ // .pan('x')\n          dim = args[0];\n          return pan[ dim ];\n\n        } else if( $$.is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })\n          if( !this._private.panningEnabled ){\n            return this;\n          }\n\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if( $$.is.number(x) ){\n            pan.x = x;\n          }\n\n          if( $$.is.number(y) ){\n            pan.y = y;\n          }\n\n          this.trigger('pan viewport');\n        }\n        break;\n\n      case 2: // .pan('x', 100)\n        if( !this._private.panningEnabled ){\n          return this;\n        }\n\n        dim = args[0];\n        val = args[1];\n\n        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){\n          pan[dim] = val;\n        }\n\n        this.trigger('pan viewport');\n        break;\n\n      default:\n        break; // invalid\n      }\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n\n      return this; // chaining\n    },\n    \n    panBy: function(params){\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      if( !this._private.panningEnabled ){\n        return this;\n      }\n\n      switch( args.length ){\n      case 1: \n\n        if( $$.is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if( $$.is.number(x) ){\n            pan.x += x;\n          }\n\n          if( $$.is.number(y) ){\n            pan.y += y;\n          }\n\n          this.trigger('pan viewport');\n        }\n        break;\n\n      case 2: // .panBy('x', 100)\n        dim = args[0];\n        val = args[1];\n\n        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){\n          pan[dim] += val;\n        }\n\n        this.trigger('pan viewport');\n        break;\n\n      default:\n        break; // invalid\n      }\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n\n      return this; // chaining\n    },\n    \n    fit: function( elements, padding ){\n      var viewportState = this.getFitViewport( elements, padding );\n\n      if( viewportState ){\n        var _p = this._private;\n        _p.zoom = viewportState.zoom;\n        _p.pan = viewportState.pan;\n\n        this.trigger('pan zoom viewport');\n\n        this.notify({ // notify the renderer that the viewport changed\n          type: 'viewport'\n        });\n      }\n\n      return this; // chaining\n    },\n\n    getFitViewport: function( elements, padding ){\n      if( $$.is.number(elements) && padding === undefined ){ // elements is optional\n        padding = elements;\n        elements = undefined;\n      }\n\n      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n        return;\n      }\n\n      var bb;\n\n      if( $$.is.string(elements) ){\n        var sel = elements;\n        elements = this.$( sel );\n\n      } else if( $$.is.boundingBox(elements) ){ // assume bb\n        var bbe = elements;\n        bb = {\n          x1: bbe.x1,\n          y1: bbe.y1,\n          x2: bbe.x2,\n          y2: bbe.y2\n        };\n\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n\n      } else if( !$$.is.elementOrCollection(elements) ){\n        elements = this.elements();\n      }\n\n      bb = bb || elements.boundingBox();\n\n      var w = this.width();\n      var h = this.height();\n      var zoom;\n      padding = $$.is.number(padding) ? padding : 0;\n\n      if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){\n        zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );\n\n        // crop zoom\n        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\n        var pan = { // now pan to middle\n          x: (w - zoom*( bb.x1 + bb.x2 ))/2,\n          y: (h - zoom*( bb.y1 + bb.y2 ))/2\n        };\n\n        return {\n          zoom: zoom, \n          pan: pan\n        };\n      }\n\n      return;\n    },\n    \n    minZoom: function( zoom ){\n      if( zoom === undefined ){\n        return this._private.minZoom;\n      } else if( $$.is.number(zoom) ){\n        this._private.minZoom = zoom;\n      }\n\n      return this;\n    },\n\n    maxZoom: function( zoom ){\n      if( zoom === undefined ){\n        return this._private.maxZoom;\n      } else if( $$.is.number(zoom) ){\n        this._private.maxZoom = zoom;\n      }\n\n      return this;\n    },\n\n    zoom: function( params ){\n      var pos; // in rendered px\n      var zoom;\n\n      if( params === undefined ){ // then get the zoom\n        return this._private.zoom;\n\n      } else if( $$.is.number(params) ){ // then set the zoom\n        zoom = params;\n\n      } else if( $$.is.plainObject(params) ){ // then zoom about a point\n        zoom = params.level;\n\n        if( params.position ){\n          var p = params.position;\n          var pan = this._private.pan;\n          var z = this._private.zoom;\n\n          pos = { // convert to rendered px\n            x: p.x * z + pan.x,\n            y: p.y * z + pan.y\n          };\n        } else if( params.renderedPosition ){\n          pos = params.renderedPosition;\n        }\n\n        if( pos && !this._private.panningEnabled ){\n          return this; // panning disabled\n        }\n      }\n\n      if( !this._private.zoomingEnabled ){\n        return this; // zooming disabled\n      }\n\n      if( !$$.is.number(zoom) || ( pos && (!$$.is.number(pos.x) || !$$.is.number(pos.y)) ) ){\n        return this; // can't zoom with invalid params\n      }\n\n      // crop zoom\n      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\n      if( pos ){ // set zoom about position\n        var pan1 = this._private.pan;\n        var zoom1 = this._private.zoom;\n        var zoom2 = zoom;\n        \n        var pan2 = {\n          x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,\n          y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y\n        };\n\n        this._private.zoom = zoom;\n        this._private.pan = pan2;\n\n        var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;\n        this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );\n      \n      } else { // just set the zoom\n        this._private.zoom = zoom;\n        this.trigger('zoom viewport');\n      }\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n\n      return this; // chaining\n    },\n\n    viewport: function( opts ){ \n      var _p = this._private;\n      var zoomDefd = true;\n      var panDefd = true;\n      var events = []; // to trigger\n      var zoomFailed = false;\n      var panFailed = false;\n\n      if( !opts ){ return this; }\n      if( !$$.is.number(opts.zoom) ){ zoomDefd = false; }\n      if( !$$.is.plainObject(opts.pan) ){ panDefd = false; }\n      if( !zoomDefd && !panDefd ){ return this; }\n\n      if( zoomDefd ){\n        var z = opts.zoom;\n\n        if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){\n          zoomFailed = true;\n\n        } else {\n          _p.zoom = z;\n\n          events.push('zoom');\n        }\n      }\n\n      if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){\n        var p = opts.pan;\n\n        if( $$.is.number(p.x) ){\n          _p.pan.x = p.x;\n          panFailed = false;\n        }\n\n        if( $$.is.number(p.y) ){\n          _p.pan.y = p.y;\n          panFailed = false;\n        }\n\n        if( !panFailed ){\n          events.push('pan');\n        }\n      }\n\n      if( events.length > 0 ){\n        events.push('viewport');\n        this.trigger( events.join(' ') );\n\n        this.notify({\n          type: 'viewport'\n        });\n      }\n\n      return this; // chaining\n    },\n    \n    center: function( elements ){\n      var pan = this.getCenterPan( elements );\n\n      if( pan ){\n        this._private.pan = pan;\n\n        this.trigger('pan viewport');\n\n        this.notify({ // notify the renderer that the viewport changed\n          type: 'viewport'\n        });\n      }\n\n      return this; // chaining\n    },\n\n    getCenterPan: function( elements, zoom ){\n      if( !this._private.panningEnabled ){\n        return;\n      }\n\n      if( $$.is.string(elements) ){\n        var selector = elements;\n        elements = this.elements( selector );\n      } else if( !$$.is.elementOrCollection(elements) ){\n        elements = this.elements();\n      }\n\n      var bb = elements.boundingBox();\n      var w = this.width();\n      var h = this.height();\n      zoom = zoom === undefined ? this._private.zoom : zoom;\n\n      var pan = { // middle\n        x: (w - zoom*( bb.x1 + bb.x2 ))/2,\n        y: (h - zoom*( bb.y1 + bb.y2 ))/2\n      };\n      \n      return pan;\n    },\n    \n    reset: function(){\n      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n        return this;\n      }\n\n      this.viewport({\n        pan: { x: 0, y: 0 },\n        zoom: 1\n      });\n      \n      return this; // chaining\n    },\n\n    width: function(){\n      var container = this._private.container;\n\n      if( container ){\n        return container.clientWidth;\n      }\n\n      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)\n    },\n\n    height: function(){\n      var container = this._private.container;\n\n      if( container ){\n        return container.clientHeight;\n      }\n\n      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)\n    },\n\n    extent: function(){\n      var pan = this._private.pan;\n      var zoom = this._private.zoom;\n      var rb = this.renderedExtent();\n\n      var b = {\n        x1: ( rb.x1 - pan.x )/zoom,\n        x2: ( rb.x2 - pan.x )/zoom,\n        y1: ( rb.y1 - pan.y )/zoom,\n        y2: ( rb.y2 - pan.y )/zoom,\n      };\n\n      b.w = b.x2 - b.x1;\n      b.h = b.y2 - b.y1;\n\n      return b;\n    },\n\n    renderedExtent: function(){\n      var width = this.width();\n      var height = this.height();\n\n      return {\n        x1: 0,\n        y1: 0,\n        x2: width,\n        y2: height,\n        w: width,\n        h: height\n      };\n    }\n  });\n\n  // aliases\n  $$.corefn.centre = $$.corefn.center;\n\n  // backwards compatibility\n  $$.corefn.autolockNodes = $$.corefn.autolock;\n  $$.corefn.autoungrabifyNodes = $$.corefn.autoungrabify;\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // Use this interface to define functions for collections/elements.\n  // This interface is good, because it forces you to think in terms\n  // of the collections case (more than 1 element), so we don't need\n  // notification blocking nonsense everywhere.\n  //\n  // Other collection-*.js files depend on this being defined first.\n  // It's a trade off: It simplifies the code for Collection and \n  // Element integration so much that it's worth it to create the\n  // JS dependency.\n  //\n  // Having this integration guarantees that we can call any\n  // collection function on an element and vice versa.\n\n  // e.g. $$.fn.collection({ someFunc: function(){ /* ... */ } })\n  $$.fn.collection = $$.fn.eles = function( fnMap, options ){\n    for( var name in fnMap ){\n      var fn = fnMap[name];\n\n      $$.Collection.prototype[ name ] = fn;\n    }\n  };\n  \n  // factory for generating edge ids when no id is specified for a new element\n  var idFactory = {\n    prefix: {\n      nodes: 'n',\n      edges: 'e'\n    },\n    id: {\n      nodes: 0,\n      edges: 0\n    },\n    generate: function(cy, element, tryThisId){\n      var json = $$.is.element( element ) ? element._private : element;\n      var group = json.group;\n      var id = tryThisId != null ? tryThisId : this.prefix[group] + this.id[group];\n      \n      if( cy.getElementById(id).empty() ){\n        this.id[group]++; // we've used the current id, so move it up\n      } else { // otherwise keep trying successive unused ids\n        while( !cy.getElementById(id).empty() ){\n          id = this.prefix[group] + ( ++this.id[group] );\n        }\n      }\n      \n      return id;\n    }\n  };\n  \n  // Element\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  // represents a node or an edge\n  $$.Element = function(cy, params, restore){\n    if( !(this instanceof $$.Element) ){\n      return new $$.Element(cy, params, restore);\n    }\n\n    var self = this;\n    restore = (restore === undefined || restore ? true : false);\n    \n    if( cy === undefined || params === undefined || !$$.is.core(cy) ){\n      $$.util.error('An element must have a core reference and parameters set');\n      return;\n    }\n    \n    // validate group\n    if( params.group !== 'nodes' && params.group !== 'edges' ){\n      $$.util.error('An element must be of type `nodes` or `edges`; you specified `' + params.group + '`');\n      return;\n    }\n    \n    // make the element array-like, just like a collection\n    this.length = 1;\n    this[0] = this;\n    \n    // NOTE: when something is added here, add also to ele.json()\n    this._private = {\n      cy: cy,\n      single: true, // indicates this is an element\n      data: params.data || {}, // data object\n      layoutData: {}, // place for layouts to put calculated stats etc for mappers\n      position: params.position || {}, // (x, y) position pair\n      autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value\n      autoHeight: undefined, \n      listeners: [], // array of bound listeners\n      group: params.group, // string; 'nodes' or 'edges'\n      style: {}, // properties as set by the style\n      rstyle: {}, // properties for style sent from the renderer to the core\n      styleCxts: [], // applied style contexts from the styler\n      removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)\n      selected: params.selected ? true : false, // whether it's selected\n      selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable\n      locked: params.locked ? true : false, // whether the element is locked (cannot be moved)\n      grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately\n      grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed\n      active: false, // whether the element is active from user interaction\n      classes: {}, // map ( className => true )\n      animation: { // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      rscratch: {}, // object in which the renderer can store information\n      scratch: {}, // scratch objects\n      edges: [], // array of connected edges\n      children: [] // array of children\n    };\n    \n    // renderedPosition overrides if specified\n    if( params.renderedPosition ){\n      var rpos = params.renderedPosition;\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n\n      this._private.position = {\n        x: (rpos.x - pan.x)/zoom,\n        y: (rpos.y - pan.y)/zoom\n      };\n    }\n    \n    if( $$.is.string(params.classes) ){\n      var classes = params.classes.split(/\\s+/);\n      for( var i = 0, l = classes.length; i < l; i++ ){\n        var cls = classes[i];\n        if( !cls || cls === '' ){ continue; }\n\n        self._private.classes[cls] = true;\n      }\n    }\n\n    if( params.css ){\n      cy.style().applyBypass( this, params.css );\n    }\n    \n    if( restore === undefined || restore ){\n      this.restore();\n    }\n    \n  };\n\n  \n  // Collection\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  // represents a set of nodes, edges, or both together\n  $$.Collection = function(cy, elements, options){\n    if( !(this instanceof $$.Collection) ){\n      return new $$.Collection(cy, elements);\n    }\n\n    if( cy === undefined || !$$.is.core(cy) ){\n      $$.util.error('A collection must have a reference to the core');\n      return;\n    }\n    \n    var ids = {};\n    var indexes = {};\n    var createdElements = false;\n    \n    if( !elements ){\n      elements = [];\n    } else if( elements.length > 0 && $$.is.plainObject( elements[0] ) && !$$.is.element( elements[0] ) ){\n      createdElements = true;\n\n      // make elements from json and restore all at once later\n      var eles = [];\n      var elesIds = {};\n\n      for( var i = 0, l = elements.length; i < l; i++ ){\n        var json = elements[i];\n\n        if( json.data == null ){\n          json.data = {};\n        }\n        \n        var data = json.data;\n\n        // make sure newly created elements have valid ids\n        if( data.id == null ){\n          data.id = idFactory.generate( cy, json );\n        } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){\n          continue; // can't create element if prior id already exists\n        }\n\n        var ele = new $$.Element( cy, json, false );\n        eles.push( ele );\n        elesIds[ data.id ] = true;\n      }\n\n      elements = eles;\n    }\n    \n    this.length = 0;\n\n    for( var i = 0, l = elements.length; i < l; i++ ){\n      var element = elements[i];\n      if( !element ){  continue; }\n      \n      var id = element._private.data.id;\n      \n      if( !options || (options.unique && !ids[ id ] ) ){\n        ids[ id ] = element;\n        indexes[ id ] = this.length;\n\n        this[ this.length ] = element;\n        this.length++;\n      }\n    }\n    \n    this._private = {\n      cy: cy,\n      ids: ids,\n      indexes: indexes\n    };\n\n    // restore the elements if we created them from json\n    if( createdElements ){\n      this.restore();\n    }\n  };\n  \n  \n  // Functions\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  // keep the prototypes in sync (an element has the same functions as a collection)\n  // and use $$.elefn and $$.elesfn as shorthands to the prototypes\n  $$.elefn = $$.elesfn = $$.Element.prototype = $$.Collection.prototype;\n\n  $$.elesfn.cy = function(){\n    return this._private.cy;\n  };\n  \n  $$.elesfn.element = function(){\n    return this[0];\n  };\n  \n  $$.elesfn.collection = function(){\n    if( $$.is.collection(this) ){\n      return this;\n    } else { // an element\n      return new $$.Collection( this._private.cy, [this] );\n    }\n  };\n\n  $$.elesfn.unique = function(){\n    return new $$.Collection( this._private.cy, this, { unique: true } );\n  };\n\n  $$.elesfn.getElementById = function( id ){\n    var cy = this._private.cy;\n    var ele = this._private.ids[ id ];\n\n    return ele ? ele : $$.Collection(cy); // get ele or empty collection\n  };\n\n  $$.elesfn.json = function(){\n    var ele = this.element();\n    if( ele == null ){ return undefined; }\n\n    var p = ele._private;\n    \n    var json = $$.util.copy({\n      data: p.data,\n      position: p.position,\n      group: p.group,\n      bypass: p.bypass,\n      removed: p.removed,\n      selected: p.selected,\n      selectable: p.selectable,\n      locked: p.locked,\n      grabbed: p.grabbed,\n      grabbable: p.grabbable,\n      classes: ''\n    });\n    \n    var classes = [];\n    for( var cls in p.classes ){\n      if( p.classes[cls] ){\n        classes.push(cls);\n      }\n    }\n    \n    for( var i = 0; i < classes.length; i++ ){\n      var cls = classes[i];\n      json.classes += cls + ( i < classes.length - 1 ? ' ' : '' );\n    }\n    \n    return json;\n  };\n\n  $$.elesfn.jsons = function(){\n    var jsons = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[i];\n      var json = ele.json();\n\n      jsons.push( json );\n    }\n\n    return jsons;\n  };\n\n  $$.elesfn.clone = function(){\n    var cy = this.cy();\n    var elesArr = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[i];\n      var json = ele.json();\n      var clone = new $$.Element(cy, json, false); // NB no restore\n\n      elesArr.push( clone );\n    }\n\n    return new $$.Collection( cy, elesArr );\n  };\n\n  $$.elesfn.restore = function( notifyRenderer ){\n    var self = this;\n    var restored = [];\n    var cy = self.cy();\n    \n    if( notifyRenderer === undefined ){\n      notifyRenderer = true;\n    }\n\n    // create arrays of nodes and edges, since we need to\n    // restore the nodes first\n    var elements = [];\n    var nodes = [], edges = [];\n    var numNodes = 0;\n    var numEdges = 0;\n    for( var i = 0, l = self.length; i < l; i++ ){\n      var ele = self[i];\n      \n      // keep nodes first in the array and edges after\n      if( ele.isNode() ){ // put to front of array if node\n        nodes.push( ele );\n        numNodes++;\n      } else { // put to end of array if edge\n        edges.push( ele );\n        numEdges++;\n      }\n    }\n\n    elements = nodes.concat( edges );\n\n    // now, restore each element\n    for( var i = 0, l = elements.length; i < l; i++ ){\n      var ele = elements[i];\n\n      if( !ele.removed() ){\n        // don't need to do anything\n        continue;\n      }\n      \n      var _private = ele._private;\n      var data = _private.data;\n      \n      // set id and validate\n      if( data.id === undefined ){\n        data.id = idFactory.generate( cy, ele );\n      } else if( $$.is.emptyString(data.id) || !$$.is.string(data.id) ){\n        $$.util.error('Can not create element with invalid string ID `' + data.id + '`');\n        \n        // can't create element if it has empty string as id or non-string id\n        continue;\n      } else if( cy.getElementById( data.id ).length !== 0 ){\n        $$.util.error('Can not create second element with ID `' + data.id + '`');\n        \n        // can't create element if one already has that id\n        continue;\n      }\n\n      var id = data.id; // id is finalised, now let's keep a ref\n      \n      if( ele.isEdge() ){ // extra checks for edges\n        \n        var edge = ele;\n        var fields = ['source', 'target'];\n        var fieldsLength = fields.length;\n        var badSourceOrTarget = false;\n        for(var j = 0; j < fieldsLength; j++){\n          \n          var field = fields[j];\n          var val = data[field];\n          \n          if( val == null || val === '' ){\n            // can't create if source or target is not defined properly\n            $$.util.error('Can not create edge `' + id + '` with unspecified ' + field);\n            badSourceOrTarget = true;\n          } else if( cy.getElementById(val).empty() ){ \n            // can't create edge if one of its nodes doesn't exist\n            $$.util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n            badSourceOrTarget = true;\n          }\n        }\n\n        if( badSourceOrTarget ){ continue; } // can't create this\n        \n        var src = cy.getElementById( data.source );\n        var tgt = cy.getElementById( data.target );\n\n        src._private.edges.push( edge );\n        tgt._private.edges.push( edge );\n\n        edge._private.source = src;\n        edge._private.target = tgt;\n\n      } // if is edge\n       \n      // create mock ids map for element so it can be used like collections\n      _private.ids = {};\n      _private.ids[ id ] = ele;\n\n      _private.removed = false;\n      cy.addToPool( ele );\n      \n      restored.push( ele );\n    } // for each element\n\n    // do compound node sanity checks\n    for( var i = 0; i < numNodes; i++ ){ // each node \n      var node = elements[i];\n      var data = node._private.data;\n\n      var parentId = node._private.data.parent;\n      var specifiedParent = parentId != null;\n\n      if( specifiedParent ){\n        var parent = cy.getElementById( parentId );\n\n        if( parent.empty() ){\n          // non-existant parent; just remove it\n          data.parent = undefined;\n        } else {\n          var selfAsParent = false;\n          var ancestor = parent;\n          while( !ancestor.empty() ){\n            if( node.same(ancestor) ){\n              // mark self as parent and remove from data\n              selfAsParent = true;\n              data.parent = undefined; // remove parent reference\n\n              // exit or we loop forever\n              break;\n            }\n\n            ancestor = ancestor.parent();\n          }\n\n          if( !selfAsParent ){\n            // connect with children\n            parent[0]._private.children.push( node );\n            node._private.parent = parent[0];\n\n            // let the core know we have a compound graph\n            cy._private.hasCompoundNodes = true;\n          }\n        } // else\n      } // if specified parent\n    } // for each node\n    \n    restored = new $$.Collection( cy, restored );\n    if( restored.length > 0 ){\n\n      var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );\n      toUpdateStyle.updateStyle( notifyRenderer );\n\n      if( notifyRenderer ){\n        restored.rtrigger('add');\n      } else {\n        restored.trigger('add');\n      }\n    }\n    \n    return self; // chainability\n  };\n  \n  $$.elesfn.removed = function(){\n    var ele = this[0];\n    return ele && ele._private.removed;\n  };\n\n  $$.elesfn.inside = function(){\n    var ele = this[0];\n    return ele && !ele._private.removed;\n  };\n\n  $$.elesfn.remove = function( notifyRenderer ){\n    var self = this;\n    var removed = [];\n    var elesToRemove = [];\n    var elesToRemoveIds = {};\n    var cy = self._private.cy;\n    \n    if( notifyRenderer === undefined ){\n      notifyRenderer = true;\n    }\n    \n    // add connected edges\n    function addConnectedEdges(node){\n      var edges = node._private.edges; \n      for( var i = 0; i < edges.length; i++ ){\n        add( edges[i] );\n      }\n    }\n    \n\n    // add descendant nodes\n    function addChildren(node){\n      var children = node._private.children;\n      \n      for( var i = 0; i < children.length; i++ ){\n        add( children[i] );\n      }\n    }\n\n    function add( ele ){\n      var alreadyAdded =  elesToRemoveIds[ ele.id() ];\n      if( alreadyAdded ){\n        return;\n      } else {\n        elesToRemoveIds[ ele.id() ] = true;\n      }\n\n      if( ele.isNode() ){\n        elesToRemove.push( ele ); // nodes are removed last\n\n        addConnectedEdges( ele );\n        addChildren( ele );\n      } else {\n        elesToRemove.unshift( ele ); // edges are removed first\n      }\n    }\n\n    // make the list of elements to remove\n    // (may be removing more than specified due to connected edges etc)\n\n    for( var i = 0, l = self.length; i < l; i++ ){\n      var ele = self[i];\n\n      add( ele );\n    }\n    \n    function removeEdgeRef(node, edge){\n      var connectedEdges = node._private.edges;\n      for( var j = 0; j < connectedEdges.length; j++ ){\n        var connectedEdge = connectedEdges[j];\n        \n        if( edge === connectedEdge ){\n          connectedEdges.splice( j, 1 );\n          break;\n        }\n      }\n    }\n\n    function removeChildRef(parent, ele){\n      ele = ele[0];\n      parent = parent[0];\n      var children = parent._private.children;\n\n      for( var j = 0; j < children.length; j++ ){\n        if( children[j][0] === ele[0] ){\n          children.splice(j, 1);\n          break;\n        }\n      }\n    }\n\n    for( var i = 0; i < elesToRemove.length; i++ ){\n      var ele = elesToRemove[i];\n\n      // mark as removed\n      ele._private.removed = true;\n\n      // remove from core pool\n      cy.removeFromPool( ele );\n\n      // add to list of removed elements\n      removed.push( ele );\n\n      if( ele.isEdge() ){ // remove references to this edge in its connected nodes\n        var src = ele.source()[0];\n        var tgt = ele.target()[0];\n\n        removeEdgeRef( src, ele );\n        removeEdgeRef( tgt, ele );\n\n      } else { // remove reference to parent \n        var parent = ele.parent();\n\n        if( parent.length !== 0 ){\n          removeChildRef(parent, ele);\n        }\n      }\n    }\n\n    // check to see if we have a compound graph or not\n    var elesStillInside = cy._private.elements;\n    cy._private.hasCompoundNodes = false;\n    for( var i = 0; i < elesStillInside.length; i++ ){\n      var ele = elesStillInside[i];\n\n      if( ele.isParent() ){\n        cy._private.hasCompoundNodes = true;\n        break;\n      }\n    }\n\n    var removedElements = new $$.Collection( this.cy(), removed );\n    if( removedElements.size() > 0 ){\n      // must manually notify since trigger won't do this automatically once removed\n      \n      if( notifyRenderer ){\n        this.cy().notify({\n          type: 'remove',\n          collection: removedElements\n        });\n      }\n      \n      removedElements.trigger('remove');\n    }\n\n    // check for empty remaining parent nodes\n    var checkedParentId = {};\n    for( var i = 0; i < elesToRemove.length; i++ ){\n      var ele = elesToRemove[i];\n      var isNode = ele._private.group === 'nodes';\n      var parentId = ele._private.data.parent;\n\n      if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){\n        checkedParentId[ parentId ] = true;\n        var parent = cy.getElementById( parentId );\n\n        if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){\n          parent.updateStyle();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  $$.elesfn.move = function( struct ){\n    var cy = this._private.cy;\n\n    if( struct.source !== undefined || struct.target !== undefined ){\n      var srcId = struct.source;\n      var tgtId = struct.target;\n      var srcExists = cy.getElementById( srcId ).length > 0;\n      var tgtExists = cy.getElementById( tgtId ).length > 0;\n\n      if( srcExists || tgtExists ){\n        var jsons = this.jsons();\n\n        this.remove();\n\n        for( var i = 0; i < jsons.length; i++ ){\n          var json = jsons[i];\n\n          if( json.group === 'edges' ){\n            if( srcExists ){ json.data.source = srcId; }\n            if( tgtExists ){ json.data.target = tgtId; }\n          }\n        }\n\n        return cy.add( jsons );\n      }\n \n    } else if( struct.parent !== undefined ){ // move node to new parent\n      var parentId = struct.parent;\n      var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;\n    \n      if( parentExists ){\n        var jsons = this.jsons();\n        var descs = this.descendants();\n        var descsEtc = descs.merge( descs.add(this).connectedEdges() );\n\n        this.remove(); // NB: also removes descendants and their connected edges\n\n        for( var i = 0; i < this.length; i++ ){\n          var json = jsons[i];\n\n          if( json.group === 'nodes' ){\n            json.data.parent = parentId === null ? undefined : parentId;\n          }\n        }\n      }\n\n      return cy.add( jsons ).merge( descsEtc.restore() );\n    }\n\n    return this; // if nothing done\n  };\n  \n})( cytoscape );\n\n\n;(function($$){ 'use strict';\n\n  // search, spanning trees, etc\n  $$.fn.eles({\n\n    // std functional ele first callback style\n    stdBreadthFirstSearch: function( options ){\n      options = $$.util.extend( {}, options, {\n        std: true\n      } );\n\n      return this.breadthFirstSearch( options );\n    },\n\n    // do a breadth first search from the nodes in the collection\n    // from pseudocode on wikipedia\n    breadthFirstSearch: function( roots, fn, directed ){\n      var options;\n      var std;\n      var thisArg;\n      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){\n        options = roots;\n        roots = options.roots;\n        fn = options.visit;\n        directed = options.directed;\n        std = options.std;\n        thisArg = options.thisArg;\n      }\n\n      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;\n      fn = $$.is.fn(fn) ? fn : function(){};\n      \n      var cy = this._private.cy;\n      var v = $$.is.string(roots) ? this.filter(roots) : roots;\n      var Q = [];\n      var connectedNodes = [];\n      var connectedBy = {};\n      var id2depth = {};\n      var V = {};\n      var j = 0;\n      var found;\n      var nodes = this.nodes();\n      var edges = this.edges();\n\n      // enqueue v\n      for( var i = 0; i < v.length; i++ ){\n        if( v[i].isNode() ){\n          Q.unshift( v[i] );\n          V[ v[i].id() ] = true; \n\n          connectedNodes.push( v[i] );\n          id2depth[ v[i].id() ] = 0;\n        }\n      }\n\n      while( Q.length !== 0 ){\n        var v = Q.shift();\n        var depth = id2depth[ v.id() ];\n        var prevEdge = connectedBy[ v.id() ];\n        var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];\n        var ret;\n\n        if( std ){\n          ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);\n        } else {\n          ret = fn.call(v, j++, depth, v, prevEdge, prevNode);\n        }\n\n        if( ret === true ){\n          found = v;\n          break;\n        }\n\n        if( ret === false ){\n          break;\n        }\n\n        var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );\n        for( var i = 0; i < vwEdges.length; i++ ){\n          var e = vwEdges[i];\n          var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );\n\n          if( w.length !== 0 && !V[ w.id() ] ){\n            w = w[0];\n\n            Q.push( w );\n            V[ w.id() ] = true;\n\n            id2depth[ w.id() ] = id2depth[ v.id() ] + 1;\n\n            connectedNodes.push( w );\n            connectedBy[ w.id() ] = e;\n          }\n        }\n        \n      }\n\n      var connectedEles = [];\n\n      for( var i = 0; i < connectedNodes.length; i++ ){\n        var node = connectedNodes[i];\n        var edge = connectedBy[ node.id() ];\n\n        if( edge ){\n          connectedEles.push( edge );\n        }\n\n        connectedEles.push( node );\n      }\n\n      return {\n        path: new $$.Collection( cy, connectedEles, { unique: true } ),\n        found: new $$.Collection( cy, found, { unique: true } )\n      };\n    },\n\n    // std functional ele first callback style\n    stdDepthFirstSearch: function( options ){\n      options = $$.util.extend( {}, options, {\n        std: true\n      } );\n\n      return this.depthFirstSearch( options );\n    },\n\n    // do a depth first search on the nodes in the collection\n    // from pseudocode on wikipedia (iterative impl)\n    depthFirstSearch: function( roots, fn, directed ){\n      var options;\n      var std;\n      var thisArg;\n      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){\n        options = roots;\n        roots = options.roots;\n        fn = options.visit;\n        directed = options.directed;\n        std = options.std;\n        thisArg = options.thisArg;\n      }\n      \n      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;\n      fn = $$.is.fn(fn) ? fn : function(){};\n      var cy = this._private.cy;\n      var v = $$.is.string(roots) ? this.filter(roots) : roots;\n      var S = [];\n      var connectedNodes = [];\n      var connectedBy = {};\n      var id2depth = {};\n      var discovered = {};\n      var j = 0;\n      var found;\n      var edges = this.edges();\n      var nodes = this.nodes();\n\n      // push v\n      for( var i = 0; i < v.length; i++ ){\n        if( v[i].isNode() ){\n          S.push( v[i] );\n\n          connectedNodes.push( v[i] );\n          id2depth[ v[i].id() ] = 0;\n        }\n      }\n\n      while( S.length !== 0 ){\n        var v = S.pop();\n\n        if( !discovered[ v.id() ] ){\n          discovered[ v.id() ] = true;\n\n          var depth = id2depth[ v.id() ];\n          var prevEdge = connectedBy[ v.id() ];\n          var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];\n          var ret;\n\n          if( std ){\n            ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);\n          } else {\n            ret = fn.call(v, j++, depth, v, prevEdge, prevNode);\n          }\n\n          if( ret === true ){\n            found = v;\n            break;\n          }\n\n          if( ret === false ){\n            break;\n          }\n\n          var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );\n          \n          for( var i = 0; i < vwEdges.length; i++ ){\n            var e = vwEdges[i];\n            var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );\n\n            if( w.length !== 0 && !discovered[ w.id() ] ){\n              w = w[0];\n\n              S.push( w );\n\n              id2depth[ w.id() ] = id2depth[ v.id() ] + 1;\n\n              connectedNodes.push( w );\n              connectedBy[ w.id() ] = e;\n            }\n          }\n        }\n      }\n\n      var connectedEles = [];\n\n      for( var i = 0; i < connectedNodes.length; i++ ){\n        var node = connectedNodes[i];\n        var edge = connectedBy[ node.id() ];\n\n        if( edge ){\n          connectedEles.push( edge );\n        }\n\n        connectedEles.push( node );\n      }\n\n      return {\n        path: new $$.Collection( cy, connectedEles, { unique: true } ),\n        found: new $$.Collection( cy, found, { unique: true } )\n      };\n    },\n\n    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n    // implemented from pseudocode from wikipedia\n    kruskal: function( weightFn ){\n      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\n      function findSet(ele){\n        for( var i = 0; i < forest.length; i++ ){\n          var eles = forest[i];\n\n          if( eles.anySame(ele) ){\n            return {\n              eles: eles,\n              index: i\n            };\n          }\n        }\n      }\n\n      var A = new $$.Collection(this._private.cy, []);\n      var forest = [];\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){\n        forest.push( nodes[i].collection() );\n      }\n\n      var edges = this.edges();\n      var S = edges.toArray().sort(function(a, b){\n        var weightA = weightFn.call(a, a);\n        var weightB = weightFn.call(b, b);\n\n        return weightA - weightB;\n      });\n\n      for(var i = 0; i < S.length; i++){\n        var edge = S[i];\n        var u = edge.source()[0];\n        var v = edge.target()[0];\n        var setU = findSet(u);\n        var setV = findSet(v);\n\n        if( setU.index !== setV.index ){\n          A = A.add( edge );\n\n          // combine forests for u and v\n          forest[ setU.index ] = setU.eles.add( setV.eles );\n          forest.splice( setV.index, 1 );\n        }\n      }\n\n      return nodes.add( A );\n\n    },\n\n    dijkstra: function( root, weightFn, directed ){\n      var options;\n      if( $$.is.plainObject(root) && !$$.is.elementOrCollection(root) ){\n        options = root;\n        root = options.root;\n        weightFn = options.weight;\n        directed = options.directed;\n      }\n\n      var cy = this._private.cy;\n      directed = !$$.is.fn(weightFn) ? weightFn : directed;\n      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\n      var source = $$.is.string(root) ? this.filter(root).eq(0) : root.eq(0);\n      var dist = {};\n      var prev = {};\n      var knownDist = {};\n\n      var edges = this.edges().filter(function(){ return !this.isLoop(); });\n      var nodes = this.nodes();\n      var Q = [];\n\n      for( var i = 0; i < nodes.length; i++ ){\n        dist[ nodes[i].id() ] = nodes[i].same( source ) ? 0 : Infinity;\n        Q.push( nodes[i] );\n      }\n\n      var valueFn = function(node) {\n        return dist[ node.id() ];\n      };\n      \n      Q = new $$.Collection(cy, Q);\n    \n      var heap = $$.Minheap(cy, Q, valueFn);\n    \n      var distBetween = function(u, v){\n        var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);\n        var smallestDistance = Infinity;\n        var smallestEdge;\n\n        for( var i = 0; i < uvs.length; i++ ){\n          var edge = uvs[i];\n          var weight = weightFn.apply( edge, [edge] );\n\n          if( weight < smallestDistance || !smallestEdge ){\n            smallestDistance = weight;\n            smallestEdge = edge;\n          }\n        }\n\n        return {\n          edge: smallestEdge,\n          dist: smallestDistance\n        };\n      };\n\n      while(heap.size() > 0){\n        var smallestEl = heap.pop(),\n        smalletsDist = smallestEl.value,\n        uid = smallestEl.id,\n        u = cy.getElementById(uid);\n    \n        knownDist[uid] = smalletsDist;\n      \n        if( smalletsDist === Math.Infinite ){\n          break;\n        }\n\n        var neighbors = u.neighborhood().intersect(nodes);\n        for( var i = 0; i < neighbors.length; i++ ){\n          var v = neighbors[i];\n          var vid = v.id();\n          var vDist = distBetween(u, v);\n\n          var alt = smalletsDist + vDist.dist;\n\n          if( alt < heap.getValueById(vid) ){\n            heap.edit(vid, alt);\n            prev[ vid ] = {\n              node: u,\n              edge: vDist.edge\n            };\n          }\n        } // for \n      } // while\n\n      return {\n        distanceTo: function(node){\n          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);\n\n          return knownDist[ target.id() ];\n        },\n\n        pathTo: function(node){\n          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);\n          var S = [];\n          var u = target;\n\n          if( target.length > 0 ){\n            S.unshift( target );\n\n            while( prev[ u.id() ] ){\n              var p = prev[ u.id() ];\n\n              S.unshift( p.edge );\n              S.unshift( p.node );\n\n              u = p.node;\n            }\n          }\n\n          return new $$.Collection( cy, S );\n        }\n      };\n    }  \n  });\n\n  // nice, short mathemathical alias\n  $$.elesfn.bfs = $$.elesfn.breadthFirstSearch;\n  $$.elesfn.dfs = $$.elesfn.depthFirstSearch;\n  $$.elesfn.stdBfs = $$.elesfn.stdBreadthFirstSearch;\n  $$.elesfn.stdDfs = $$.elesfn.stdDepthFirstSearch;\n  \n})( cytoscape );\n;(function($$) { \n  'use strict';\n\n  // Additional graph analysis algorithms\n  $$.fn.eles({\n\n    // Implemented from pseudocode from wikipedia\n\n    // options => options object\n    //   root // starting node (either element or selector string)\n    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges\n    //   heuristic: function( node ){} // specifies heuristic value for `node`/`this`\n    //   directed // default false\n    //   goal // target node (either element or selector string). Mandatory.\n\n    // retObj => returned object by function\n    //   found : true/false // whether a path from root to goal has been found\n    //   distance // Distance for the shortest path from root to goal\n    //   path // Array of ids of nodes in shortest path\n    aStar: function(options) {\n      options = options || {};\n\n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Reconstructs the path from Start to End, acumulating the result in pathAcum\n      var reconstructPath = function(start, end, cameFromMap, pathAcum) {\n        // Base case\n        if (start == end) {\n          pathAcum.push( cy.getElementById(end) );\n          return pathAcum;\n        }\n        \n        if (end in cameFromMap) {\n          // We know which node is before the last one\n          var previous = cameFromMap[end];\n          var previousEdge = cameFromEdge[end];\n\n          pathAcum.push( cy.getElementById(end) );\n          pathAcum.push( cy.getElementById(previousEdge) );\n\n\n          return reconstructPath(start, \n                       previous, \n                       cameFromMap, \n                       pathAcum);\n        }\n\n        // We should not reach here!\n        return undefined;       \n      };\n\n      // Returns the index of the element in openSet which has minimum fScore\n      var findMin = function(openSet, fScore) {\n        if (openSet.length === 0) {\n          // Should never be the case\n          return undefined;\n        }\n        var minPos = 0;\n        var tempScore = fScore[openSet[0]];\n        for (var i = 1; i < openSet.length; i++) {\n          var s = fScore[openSet[i]];\n          if (s < tempScore) {\n            tempScore = s;\n            minPos = i;\n          }\n        }\n        return minPos;\n      };\n\n      // Parse options\n      // debug - optional\n      if (options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n\n      logDebug(\"Starting aStar...\"); \n      var cy = this._private.cy;\n\n      // root - mandatory!\n      if (options != null && options.root != null) {        \n        var source = $$.is.string(options.root) ? \n          // use it as a selector, e.g. \"#rootID\n          this.filter(options.root)[0] : \n          options.root[0];\n        logDebug(\"Source node: %s\", source.id()); \n      } else {\n        return undefined;\n      }\n      \n      // goal - mandatory!\n      if (options.goal != null) {       \n        var target = $$.is.string(options.goal) ? \n          // use it as a selector, e.g. \"#goalID\n          this.filter(options.goal)[0] : \n          options.goal[0];\n        logDebug(\"Target node: %s\", target.id()); \n      } else {\n        return undefined;\n      }\n\n      // Heuristic function - optional\n      if (options.heuristic != null && $$.is.fn(options.heuristic)) {       \n        var heuristic = options.heuristic;\n      } else {\n        var heuristic = function(){ return 0; }; // use constant if unspecified\n        // $$.util.error(\"Missing required parameter (heuristic)! Aborting.\");\n        // return;\n      }\n\n      // Weight function - optional\n      if (options.weight != null && $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;};\n      }\n\n      // directed - optional\n      if (options.directed != null) {       \n        var directed = options.directed;\n      } else {\n        var directed = false;\n      }\n\n      var closedSet = [];\n      var openSet = [source.id()];\n      var cameFrom = {};\n      var cameFromEdge = {};\n      var gScore = {};\n      var fScore = {};\n\n      gScore[source.id()] = 0;\n      fScore[source.id()] = heuristic(source);\n      \n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n\n      // Counter\n      var steps = 0;\n\n      // Main loop \n      while (openSet.length > 0) {\n        var minPos = findMin(openSet, fScore);\n        var cMin = this.filter(\"#\" + openSet[minPos])[0];\n        steps++;\n\n        logDebug(\"\\nStep: %s\", steps);\n        logDebug(\"Processing node: %s, fScore = %s\", cMin.id(), fScore[cMin.id()]);\n        \n        // If we've found our goal, then we are done\n        if (cMin.id() == target.id()) {\n          logDebug(\"Found goal node!\");\n          var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);\n          rPath.reverse();\n          logDebug(\"Path: %s\", rPath);\n          return {\n            found : true,\n            distance : gScore[cMin.id()],\n            path : new $$.Collection(cy, rPath),\n            steps : steps\n          };          \n        }\n        \n        // Add cMin to processed nodes\n        closedSet.push(cMin.id());\n        // Remove cMin from boundary nodes\n        openSet.splice(minPos, 1);\n        logDebug(\"Added node to closedSet, removed from openSet.\");\n        logDebug(\"Processing neighbors...\");\n\n        // Update scores for neighbors of cMin\n        // Take into account if graph is directed or not\n        var vwEdges = cMin.connectedEdges(directed ? '[source = \"' + cMin.id() + '\"]' \n                         : undefined).intersect(edges);         \n        for (var i = 0; i < vwEdges.length; i++) {\n          var e = vwEdges[i];\n          var w = e.connectedNodes('[id != \"' + cMin.id() + '\"]').intersect(nodes);\n\n          logDebug(\"   processing neighbor: %s\", w.id());\n          // if node is in closedSet, ignore it\n          if (closedSet.indexOf(w.id()) != -1) {\n            logDebug(\"   already in closedSet, ignoring it.\");\n            continue;\n          }\n          \n          // New tentative score for node w\n          var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);\n          logDebug(\"   tentative gScore: %d\", tempScore);\n\n          // Update gScore for node w if:\n          //   w not present in openSet\n          // OR\n          //   tentative gScore is less than previous value\n\n          // w not in openSet\n          if (openSet.indexOf(w.id()) == -1) {\n            gScore[w.id()] = tempScore;\n            fScore[w.id()] = tempScore + heuristic(w);\n            openSet.push(w.id()); // Add node to openSet\n            cameFrom[w.id()] = cMin.id();\n            cameFromEdge[w.id()] = e.id();\n            logDebug(\"   not in openSet, adding it. \");\n            logDebug(\"   fScore(%s) = %s\", w.id(), tempScore);\n            continue;\n          }\n          // w already in openSet, but with greater gScore\n          if (tempScore < gScore[w.id()]) {\n            gScore[w.id()] = tempScore;\n            fScore[w.id()] = tempScore + heuristic(w);\n            cameFrom[w.id()] = cMin.id();\n            logDebug(\"   better score, replacing gScore. \");\n            logDebug(\"   fScore(%s) = %s\", w.id(), tempScore);\n          }\n\n        } // End of neighbors update\n\n      } // End of main loop\n\n      // If we've reached here, then we've not reached our goal\n      logDebug(\"Reached end of computation without finding our goal\");\n      return {\n        found : false,\n        distance : undefined,\n        path : undefined,\n        steps : steps\n      };\n    }, // aStar()\n\n\n    // Implemented from pseudocode from wikipedia\n    // options => options object\n    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges\n    //   directed // default false\n    // retObj => returned object by function\n    //   pathTo : function(fromId, toId) // Returns the shortest path from node with ID \"fromID\" to node with ID \"toId\", as an array of node IDs\n    //   distanceTo: function(fromId, toId) // Returns the distance of the shortest path from node with ID \"fromID\" to node with ID \"toId\"\n    floydWarshall: function(options) {\n      options = options || {};\n\n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Parse options\n      // debug - optional\n      if (options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting floydWarshall...\"); \n\n      var cy = this._private.cy;\n\n      // Weight function - optional\n      if (options.weight != null && $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;};\n      }\n\n      // directed - optional\n      if (options.directed != null) {       \n        var directed = options.directed;\n      } else {\n        var directed = false;\n      }\n\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n\n      // mapping: node id -> position in nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }     \n\n      // Initialize distance matrix\n      var dist = [];\n      for (var i = 0; i < numNodes; i++) {\n        var newRow = new Array(numNodes);\n        for (var j = 0; j < numNodes; j++) {\n          if (i == j) {\n            newRow[j] = 0;\n          } else {\n            newRow[j] = Infinity;\n          }\n        }\n        dist.push(newRow);\n      }           \n\n      // Initialize matrix used for path reconstruction\n      // Initialize distance matrix\n      var next = [];\n      var edgeNext = [];\n\n      var initMatrix = function(next){\n        for (var i = 0; i < numNodes; i++) {\n          var newRow = new Array(numNodes);\n          for (var j = 0; j < numNodes; j++) {\n            newRow[j] = undefined;\n          }\n          next.push(newRow);\n        }\n      };\n\n      initMatrix(next);\n      initMatrix(edgeNext);\n      \n      // Process edges\n      for (var i = 0; i < edges.length ; i++) {     \n        var sourceIndex = id2position[edges[i].source().id()];\n        var targetIndex = id2position[edges[i].target().id()];    \n        var weight = weightFn.apply(edges[i], [edges[i]]);\n        \n        // Check if already process another edge between same 2 nodes\n        if (dist[sourceIndex][targetIndex] > weight) {\n          dist[sourceIndex][targetIndex] = weight;\n          next[sourceIndex][targetIndex] = targetIndex;\n          edgeNext[sourceIndex][targetIndex] = edges[i];\n        }\n      }\n\n      // If undirected graph, process 'reversed' edges\n      if (!directed) {\n        for (var i = 0; i < edges.length ; i++) {     \n          var sourceIndex = id2position[edges[i].target().id()];    \n          var targetIndex = id2position[edges[i].source().id()];\n          var weight = weightFn.apply(edges[i], [edges[i]]);\n          \n          // Check if already process another edge between same 2 nodes\n          if (dist[sourceIndex][targetIndex] > weight) {\n            dist[sourceIndex][targetIndex] = weight;\n            next[sourceIndex][targetIndex] = targetIndex;\n            edgeNext[sourceIndex][targetIndex] = edges[i];\n          }\n        }\n      }\n\n      // Main loop\n      for (var k = 0; k < numNodes; k++) {\n        for (var i = 0; i < numNodes; i++) {\n          for (var j = 0; j < numNodes; j++) {            \n            if (dist[i][k] + dist[k][j] < dist[i][j]) {\n              dist[i][j] = dist[i][k] + dist[k][j];\n              next[i][j] = next[i][k];\n            }\n          }\n        }\n      }\n\n      // Build result object       \n      var position2id = [];\n      for (var i = 0; i < numNodes; i++) {\n        position2id.push(nodes[i].id());\n      }\n\n      var res = {\n        distance: function(from, to) {\n          if ($$.is.string(from)) {\n            // from is a selector string\n            var fromId = (cy.filter(from)[0]).id();\n          } else {\n            // from is a node\n            var fromId = from.id();\n          }\n\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n\n          return dist[id2position[fromId]][id2position[toId]];\n        },\n\n        path: function(from, to) {\n          var reconstructPathAux = function(from, to, next, position2id, edgeNext) {\n            if (from === to) {\n              return cy.getElementById( position2id[from] );\n            }\n            if (next[from][to] === undefined) {\n              return undefined;\n            }\n\n            var path = [ cy.getElementById(position2id[from]) ];\n            var prev = from;\n            while (from !== to) {\n              prev = from;\n              from = next[from][to];\n\n              var edge = edgeNext[prev][from];\n              path.push( edge );\n\n              path.push( cy.getElementById(position2id[from]) );\n            }\n            return path;\n          };\n\n          if ($$.is.string(from)) {\n            // from is a selector string\n            var fromId = (cy.filter(from)[0]).id();\n          } else {\n            // from is a node\n            var fromId = from.id();\n          }\n\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n          \n          var pathArr = reconstructPathAux(id2position[fromId], \n                        id2position[toId], \n                        next,\n                        position2id,\n                        edgeNext);\n\n          return new $$.Collection( cy, pathArr );\n        },\n      };\n\n      return res;\n\n    }, // floydWarshall\n\n\n    // Implemented from pseudocode from wikipedia\n    // options => options object\n    //   root: starting node (either element or selector string)\n    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges\n    //   directed // default false\n    // retObj => returned object by function\n    //   pathTo : function(toId) // Returns the shortest path from root node to node with ID \"toId\", as an array of node IDs\n    //   distanceTo: function(toId) // Returns the distance of the shortest path from root node to node with ID \"toId\"\n    //   hasNegativeWeightCycle: true/false (if true, pathTo and distanceTo will be undefined)\n    bellmanFord: function(options) {\n      options = options || {};\n\n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Parse options\n      // debug - optional\n      if (options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting bellmanFord...\"); \n\n      // Weight function - optional\n      if (options.weight != null && $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;};\n      }\n\n      // directed - optional\n      if (options.directed != null) {       \n        var directed = options.directed;\n      } else {\n        var directed = false;\n      }\n\n      // root - mandatory!\n      if (options.root != null) {       \n        if ($$.is.string(options.root)) {\n          // use it as a selector, e.g. \"#rootID\n          var source = this.filter(options.root)[0];\n        } else {\n          var source = options.root[0];\n        }\n        logDebug(\"Source node: %s\", source.id()); \n      } else {\n        $$.util.error(\"options.root required\");\n        return undefined;\n      }\n\n      var cy = this._private.cy;\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n\n      // mapping: node id -> position in nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }     \n\n      // Initializations\n      var cost = [];\n      var predecessor = [];\n      var predEdge = [];\n      \n      for (var i = 0; i < numNodes; i++) {\n        if (nodes[i].id() === source.id()) {\n          cost[i] = 0;\n        } else {\n          cost[i] = Infinity;\n        } \n        predecessor[i] = undefined;\n      }\n      \n      // Edges relaxation      \n      var flag = false;\n      for (var i = 1; i < numNodes; i++) {\n        flag = false;\n        for (var e = 0; e < edges.length; e++) {\n          var sourceIndex = id2position[edges[e].source().id()];\n          var targetIndex = id2position[edges[e].target().id()];    \n          var weight = weightFn.apply(edges[e], [edges[e]]);\n          \n          var temp = cost[sourceIndex] + weight;\n          if (temp < cost[targetIndex]) {\n            cost[targetIndex] = temp;\n            predecessor[targetIndex] = sourceIndex;\n            predEdge[targetIndex] = edges[e];\n            flag = true;\n          }\n\n          // If undirected graph, we need to take into account the 'reverse' edge\n          if (!directed) {\n            var temp = cost[targetIndex] + weight;\n            if (temp < cost[sourceIndex]) {\n              cost[sourceIndex] = temp;\n              predecessor[sourceIndex] = targetIndex;\n              predEdge[sourceIndex] = edges[e];\n              flag = true;\n            }\n          }\n        }\n\n        if (!flag) {\n          break;\n        }\n      }      \n            \n      if (flag) {\n        // Check for negative weight cycles\n        for (var e = 0; e < edges.length; e++) {\n          var sourceIndex = id2position[edges[e].source().id()];\n          var targetIndex = id2position[edges[e].target().id()];    \n          var weight = weightFn.apply(edges[e], [edges[e]]);\n          \n          if (cost[sourceIndex] + weight < cost[targetIndex]) {\n            $$.util.error(\"Error: graph contains a negative weigth cycle!\"); \n            return { pathTo: undefined,\n                 distanceTo: undefined,\n                 hasNegativeWeightCycle: true};\n          }\n        }     \n      }\n\n      // Build result object       \n      var position2id = [];\n      for (var i = 0; i < numNodes; i++) {\n        position2id.push(nodes[i].id());\n      }\n      \n      \n      var res = {       \n        distanceTo : function(to) {\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n\n          return cost[id2position[toId]];\n        }, \n\n        pathTo : function(to) {\n\n          var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {\n            for(;;){\n              // Add toId to path\n              acumPath.push( cy.getElementById(position2id[toPos]) );\n              acumPath.push( predEdge[toPos] );\n\n              if (fromPos === toPos) {\n                // reached starting node\n                return acumPath;\n              }\n\n              // If no path exists, discart acumulated path and return undefined\n              var predPos = predecessor[toPos];\n              if (typeof predPos === \"undefined\") {\n                return undefined;\n              }\n\n              toPos = predPos;\n            }\n\n          };\n\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n          var path = [];\n\n          // This returns a reversed path \n          var res =  reconstructPathAux(predecessor, \n                        id2position[source.id()],\n                        id2position[toId], \n                        position2id, \n                        path,\n                        predEdge);\n\n          // Get it in the correct order and return it\n          if (res != null) {\n            res.reverse();\n          }\n\n          return new $$.Collection(cy, res);                       \n        }, \n\n        hasNegativeWeightCycle: false\n      };\n\n      return res;\n\n    }, // bellmanFord\n\n\n    // Computes the minimum cut of an undirected graph\n    // Returns the correct answer with high probability\n    // options => options object\n    // \n    // retObj => returned object by function\n    //   cut : list of IDs of edges in the cut,\n    //   partition1: list of IDs of nodes in one partition\n    //   partition2: list of IDs of nodes in the other partition\n    kargerStein: function(options) {\n      options = options || {};\n      \n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Function which colapses 2 (meta) nodes into one\n      // Updates the remaining edge lists\n      // Receives as a paramater the edge which causes the collapse\n      var colapse = function(edgeIndex, nodeMap, remainingEdges) {\n        var edgeInfo = remainingEdges[edgeIndex];\n        var sourceIn = edgeInfo[1];\n        var targetIn = edgeInfo[2];\n        var partition1 = nodeMap[sourceIn];\n        var partition2 = nodeMap[targetIn];\n\n        // Delete all edges between partition1 and partition2\n        var newEdges = remainingEdges.filter(function(edge) {\n          if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {\n            return false;\n          }\n          if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {\n            return false;\n          }\n          return true;\n        });\n        \n        // All edges pointing to partition2 should now point to partition1\n        for (var i = 0; i < newEdges.length; i++) {\n          var edge = newEdges[i];\n          if (edge[1] === partition2) { // Check source\n            newEdges[i] = edge.slice(0);\n            newEdges[i][1] = partition1;\n          } else if (edge[2] === partition2) { // Check target\n            newEdges[i] = edge.slice(0);\n            newEdges[i][2] = partition1;\n          }\n        } \n        \n        // Move all nodes from partition2 to partition1\n        for (var i = 0; i < nodeMap.length; i++) {\n          if (nodeMap[i] === partition2) {\n            nodeMap[i] = partition1;\n          }\n        }\n        \n        return newEdges;\n      };\n\n\n      // Contracts a graph until we reach a certain number of meta nodes\n      var contractUntil = function(metaNodeMap, \n                     remainingEdges,\n                     size, \n                     sizeLimit) {\n        // Stop condition\n        if (size <= sizeLimit) {\n          return remainingEdges;\n        }\n        \n        // Choose an edge randomly\n        var edgeIndex = Math.floor((Math.random() * remainingEdges.length));\n\n        // Colapse graph based on edge\n        var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);\n        \n        return contractUntil(metaNodeMap, \n                   newEdges, \n                   size - 1, \n                   sizeLimit);        \n      };\n\n\n      // Parse options\n      // debug - optional\n      if (options != null && options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting kargerStein...\"); \n\n      var cy = this._private.cy;\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n      var numEdges = edges.length;\n      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n      var stopSize = Math.floor(numNodes / Math.sqrt(2));\n\n      if (numNodes < 2) {\n        $$.util.error(\"At least 2 nodes are required for KargerSteing algorithm!\"); \n        return undefined;\n      }\n\n      // Create numerical identifiers for each node\n      // mapping: node id -> position in nodes array\n      // for reverse mapping, simply use nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }\n\n      // Now store edge destination as indexes\n      // Format for each edge (edge index, source node index, target node index)\n      var edgeIndexes = [];\n      for (var i = 0; i < numEdges; i++) {\n        var e = edges[i];\n        edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);\n      }\n\n      // We will store the best cut found here\n      var minCutSize = Infinity;\n      var minCut;     \n\n      // Initial meta node partition\n      var originalMetaNode = [];\n      for (var i = 0; i < numNodes; i++) {\n        originalMetaNode.push(i);\n      }\n\n      // Main loop\n      for (var iter = 0; iter <= numIter; iter++) {\n        // Create new meta node partition\n        var metaNodeMap = originalMetaNode.slice(0);\n\n        // Contract until stop point (stopSize nodes)\n        var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);\n        \n        // Create a copy of the colapsed nodes state\n        var metaNodeMap2 = metaNodeMap.slice(0);\n\n        // Run 2 iterations starting in the stop state\n        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n        var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);\n\n        // Is any of the 2 results the best cut so far?\n        if (res1.length <= res2.length && res1.length < minCutSize) {\n          minCutSize = res1.length;\n          minCut = [res1, metaNodeMap];\n        } else if (res2.length <= res1.length && res2.length < minCutSize) {\n          minCutSize = res2.length;\n          minCut = [res2, metaNodeMap2];\n        }\n      } // end of main loop\n\n      \n      // Construct result\n      var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });\n      var partition1 = [];\n      var partition2 = [];\n\n      // traverse metaNodeMap for best cut\n      var witnessNodePartition = minCut[1][0];\n      for (var i = 0; i < minCut[1].length; i++) { \n        var partitionId = minCut[1][i]; \n        if (partitionId === witnessNodePartition) {\n          partition1.push(nodes[i]);\n        } else {\n          partition2.push(nodes[i]);\n        }       \n      }\n      \n      var ret = {\n        cut: new $$.Collection(cy, resEdges),\n        partition1: new $$.Collection(cy, partition1),\n        partition2: new $$.Collection(cy, partition2)\n      };\n      \n      return ret;\n    },\n\n\n    // \n    // options => options object\n    //   dampingFactor: optional\n    //   precision: optional\n    //   iterations : optional\n    // retObj => returned object by function\n    //  rank : function that returns the pageRank of a given node (object or selector string)\n    pageRank: function(options) {\n      options = options || {};\n      \n      var normalizeVector = function(vector) {\n        var length = vector.length;\n\n        // First, get sum of all elements\n        var total = 0; \n        for (var i = 0; i < length; i++) {\n          total += vector[i];\n        }\n\n        // Now, divide each by the sum of all elements\n        for (var i = 0; i < length; i++) {\n          vector[i] = vector[i] / total;\n        }\n      };\n      \n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n      \n      // Parse options\n      // debug - optional\n      if (options != null && \n        options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting pageRank...\"); \n\n      // dampingFactor - optional\n      if (options != null && \n        options.dampingfactor != null) {\n        var dampingFactor = options.dampingFactor;\n      } else {\n        var dampingFactor = 0.8; // Default damping factor\n      }\n\n      // desired precision - optional\n      if (options != null && \n        options.precision != null) {\n        var epsilon = options.precision;\n      } else {\n        var epsilon = 0.000001; // Default precision\n      }\n\n      // Max number of iterations - optional\n      if (options != null && \n        options.iterations != null) {\n        var numIter = options.iterations;\n      } else {\n        var numIter = 200; // Default number of iterations\n      }\n\n      // Weight function - optional\n      if (options != null && \n        options.weight != null && \n        $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;}; \n      }\n\n      var cy = this._private.cy;\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n      var numEdges = edges.length;\n\n      // Create numerical identifiers for each node\n      // mapping: node id -> position in nodes array\n      // for reverse mapping, simply use nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }\n\n      // Construct transposed adjacency matrix\n      // First lets have a zeroed matrix of the right size\n      // We'll also keep track of the sum of each column\n      var matrix = [];\n      var columnSum = [];\n      var additionalProb = (1 - dampingFactor) / numNodes;\n\n      // Create null matric\n      for (var i = 0; i < numNodes; i++) { \n        var newRow = [];\n        for (var j = 0; j < numNodes; j++) {\n          newRow.push(0.0);\n        }\n        matrix.push(newRow);\n        columnSum.push(0.0);\n      }\n\n      // Now, process edges\n      for (var i = 0; i < numEdges; i++) {\n        var edge = edges[i];\n        var s = id2position[edge.source().id()];\n        var t = id2position[edge.target().id()];\n        var w = weightFn.apply(edge, [edge]);\n        \n        // Update matrix\n        matrix[t][s] += w;\n\n        // Update column sum\n        columnSum[s] += w; \n      }\n\n      // Add additional probability based on damping factor\n      // Also, take into account columns that have sum = 0\n      var p = 1.0 / numNodes + additionalProb; // Shorthand\n      // Traverse matrix, column by column\n      for (var j = 0; j < numNodes; j++) { \n        if (columnSum[j] === 0) {\n          // No 'links' out from node jth, assume equal probability for each possible node\n          for (var i = 0; i < numNodes; i++) {\n            matrix[i][j] = p;\n          }\n        } else {\n          // Node jth has outgoing link, compute normalized probabilities\n          for (var i = 0; i < numNodes; i++) {\n            matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;\n          }         \n        }\n      }\n\n      // Compute dominant eigenvector using power method\n      var eigenvector = [];\n      var nullVector = [];\n      var previous;\n\n      // Start with a vector of all 1's\n      // Also, initialize a null vector which will be used as shorthand\n      for (var i = 0; i < numNodes; i++) {\n        eigenvector.push(1.0);\n        nullVector.push(0.0);\n      }\n            \n      for (var iter = 0; iter < numIter; iter++) {\n        // New array with all 0's\n        var temp = nullVector.slice(0);\n        \n        // Multiply matrix with previous result\n        for (var i = 0; i < numNodes; i++) {\n          for (var j = 0; j < numNodes; j++) {        \n            temp[i] += matrix[i][j] * eigenvector[j];\n          }\n        }\n\n        normalizeVector(temp);\n        previous = eigenvector;\n        eigenvector = temp;\n\n        var diff = 0;\n        // Compute difference (squared module) of both vectors\n        for (var i = 0; i < numNodes; i++) {\n          diff += Math.pow(previous[i] - eigenvector[i], 2);\n        }\n        \n        // If difference is less than the desired threshold, stop iterating\n        if (diff < epsilon) {\n          logDebug(\"Stoped at iteration %s\", iter);\n          break;\n        }\n      }\n            \n      logDebug(\"Result:\\n\" + eigenvector);\n\n      // Construct result\n      var res = {\n        rank : function(node) {\n          if ($$.is.string(node)) {\n            // is a selector string\n            var nodeId = (cy.filter(node)[0]).id();\n          } else {\n            // is a node object\n            var nodeId = node.id();\n          }\n          return eigenvector[id2position[nodeId]];\n        }\n      };\n\n\n      return res;\n    } // pageRank\n\n  }); // $$.fn.eles\n\n\n}) (cytoscape);\n;(function( $$ ){ 'use strict';\n\n  $$.fn.eles({\n    animated: $$.define.animated(),\n    clearQueue: $$.define.clearQueue(),\n    delay: $$.define.delay(),\n    animate: $$.define.animate(),\n    stop: $$.define.stop()\n  });\n  \n})( cytoscape );  \n\n;(function( $$ ){ 'use strict';\n  \n  $$.fn.eles({\n    classes: function(opts){\n      var eles = this;\n      var changed = [];\n      var fn;\n\n      if( $$.is.fn(opts) ){\n        fn = opts;\n\n      } else if( !$$.is.plainObject(opts) ){\n        return this; // needs opts or fn\n      } \n\n      for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var eleChanged = false;\n\n        opts = fn ? fn.apply(ele, [i, ele]) : opts;\n\n        // add classes\n        if( opts.add ){ for( var j = 0; j < opts.add.length; j++ ){\n          var cls = opts.add[j];\n          var hasClass = ele._private.classes[cls];\n\n          ele._private.classes[cls] = true;\n\n          if( !hasClass && !eleChanged ){\n            changed.push( ele );\n            eleChanged = true;\n          }\n        } }\n\n        // remove classes\n        if( opts.remove ){ for( var j = 0; j < opts.remove.length; j++ ){\n          var cls = opts.remove[j];\n          var hasClass = ele._private.classes[cls];\n\n          ele._private.classes[cls] = false;\n\n          if( hasClass && !eleChanged ){\n            changed.push( ele );\n            eleChanged = true;\n          }\n        } }\n\n        // toggle classes\n        if( opts.toggle ){ for( var j = 0; j < opts.toggle.length; j++ ){\n          var cls = opts.toggle[j];\n          var hasClass = ele._private.classes[cls];\n\n          ele._private.classes[cls] = !hasClass;\n\n          if( !eleChanged ){\n            changed.push( ele );\n            eleChanged = true;\n          }\n        } }\n      }\n\n      if( changed.length > 0 ){\n        new $$.Collection( this.cy(), changed )\n          .updateStyle()\n          .trigger('class')\n        ;\n      }\n\n      return this;\n    },\n\n    addClass: function(classes){\n      classes = classes.split(/\\s+/);\n      var self = this;\n      var changed = [];\n      \n      for( var i = 0; i < classes.length; i++ ){\n        var cls = classes[i];\n        if( $$.is.emptyString(cls) ){ continue; }\n        \n        for( var j = 0; j < self.length; j++ ){\n          var ele = self[j];\n          var hasClass = ele._private.classes[cls];\n          ele._private.classes[cls] = true;\n\n          if( !hasClass ){ // if didn't already have, add to list of changed\n            changed.push( ele );\n          }\n        }\n      }\n      \n      // trigger update style on those eles that had class changes\n      if( changed.length > 0 ){\n        new $$.Collection(this._private.cy, changed)\n          .updateStyle()\n          .trigger('class')\n        ;\n      }\n\n      return self;\n    },\n\n    hasClass: function(className){\n      var ele = this[0];\n      return ( ele != null && ele._private.classes[className] ) ? true : false;\n    },\n\n    toggleClass: function(classesStr, toggle){\n      var classes = classesStr.split(/\\s+/);\n      var self = this;\n      var changed = []; // eles who had classes changed\n      \n      for( var i = 0, il = self.length; i < il; i++ ){\n        var ele = self[i];\n\n        for( var j = 0; j < classes.length; j++ ){\n          var cls = classes[j];\n\n          if( $$.is.emptyString(cls) ){ continue; }\n          \n          var hasClass = ele._private.classes[cls];\n          var shouldAdd = toggle || (toggle === undefined && !hasClass);\n\n          if( shouldAdd ){\n            ele._private.classes[cls] = true;\n\n            if( !hasClass ){ changed.push(ele); }\n          } else { // then remove\n            ele._private.classes[cls] = false;\n\n            if( hasClass ){ changed.push(ele); }\n          }\n\n        } // for j classes\n      } // for i eles\n      \n      // trigger update style on those eles that had class changes\n      if( changed.length > 0 ){\n        new $$.Collection(this._private.cy, changed)\n          .updateStyle()\n          .trigger('class')\n        ;\n      }\n\n      return self;\n    },\n\n    removeClass: function(classes){\n      classes = classes.split(/\\s+/);\n      var self = this;\n      var changed = [];\n\n      for( var i = 0; i < self.length; i++ ){\n        var ele = self[i];\n\n        for( var j = 0; j < classes.length; j++ ){\n          var cls = classes[j];\n          if( !cls || cls === '' ){ continue; }\n\n          var hasClass = ele._private.classes[cls];\n          ele._private.classes[cls] = undefined;\n\n          if( hasClass ){ // then we changed its set of classes\n            changed.push( ele );\n          }\n        }\n      }\n      \n      // trigger update style on those eles that had class changes\n      if( changed.length > 0 ){\n        new $$.Collection(self._private.cy, changed).updateStyle();\n      }\n\n      self.trigger('class');\n      return self;\n    },\n\n    flashClass: function(classes, duration){\n      var self = this;\n\n      if( duration == null ){\n        duration = 250;\n      } else if( duration === 0 ){\n        return self; // nothing to do really\n      }\n\n      self.addClass( classes );\n      setTimeout(function(){\n        self.removeClass( classes );\n      }, duration);\n\n      return self;\n    }\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n    allAre: function( selector ){\n      return this.filter(selector).length === this.length;\n    },\n\n    is: function( selector ){\n      return this.filter(selector).length > 0;\n    },\n\n    some: function( fn, thisArg ){\n      for( var i = 0; i < this.length; i++ ){\n        var ret = fn.apply( thisArg, [ this[i], i, this ] );\n\n        if( ret ){\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    every: function( fn, thisArg ){\n      for( var i = 0; i < this.length; i++ ){\n        var ret = fn.apply( thisArg, [ this[i], i, this ] );\n\n        if( !ret ){\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    same: function( collection ){\n      collection = this.cy().collection( collection );\n\n      // cheap extra check\n      if( this.length !== collection.length ){\n        return false;\n      }\n\n      return this.intersect( collection ).length === this.length;\n    },\n\n    anySame: function( collection ){\n      collection = this.cy().collection( collection );\n\n      return this.intersect( collection ).length > 0;\n    },\n\n    allAreNeighbors: function( collection ){\n      collection = this.cy().collection( collection );\n\n      return this.neighborhood().intersect( collection ).length === collection.length;\n    }\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // Compound functions\n  /////////////////////\n\n  $$.fn.eles({\n    parent: function( selector ){\n      var parents = [];\n      var cy = this._private.cy;\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        var parent = cy.getElementById( ele._private.data.parent );\n\n        if( parent.size() > 0 ){\n          parents.push( parent );\n        }\n      }\n      \n      return new $$.Collection( cy, parents, { unique: true } ).filter( selector );\n    },\n\n    parents: function( selector ){\n      var parents = [];\n\n      var eles = this.parent();\n      while( eles.nonempty() ){\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n          parents.push( ele );\n        }\n\n        eles = eles.parent();\n      }\n\n      return new $$.Collection( this.cy(), parents, { unique: true } ).filter( selector );\n    },\n\n    commonAncestors: function( selector ){\n      var ancestors;\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        var parents = ele.parents();\n        \n        ancestors = ancestors || parents;\n\n        ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set\n      }\n\n      return ancestors.filter( selector );\n    },\n\n    orphans: function( selector ){\n      return this.stdFilter(function( ele ){\n        return ele.isNode() && ele.parent().empty();\n      }).filter( selector );\n    },\n\n    nonorphans: function( selector ){\n      return this.stdFilter(function( ele ){\n        return ele.isNode() && ele.parent().nonempty();\n      }).filter( selector );\n    },\n\n    children: function( selector ){\n      var children = [];\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        children = children.concat( ele._private.children );\n      }\n\n      return new $$.Collection( this.cy(), children, { unique: true } ).filter( selector );\n    },\n\n    siblings: function( selector ){\n      return this.parent().children().not( this ).filter( selector );\n    },\n\n    isParent: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.children.length !== 0;\n      }\n    },\n\n    isChild: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.data.parent !== undefined && ele.parent().length !== 0;\n      }\n    },\n\n    descendants: function( selector ){\n      var elements = [];\n\n      function add( eles ){\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          elements.push( ele );\n\n          if( ele.children().nonempty() ){\n            add( ele.children() );\n          }\n        }\n      }\n\n      add( this.children() );\n\n      return new $$.Collection( this.cy(), elements, { unique: true } ).filter( selector );\n    }\n  });\n\n  // aliases\n  $$.elesfn.ancestors = $$.elesfn.parents;\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  var borderWidthMultiplier = 2 * 0.5;\n  var borderWidthAdjustment = 0;\n\n  $$.fn.eles({\n\n    data: $$.define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n\n    removeData: $$.define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n\n    scratch: $$.define.data({\n      field: 'scratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n\n    removeScratch: $$.define.removeData({\n      field: 'scratch',\n      triggerEvent: false\n    }),\n\n    rscratch: $$.define.data({\n      field: 'rscratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n\n    removeRscratch: $$.define.removeData({\n      field: 'rscratch',\n      triggerEvent: false\n    }),\n\n    id: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.data.id;\n      }\n    },\n\n    position: $$.define.data({\n      field: 'position',\n      bindingEvent: 'position',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'position',\n      settingTriggersEvent: true,\n      triggerFnName: 'rtrigger',\n      allowGetting: true,\n      validKeys: ['x', 'y'],\n      onSet: function( eles ){\n        var updatedEles = eles.updateCompoundBounds();\n        updatedEles.rtrigger('position');\n      },\n      canSet: function( ele ){\n        return !ele.locked();\n      }\n    }),\n\n    // position but no notification to renderer\n    silentPosition: $$.define.data({\n      field: 'position',\n      bindingEvent: 'position',\n      allowBinding: false,\n      allowSetting: true,\n      settingEvent: 'position',\n      settingTriggersEvent: false,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      validKeys: ['x', 'y'],\n      onSet: function( eles ){\n        eles.updateCompoundBounds();\n      },\n      canSet: function( ele ){\n        return !ele.locked();\n      }\n    }),\n\n    positions: function( pos, silent ){\n      if( $$.is.plainObject(pos) ){\n        this.position(pos);\n        \n      } else if( $$.is.fn(pos) ){\n        var fn = pos;\n        \n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n\n          var pos = fn.apply(ele, [i, ele]);\n\n          if( pos && !ele.locked() ){\n            var elePos = ele._private.position;\n            elePos.x = pos.x;\n            elePos.y = pos.y;\n          }\n        }\n\n        var updatedEles = this.updateCompoundBounds();\n        var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;\n\n        if( silent ){\n          toTrigger.trigger('position');\n        } else {\n          toTrigger.rtrigger('position');\n        }\n      }\n\n      return this; // chaining\n    },\n\n    silentPositions: function( pos ){\n      return this.positions( pos, true );\n    },\n\n    updateCompoundBounds: function(){\n      var cy = this.cy();\n\n      if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled\n\n      var updated = [];\n\n      function update( parent ){\n        var children = parent.children();\n        var style = parent._private.style;\n        var bb = children.boundingBox({ includeLabels: false, includeEdges: false });\n        var padding = {\n          top: style['padding-top'].pxValue,\n          bottom: style['padding-bottom'].pxValue,\n          left: style['padding-left'].pxValue,\n          right: style['padding-right'].pxValue\n        };\n        var pos = parent._private.position;\n        var didUpdate = false;\n\n        if( style['width'].value === 'auto' ){\n          parent._private.autoWidth = bb.w + padding.left + padding.right;\n          pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;\n          didUpdate = true;\n        }\n\n        if( style['height'].value === 'auto' ){\n          parent._private.autoHeight = bb.h + padding.top + padding.bottom;\n          pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;\n          didUpdate = true;\n        }\n\n        if( didUpdate ){\n          updated.push( parent );\n        }\n      }\n\n      // go up, level by level\n      var eles = this.parent();\n      while( eles.nonempty() ){\n\n        // update each parent node in this level\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          update( ele );\n        }\n\n        // next level\n        eles = eles.parent();\n      }\n\n      // return changed\n      return new $$.Collection( cy, updated );\n    },\n\n    // get/set the rendered (i.e. on screen) positon of the element\n    renderedPosition: function( dim, val ){\n      var ele = this[0];\n      var cy = this.cy();\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var rpos = $$.is.plainObject( dim ) ? dim : undefined;\n      var setting = rpos !== undefined || ( val !== undefined && $$.is.string(dim) );\n\n      if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n        if( setting ){\n          for( var i = 0; i < this.length; i++ ){\n            var ele = this[i];\n\n            if( val !== undefined ){ // set one dimension\n              ele._private.position[dim] = ( val - pan[dim] )/zoom;\n            } else if( rpos !== undefined ){ // set whole position\n              ele._private.position = {\n                x: ( rpos.x - pan.x ) /zoom,\n                y: ( rpos.y - pan.y ) /zoom\n              };\n            }\n          }\n\n          this.rtrigger('position');\n        } else { // getting\n          var pos = ele._private.position;\n          rpos = {\n            x: pos.x * zoom + pan.x,\n            y: pos.y * zoom + pan.y\n          };\n\n          if( dim === undefined ){ // then return the whole rendered position\n            return rpos;\n          } else { // then return the specified dimension\n            return rpos[ dim ];\n          }\n        }\n      } else if( !setting ){\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    },\n\n    // get/set the position relative to the parent\n    parentPosition: function( dim, val ){\n      var ele = this[0];\n      var cy = this.cy();\n      var ppos = $$.is.plainObject( dim ) ? dim : undefined;\n      var setting = ppos !== undefined || ( val !== undefined && $$.is.string(dim) );\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n        if( setting ){\n          for( var i = 0; i < this.length; i++ ){\n            var ele = this[i];\n            var parent = hasCompoundNodes ? ele.parent() : null;\n            var hasParent = parent && parent.length > 0;\n            var relativeToParent = hasParent;\n\n            if( hasParent ){\n              parent = parent[0];\n            }\n\n            var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\n            if( val !== undefined ){ // set one dimension\n              ele._private.position[dim] = val + origin[dim];\n            } else if( ppos !== undefined ){ // set whole position\n              ele._private.position = {\n                x: ppos.x + origin.x,\n                y: ppos.y + origin.y,\n              };\n            }\n          }\n\n          this.rtrigger('position');\n\n        } else { // getting\n          var pos = ele._private.position;\n          var parent = hasCompoundNodes ? ele.parent() : null;\n          var hasParent = parent && parent.length > 0;\n          var relativeToParent = hasParent;\n\n          if( hasParent ){\n            parent = parent[0];\n          }\n\n          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\n          ppos = {\n            x: pos.x - origin.x,\n            y: pos.y - origin.y\n          };\n\n          if( dim === undefined ){ // then return the whole rendered position\n            return ppos;\n          } else { // then return the specified dimension\n            return ppos[ dim ];\n          }\n        }\n      } else if( !setting ){\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    },\n\n    // convenience function to get a numerical value for the width of the node/edge\n    width: function(){\n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele ){\n        if( styleEnabled ){\n          var w = ele._private.style.width;\n          return w.strValue === 'auto' ? ele._private.autoWidth : w.pxValue;\n        } else {\n          return 1;\n        }\n      }\n    },\n\n    outerWidth: function(){\n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele ){\n        if( styleEnabled ){\n          var style = ele._private.style;\n          var width = style.width.strValue === 'auto' ? ele._private.autoWidth : style.width.pxValue;\n          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;\n\n          return width + border;\n        } else {\n          return 1;\n        }\n      }\n    },\n\n    renderedWidth: function(){\n      var ele = this[0];\n\n      if( ele ){\n        var width = ele.width();\n        return width * this.cy().zoom();\n      }\n    },\n\n    renderedOuterWidth: function(){\n      var ele = this[0];\n\n      if( ele ){\n        var owidth = ele.outerWidth();\n        return owidth * this.cy().zoom();\n      }\n    },\n\n    // convenience function to get a numerical value for the height of the node\n    height: function(){ \n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele && ele._private.group === 'nodes' ){\n        if( styleEnabled ){\n          var h = ele._private.style.height;\n          return h.strValue === 'auto' ? ele._private.autoHeight : h.pxValue;\n        } else {\n          return 1;\n        }\n      }\n    },\n\n    outerHeight: function(){\n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele && ele._private.group === 'nodes' ){\n        if( styleEnabled ){\n          var style = ele._private.style;\n          var height = style.height.strValue === 'auto' ? ele._private.autoHeight : style.height.pxValue;\n          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;\n        } else {\n          return 1;\n        }\n\n        return height + border;\n      }\n    },\n\n    renderedHeight: function(){\n      var ele = this[0];\n\n      if( ele && ele._private.group === 'nodes' ){\n        var height = ele.height();\n        return height * this.cy().zoom();\n      }\n    },\n\n    renderedOuterHeight: function(){\n      var ele = this[0];\n\n      if( ele && ele._private.group === 'nodes' ){\n        var oheight = ele.outerHeight();\n        return oheight * this.cy().zoom();\n      }\n    },\n\n    renderedBoundingBox: function( options ){\n      var bb = this.boundingBox( options );\n      var cy = this.cy();\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n\n      var x1 = bb.x1 * zoom + pan.x;\n      var x2 = bb.x2 * zoom + pan.x;\n      var y1 = bb.y1 * zoom + pan.y;\n      var y2 = bb.y2 * zoom + pan.y;\n\n      return {\n        x1: x1,\n        x2: x2,\n        y1: y1,\n        y2: y2,\n        w: x2 - x1,\n        h: y2 - y1\n      };\n    },\n\n    // get the bounding box of the elements (in raw model position)\n    boundingBox: function( options ){\n      var eles = this;\n      var cy = eles._private.cy;\n      var cy_p = cy._private;\n      var styleEnabled = cy_p.styleEnabled;\n\n      options = options || {};\n\n      var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;\n      var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;\n      var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;\n\n      // recalculate projections etc\n      if( styleEnabled ){\n        cy_p.renderer.recalculateRenderedStyle( this );\n      }\n\n      var x1 = Infinity;\n      var x2 = -Infinity;\n      var y1 = Infinity;\n      var y2 = -Infinity;\n\n      // find bounds of elements\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var _p = ele._private;\n        var display = styleEnabled ? _p.style['display'].value : 'element';\n        var isNode = _p.group === 'nodes';\n        var ex1, ex2, ey1, ey2, x, y;\n        var includedEle = false;\n\n        if( display === 'none' ){ continue; } // then ele doesn't take up space      \n\n        if( isNode && includeNodes ){\n          includedEle = true;\n\n          var pos = _p.position;\n          x = pos.x;\n          y = pos.y;\n          var w = ele.outerWidth();\n          var halfW = w/2;\n          var h = ele.outerHeight();\n          var halfH = h/2;\n\n          // handle node dimensions\n          /////////////////////////\n\n          ex1 = x - halfW;\n          ex2 = x + halfW;\n          ey1 = y - halfH;\n          ey2 = y + halfH;\n\n          x1 = ex1 < x1 ? ex1 : x1;\n          x2 = ex2 > x2 ? ex2 : x2;\n          y1 = ey1 < y1 ? ey1 : y1;\n          y2 = ey2 > y2 ? ey2 : y2;\n\n        } else if( ele.isEdge() && includeEdges ){ \n          includedEle = true;\n\n          var n1pos = ele._private.source._private.position;\n          var n2pos = ele._private.target._private.position;\n\n          // handle edge dimensions (rough box estimate)\n          //////////////////////////////////////////////\n\n          var rstyle = ele._private.rstyle || {};\n\n          ex1 = n1pos.x;\n          ex2 = n2pos.x;\n          ey1 = n1pos.y;\n          ey2 = n2pos.y;\n\n          if( ex1 > ex2 ){\n            var temp = ex1;\n            ex1 = ex2;\n            ex2 = temp;\n          }\n\n          if( ey1 > ey2 ){\n            var temp = ey1;\n            ey1 = ey2;\n            ey2 = temp;\n          }\n\n          x1 = ex1 < x1 ? ex1 : x1;\n          x2 = ex2 > x2 ? ex2 : x2;\n          y1 = ey1 < y1 ? ey1 : y1;\n          y2 = ey2 > y2 ? ey2 : y2;\n\n          // handle points along edge (sanity check)\n          //////////////////////////////////////////\n\n          if( styleEnabled ){\n            var bpts = rstyle.bezierPts || [];\n\n            var w = ele._private.style['width'].pxValue;\n            var wHalf = w/2;\n\n            for( var j = 0; j < bpts.length; j++ ){\n              var bpt = bpts[j];\n\n              ex1 = bpt.x - wHalf;\n              ex2 = bpt.x + wHalf;\n              ey1 = bpt.y - wHalf;\n              ey2 = bpt.y + wHalf;\n\n              x1 = ex1 < x1 ? ex1 : x1;\n              x2 = ex2 > x2 ? ex2 : x2;\n              y1 = ey1 < y1 ? ey1 : y1;\n              y2 = ey2 > y2 ? ey2 : y2;\n            }\n          }\n\n        } // edges\n\n        // handle label dimensions\n        //////////////////////////\n\n        if( styleEnabled ){\n\n          var style = ele._private.style;\n          var rstyle = ele._private.rstyle;\n          var label = style['content'].strValue;\n          var fontSize = style['font-size'];\n          var halign = style['text-halign'];\n          var valign = style['text-valign'];\n          var labelWidth = rstyle.labelWidth;\n          var labelHeight = rstyle.labelHeight;\n          var labelX = rstyle.labelX;\n          var labelY = rstyle.labelY;\n\n          if( includedEle && includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){\n            var lh = labelHeight;\n            var lw = labelWidth;\n            var lx1, lx2, ly1, ly2;\n\n            if( ele.isEdge() ){\n              lx1 = labelX - lw/2;\n              lx2 = labelX + lw/2;\n              ly1 = labelY - lh/2;\n              ly2 = labelY + lh/2;\n            } else {\n              switch( halign.value ){\n                case 'left':\n                  lx1 = labelX - lw;\n                  lx2 = labelX;\n                  break;\n\n                case 'center':\n                  lx1 = labelX - lw/2;\n                  lx2 = labelX + lw/2;\n                  break;\n\n                case 'right':\n                  lx1 = labelX;\n                  lx2 = labelX + lw;\n                  break;\n              }\n\n              switch( valign.value ){\n                case 'top':\n                  ly1 = labelY - lh;\n                  ly2 = labelY;\n                  break;\n\n                case 'center':\n                  ly1 = labelY - lh/2;\n                  ly2 = labelY + lh/2;\n                  break;\n\n                case 'bottom':\n                  ly1 = labelY;\n                  ly2 = labelY + lh;\n                  break;\n              }\n            }\n\n            x1 = lx1 < x1 ? lx1 : x1;\n            x2 = lx2 > x2 ? lx2 : x2;\n            y1 = ly1 < y1 ? ly1 : y1;\n            y2 = ly2 > y2 ? ly2 : y2;\n          }\n        } // style enabled\n      } // for\n\n      return {\n        x1: x1,\n        x2: x2,\n        y1: y1,\n        y2: y2,\n        w: x2 - x1,\n        h: y2 - y1\n      };\n    }\n  }); \n\n  // in case some users want to be explicit\n  $$.elesfn.modelPosition = $$.elesfn.position;\n  $$.elesfn.modelPositions = $$.elesfn.positions;\n  \n})( cytoscape );\n\n;(function( $$ ){ 'use strict';\n  \n  // Regular degree functions (works on single element)\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  function defineDegreeFunction(callback){\n    return function( includeLoops ){\n      var self = this;\n\n      if( includeLoops === undefined ){\n        includeLoops = true;\n      }\n      \n      if( self.length === 0 ){ return; }\n\n      if( self.isNode() && !self.removed() ){\n        var degree = 0;\n        var node = self[0];\n        var connectedEdges = node._private.edges;\n\n        for( var i = 0; i < connectedEdges.length; i++ ){\n          var edge = connectedEdges[i];\n\n          if( !includeLoops && edge.isLoop() ){\n            continue;\n          }\n\n          degree += callback( node, edge );\n        }\n        \n        return degree;\n      } else {\n        return;\n      }\n    };\n  }\n  \n  $$.fn.eles({\n    degree: defineDegreeFunction(function(node, edge){\n      if( edge.source().same( edge.target() ) ){\n        return 2;\n      } else {\n        return 1;\n      }\n    }),\n\n    indegree: defineDegreeFunction(function(node, edge){\n      if( edge.target().same(node) ){\n        return 1;\n      } else {\n        return 0;\n      }\n    }),\n\n    outdegree: defineDegreeFunction(function(node, edge){\n      if( edge.source().same(node) ){\n        return 1;\n      } else {\n        return 0;\n      }\n    })\n  });\n  \n  \n  // Collection degree stats\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  function defineDegreeBoundsFunction(degreeFn, callback){\n    return function( includeLoops ){\n      var ret;\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){\n        var ele = nodes[i];\n        var degree = ele[degreeFn]( includeLoops );\n        if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){\n          ret = degree;\n        }\n      }\n      \n      return ret;\n    };\n  }\n  \n  $$.fn.eles({\n    minDegree: defineDegreeBoundsFunction('degree', function(degree, min){\n      return degree < min;\n    }),\n\n    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){\n      return degree > max;\n    }),\n\n    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){\n      return degree < min;\n    }),\n\n    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){\n      return degree > max;\n    }),\n\n    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){\n      return degree < min;\n    }),\n\n    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){\n      return degree > max;\n    })\n  });\n  \n  $$.fn.eles({\n    totalDegree: function( includeLoops ){\n      var total = 0;\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){\n        total += nodes[i].degree( includeLoops );\n      }\n\n      return total;\n    }\n  });\n  \n})( cytoscape );\n\n  \n;(function($$){ 'use strict';\n  \n  // Functions for binding & triggering events\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  $$.fn.eles({\n    on: $$.define.on(), // .on( events [, selector] [, data], handler)\n    one: $$.define.on({ unbindSelfOnTrigger: true }),\n    once: $$.define.on({ unbindAllBindersOnTrigger: true }),\n    off: $$.define.off(), // .off( events [, selector] [, handler] )\n    trigger: $$.define.trigger(), // .trigger( events [, extraParams] )\n\n    rtrigger: function(event, extraParams){ // for internal use only\n      if( this.length === 0 ){ return; } // empty collections don't need to notify anything\n\n      // notify renderer\n      this.cy().notify({\n        type: event,\n        collection: this\n      });\n      \n      this.trigger(event, extraParams);\n      return this;\n    }\n  });\n\n  // aliases for those folks who like old stuff:\n  $$.elesfn.bind = $$.elesfn.on;\n  $$.elesfn.unbind = $$.elesfn.off;\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n    nodes: function( selector ){\n      return this.filter(function(i, element){\n        return element.isNode();\n      }).filter(selector);\n    },\n\n    edges: function( selector ){\n      return this.filter(function(i, element){\n        return element.isEdge();\n      }).filter(selector);\n    },\n\n    filter: function( filter ){\n      var cy = this._private.cy;\n      \n      if( $$.is.fn(filter) ){\n        var elements = [];\n\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n\n          if( filter.apply(ele, [i, ele]) ){\n            elements.push(ele);\n          }\n        }\n        \n        return new $$.Collection(cy, elements);\n      \n      } else if( $$.is.string(filter) || $$.is.elementOrCollection(filter) ){\n        return new $$.Selector(filter).filter(this);\n      \n      } else if( filter === undefined ){\n        return this;\n      }\n\n      return new $$.Collection( cy ); // if not handled by above, give 'em an empty collection\n    },\n\n    not: function( toRemove ){\n      var cy = this._private.cy;\n\n      if( !toRemove ){\n        return this;\n      } else {\n      \n        if( $$.is.string( toRemove ) ){\n          toRemove = this.filter( toRemove );\n        }\n        \n        var elements = [];\n        \n        for( var i = 0; i < this.length; i++ ){\n          var element = this[i];\n\n          var remove = toRemove._private.ids[ element.id() ];\n          if( !remove ){\n            elements.push( element );\n          }\n        }\n        \n        return new $$.Collection( cy, elements );\n      }\n      \n    },\n\n    intersect: function( other ){\n      var cy = this._private.cy;\n      \n      // if a selector is specified, then filter by it instead\n      if( $$.is.string(other) ){\n        var selector = other;\n        return this.filter( selector );\n      }\n      \n      var elements = [];\n      var col1 = this;\n      var col2 = other;\n      var col1Smaller = this.length < other.length;\n      // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;\n      var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;\n      var col = col1Smaller ? col1 : col2;\n      \n      for( var i = 0; i < col.length; i++ ){\n        var id = col[i]._private.data.id;\n        var ele = ids2[ id ];\n\n        if( ele ){\n          elements.push( ele );\n        }\n      }\n      \n      return new $$.Collection( cy, elements );\n    },\n\n    add: function( toAdd ){\n      var cy = this._private.cy;    \n      \n      if( !toAdd ){\n        return this;\n      }\n      \n      if( $$.is.string(toAdd) ){\n        var selector = toAdd;\n        toAdd = cy.elements(selector);\n      }\n      \n      var elements = [];\n\n      for( var i = 0; i < this.length; i++ ){\n        elements.push( this[i] );\n      }\n\n      for( var i = 0; i < toAdd.length; i++ ){\n\n        var add = !this._private.ids[ toAdd[i].id() ];\n        if( add ){\n          elements.push( toAdd[i] );\n        }\n      }\n      \n      return new $$.Collection(cy, elements);\n    },\n\n    // in place merge on calling collection\n    merge: function( toAdd ){\n      var _p = this._private;\n      var cy = _p.cy;    \n      \n      if( !toAdd ){\n        return this;\n      }\n      \n      if( $$.is.string(toAdd) ){\n        var selector = toAdd;\n        toAdd = cy.elements(selector);\n      }\n\n      for( var i = 0; i < toAdd.length; i++ ){\n        var toAddEle = toAdd[i];\n        var id = toAddEle.id();\n        var add = !_p.ids[ id ];\n\n        if( add ){\n          var index = this.length++;\n\n          this[ index ] = toAddEle;\n          _p.ids[ id ] = toAddEle;\n          _p.indexes[ id ] = index;\n        }\n      }\n      \n      return this; // chaining\n    },\n\n    // remove single ele in place in calling collection\n    unmergeOne: function( ele ){\n      ele = ele[0];\n\n      var _p = this._private;\n      var id = ele.id();\n      var i = _p.indexes[ id ];\n\n      if( i == null ){\n        return this; // no need to remove\n      }\n\n      // remove ele\n      this[i] = undefined;\n      _p.ids[ id ] = undefined;\n      _p.indexes[ id ] = undefined;\n\n      var unmergedLastEle = i === this.length - 1;\n\n      // replace empty spot with last ele in collection\n      if( this.length > 1 && !unmergedLastEle ){\n        var lastEleI = this.length - 1;\n        var lastEle = this[ lastEleI ];\n\n        this[ lastEleI ] = undefined;\n        this[i] = lastEle;\n        _p.indexes[ lastEle.id() ] = i;\n      }\n\n      // the collection is now 1 ele smaller\n      this.length--;\n\n      return this;\n    },\n\n    // remove eles in place on calling collection\n    unmerge: function( toRemove ){\n      var cy = this._private.cy;    \n      \n      if( !toRemove ){\n        return this;\n      }\n\n      if( $$.is.string(toRemove) ){\n        var selector = toRemove;\n        toRemove = cy.elements(selector);\n      }\n\n      for( var i = 0; i < toRemove.length; i++ ){\n        this.unmergeOne( toRemove[i] );\n      }\n      \n      return this; // chaining\n    },\n\n    map: function( mapFn, thisArg ){\n      var arr = [];\n      var eles = this;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var ret = mapFn.apply( thisArg, [ele, i, eles] );\n\n        arr.push( ret );\n      }\n\n      return arr;\n    },\n\n    stdFilter: function( fn, thisArg ){\n      var filterEles = [];\n      var eles = this;\n      var cy = this._private.cy;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var include = fn.apply( thisArg, [ele, i, eles] );\n\n        if( include ){\n          filterEles.push( ele );\n        }\n      }\n\n      return new $$.Collection( cy, filterEles );\n    },\n\n    max: function( valFn, thisArg ){\n      var max = -Infinity;\n      var maxEle;\n      var eles = this;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var val = valFn.apply( thisArg, [ ele, i, eles ] );\n\n        if( val > max ){\n          max = val;\n          maxEle = ele;\n        }\n      }\n\n      return {\n        value: max,\n        ele: maxEle\n      };\n    },\n\n    min: function( valFn, thisArg ){\n      var min = Infinity;\n      var minEle;\n      var eles = this;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var val = valFn.apply( thisArg, [ ele, i, eles ] );\n\n        if( val < min ){\n          min = val;\n          minEle = ele;\n        }\n      }\n\n      return {\n        value: min,\n        ele: minEle\n      };\n    }\n  });\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n    isNode: function(){\n      return this.group() === 'nodes';\n    },\n\n    isEdge: function(){\n      return this.group() === 'edges';\n    },\n\n    isLoop: function(){\n      return this.isEdge() && this.source().id() === this.target().id();\n    },\n\n    isSimple: function(){\n      return this.isEdge() && this.source().id() !== this.target().id();\n    },\n\n    group: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.group;\n      }\n    }\n  });\n\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // Functions for iterating over collections\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  $$.fn.eles({\n    each: function(fn){\n      if( $$.is.fn(fn) ){\n        for(var i = 0; i < this.length; i++){\n          var ele = this[i];\n          var ret = fn.apply( ele, [ i, ele ] );\n\n          if( ret === false ){ break; } // exit each early on return false\n        }\n      }\n      return this;\n    },\n\n    forEach: function(fn, thisArg){\n      if( $$.is.fn(fn) ){\n\n        for(var i = 0; i < this.length; i++){\n          var ele = this[i];\n          var ret = fn.apply( thisArg, [ ele, i, this ] );\n\n          if( ret === false ){ break; } // exit each early on return false\n        }\n      }\n\n      return this;\n    },\n\n    toArray: function(){\n      var array = [];\n      \n      for(var i = 0; i < this.length; i++){\n        array.push( this[i] );\n      }\n      \n      return array;\n    },\n\n    slice: function(start, end){\n      var array = [];\n      var thisSize = this.length;\n      \n      if( end == null ){\n        end = thisSize;\n      }\n\n      if( start == null ){\n        start = 0;\n      }\n      \n      if( start < 0 ){\n        start = thisSize + start;\n      }\n\n      if( end < 0 ){\n        end = thisSize + end;\n      }\n      \n      for(var i = start; i >= 0 && i < end && i < thisSize; i++){\n        array.push( this[i] );\n      }\n      \n      return new $$.Collection(this.cy(), array);\n    },\n\n    size: function(){\n      return this.length;\n    },\n\n    eq: function(i){\n      return this[i] || new $$.Collection( this.cy() );\n    },\n\n    first: function(){\n      return this[0] || new $$.Collection( this.cy() );\n    },\n\n    last: function(){\n      return this[ this.length - 1 ] || new $$.Collection( this.cy() );\n    },\n\n    empty: function(){\n      return this.length === 0;\n    },\n\n    nonempty: function(){\n      return !this.empty();\n    },\n\n    sort: function( sortFn ){\n      if( !$$.is.fn( sortFn ) ){\n        return this;\n      }\n\n      var cy = this.cy();      \n      var sorted = this.toArray().sort( sortFn );\n\n      return new $$.Collection(cy, sorted);\n    },\n\n    sortByZIndex: function(){\n      return this.sort( $$.Collection.zIndexSort );\n    },\n\n    zDepth: function(){\n      var ele = this[0];\n      if( !ele ){ return undefined; }\n\n      var _p = ele._private;\n      var group = _p.group;\n\n      if( group === 'nodes' ){\n        return _p.data.parent ? ele.parents().size() : 0;\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcDepth = src._private.data.parent ? src.parents().size() : 0;\n        var tgtDepth = tgt._private.data.parent ? tgt.parents().size() : 0;\n\n        return Math.max( srcDepth - 1, tgtDepth - 1, 0 ) + 0.5; // depth of deepest parent and just a bit above\n      }\n    }\n  });\n\n  $$.Collection.zIndexSort = function(a, b){\n    var cy = a.cy();\n    var a_p = a._private;\n    var b_p = b._private;\n    var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;\n    var depthA = 0;\n    var depthB = 0;\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var aIsNode = a_p.group === 'nodes';\n    var aIsEdge = a_p.group === 'edges';\n    var bIsNode = b_p.group === 'nodes';\n    var bIsEdge = b_p.group === 'edges';\n\n    // no need to calculate element depth if there is no compound node\n    if( hasCompoundNodes ){\n      depthA = a.zDepth();\n      depthB = b.zDepth();\n    }\n\n    var depthDiff = depthA - depthB;\n    var sameDepth = depthDiff === 0;\n\n    if( sameDepth ){\n      \n      if( aIsNode && bIsEdge ){\n        return 1; // 'a' is a node, it should be drawn later       \n      \n      } else if( aIsEdge && bIsNode ){\n        return -1; // 'a' is an edge, it should be drawn first\n\n      } else { // both nodes or both edges\n        if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)\n          return a_p.index - b_p.index;\n        } else {\n          return zDiff;\n        }\n      }\n    \n    // elements on different level\n    } else {\n      return depthDiff; // deeper element should be drawn later\n    }\n\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // Functions for layouts on nodes\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  $$.fn.eles({\n\n    // using standard layout options, apply position function (w/ or w/o animation)\n    layoutPositions: function( layout, options, fn ){\n      var nodes = this.nodes();\n      var cy = this.cy();\n\n      layout.trigger({ type: 'layoutstart', layout: layout });\n\n      if( options.animate ){\n        for( var i = 0; i < nodes.length; i++ ){\n          var node = nodes[i];\n          var lastNode = i === nodes.length - 1;\n\n          var newPos = fn.call( node, i, node );\n          var pos = node.position();\n\n          if( !$$.is.number(pos.x) || !$$.is.number(pos.y) ){\n            node.silentPosition({ x: 0, y: 0 });\n          }\n\n          node.animate({\n            position: newPos\n          }, {\n            duration: options.animationDuration,\n            step: !lastNode ? undefined : function(){\n              if( options.fit ){\n                cy.fit( options.padding );\n              } \n            },\n            complete: !lastNode ? undefined : function(){\n              if( options.zoom != null ){\n                cy.zoom( options.zoom );\n              }\n\n              if( options.pan ){\n                cy.pan( options.pan );\n              } \n\n              if( options.fit ){\n                cy.fit( options.padding );\n              } \n              \n              layout.one('layoutstop', options.stop);\n              layout.trigger({ type: 'layoutstop', layout: layout });\n            }\n          });\n        }\n\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n      } else {\n        nodes.positions( fn );\n\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n\n        if( options.zoom != null ){\n          cy.zoom( options.zoom );\n        }\n\n        if( options.pan ){\n          cy.pan( options.pan );\n        } \n\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n        \n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n      }\n\n      return this; // chaining\n    },\n\n    layout: function( options ){\n      var cy = this.cy();\n\n      cy.layout( $$.util.extend({}, options, {\n        eles: this\n      }) );\n\n      return this;\n    },\n\n    makeLayout: function( options ){\n      var cy = this.cy();\n\n      return cy.makeLayout( $$.util.extend({}, options, {\n        eles: this\n      }) );\n    }\n\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n\n    // fully updates (recalculates) the style for the elements\n    updateStyle: function( notifyRenderer ){\n      var cy = this._private.cy;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      if( cy._private.batchingStyle ){\n        var bEles = cy._private.batchStyleEles;\n\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n\n          if( !bEles.ids[ ele._private.id ] ){\n            bEles.push( ele );\n          }\n        }\n\n        return this; // chaining and exit early when batching\n      }\n\n      var style = cy.style();\n      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n      style.apply( this );\n\n      var updatedCompounds = this.updateCompoundBounds();\n      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\n      if( notifyRenderer ){\n        toNotify.rtrigger('style'); // let renderer know we changed style\n      } else {\n        toNotify.trigger('style'); // just fire the event\n      }\n      return this; // chaining\n    },\n\n    // just update the mappers in the elements' styles; cheaper than eles.updateStyle()\n    updateMappers: function( notifyRenderer ){\n      var cy = this._private.cy;\n      var style = cy.style();\n      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      style.updateMappers( this );\n\n      var updatedCompounds = this.updateCompoundBounds();\n      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\n      if( notifyRenderer ){\n        toNotify.rtrigger('style'); // let renderer know we changed style\n      } else {\n        toNotify.trigger('style'); // just fire the event\n      }\n      return this; // chaining\n    },\n\n    // get the specified css property as a rendered value (i.e. on-screen value)\n    // or get the whole rendered style if no property specified (NB doesn't allow setting)\n    renderedCss: function( property ){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return this; }\n\n      var ele = this[0];\n\n      if( ele ){\n        var renstyle = ele.cy().style().getRenderedStyle( ele );\n\n        if( property === undefined ){\n          return renstyle;\n        } else {\n          return renstyle[ property ];\n        }\n      }\n    },\n\n    // read the calculated css style of the element or override the style (via a bypass)\n    css: function( name, value ){\n      var cy = this.cy();\n      \n      if( !cy.styleEnabled() ){ return this; }\n\n      var updateTransitions = false;\n      var style = cy.style();\n\n      if( $$.is.plainObject(name) ){ // then extend the bypass\n        var props = name;\n        style.applyBypass( this, props, updateTransitions );\n\n        var updatedCompounds = this.updateCompoundBounds();\n        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n        toNotify.rtrigger('style'); // let the renderer know we've updated style\n\n      } else if( $$.is.string(name) ){\n  \n        if( value === undefined ){ // then get the property from the style\n          var ele = this[0];\n\n          if( ele ){\n            return ele._private.style[ name ].strValue;\n          } else { // empty collection => can't get any value\n            return;\n          }\n\n        } else { // then set the bypass with the property value\n          style.applyBypass( this, name, value, updateTransitions );\n\n          var updatedCompounds = this.updateCompoundBounds();\n          var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n          toNotify.rtrigger('style'); // let the renderer know we've updated style\n        }\n\n      } else if( name === undefined ){\n        var ele = this[0];\n\n        if( ele ){\n          return style.getRawStyle( ele );\n        } else { // empty collection => can't get any value\n          return;\n        }\n      }\n\n      return this; // chaining\n    },\n\n    removeCss: function( names ){\n      var cy = this.cy();\n      \n      if( !cy.styleEnabled() ){ return this; }\n\n      var updateTransitions = false;\n      var style = cy.style();\n      var eles = this;\n\n      if( names === undefined ){\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          style.removeAllBypasses( ele, updateTransitions );\n        }\n      } else {\n        names = names.split(/\\s+/);\n\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          style.removeBypasses( ele, names, updateTransitions );\n        }\n      }\n\n      var updatedCompounds = this.updateCompoundBounds();\n      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n      toNotify.rtrigger('style'); // let the renderer know we've updated style\n\n      return this; // chaining\n    },\n\n    show: function(){\n      this.css('display', 'element');\n      return this; // chaining\n    },\n\n    hide: function(){\n      this.css('display', 'none');\n      return this; // chaining\n    },\n\n    visible: function(){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return true; }\n\n      var ele = this[0];\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if( ele ){\n        var style = ele._private.style;\n\n        if(\n          style['visibility'].value !== 'visible'\n          || style['display'].value !== 'element'\n        ){\n          return false;\n        }\n        \n        if( ele._private.group === 'nodes' ){\n          if( !hasCompoundNodes ){ return true; }\n\n          var parents = ele._private.data.parent ? ele.parents() : null;\n\n          if( parents ){\n            for( var i = 0; i < parents.length; i++ ){\n              var parent = parents[i];\n              var pStyle = parent._private.style;\n              var pVis = pStyle['visibility'].value;\n              var pDis = pStyle['display'].value;\n\n              if( pVis !== 'visible' || pDis !== 'element' ){\n                return false;\n              }\n            }\n          }\n\n          return true;\n        } else {\n          var src = ele._private.source;\n          var tgt = ele._private.target;\n\n          return src.visible() && tgt.visible();\n        }\n\n      }\n    },\n\n    hidden: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return !ele.visible();\n      }\n    },\n\n    effectiveOpacity: function(){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return 1; }\n\n      var hasCompoundNodes = cy.hasCompoundNodes();\n      var ele = this[0];\n\n      if( ele ){\n        var _p = ele._private;\n        var parentOpacity = _p.style.opacity.value;\n\n        if( !hasCompoundNodes ){ return parentOpacity; }\n\n        var parents = !_p.data.parent ? null : ele.parents();\n        \n        if( parents ){\n          for( var i = 0; i < parents.length; i++ ){\n            var parent = parents[i];\n            var opacity = parent._private.style.opacity.value;\n\n            parentOpacity = opacity * parentOpacity;\n          }\n        }\n\n        return parentOpacity;\n      }\n    },\n\n    transparent: function(){\n      var ele = this[0];\n      var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n      if( ele ){\n        if( !hasCompoundNodes ){\n          return ele._private.style.opacity.value === 0;\n        } else {\n          return ele.effectiveOpacity() === 0;\n        }\n      }\n    },\n\n    isFullAutoParent: function(){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return false; }\n\n      var ele = this[0];\n\n      if( ele ){\n        var autoW = ele._private.style['width'].value === 'auto';\n        var autoH = ele._private.style['height'].value === 'auto';\n\n        return ele.isParent() && autoW && autoH;\n      }\n    }\n\n  });\n\n\n  $$.elesfn.style = $$.elesfn.css;\n  $$.elesfn.renderedStyle = $$.elesfn.renderedCss;\n  $$.elesfn.removeStyle = $$.elesfn.removeCss;\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  // Collection functions that toggle a boolean value\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  \n  function defineSwitchFunction(params){\n    return function(){\n      var args = arguments;\n      \n      // e.g. cy.nodes().select( data, handler )\n      if( args.length === 2 ){\n        var data = args[0];\n        var handler = args[1];\n        this.bind( params.event, data, handler );\n      } \n      \n      // e.g. cy.nodes().select( handler )\n      else if( args.length === 1 ){\n        var handler = args[0];\n        this.bind( params.event, handler );\n      }\n      \n      // e.g. cy.nodes().select()\n      else if( args.length === 0 ){\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n          var able = !params.ableField || ele._private[params.ableField];\n\n          if( params.overrideAble ){\n            var overrideAble = params.overrideAble(ele);\n\n            if( overrideAble !== undefined ){\n              able = overrideAble;\n\n              if( !overrideAble ){ return this; } // to save cycles assume not able for all on override\n            }\n          }\n\n          if( able ){\n            ele._private[params.field] = params.value;\n          }\n        }\n        this.updateStyle(); // change of state => possible change of style\n        this.trigger( params.event );\n      }\n\n      return this;\n    };\n  }\n  \n  function defineSwitchSet( params ){\n    $$.elesfn[ params.field ] = function(){\n      var ele = this[0];\n\n      if( ele ){\n        if( params.overrideField ){\n          var val = params.overrideField(ele);\n\n          if( val !== undefined ){\n            return val;\n          }\n        }\n\n        return ele._private[ params.field ];\n      }\n    };\n    \n    $$.elesfn[ params.on ] = defineSwitchFunction({\n      event: params.on,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: true\n    });\n\n    $$.elesfn[ params.off ] = defineSwitchFunction({\n      event: params.off,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: false\n    });\n  }\n  \n  defineSwitchSet({\n    field: 'locked',\n    overrideField: function(ele){\n      return ele.cy().autolock() ? true : undefined;\n    },\n    on: 'lock',\n    off: 'unlock'\n  });\n  \n  defineSwitchSet({\n    field: 'grabbable',\n    overrideField: function(ele){\n      return ele.cy().autoungrabify() ? false : undefined;\n    },\n    on: 'grabify',\n    off: 'ungrabify'\n  });\n  \n  defineSwitchSet({\n    field: 'selected',\n    ableField: 'selectable',\n    overrideAble: function(ele){\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'select',\n    off: 'unselect'\n  });\n  \n  defineSwitchSet({\n    field: 'selectable',\n    overrideField: function(ele){\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'selectify',\n    off: 'unselectify'\n  });\n  \n  $$.elesfn.grabbed = function(){\n    var ele = this[0];\n    if( ele ){\n      return ele._private.grabbed;\n    }\n  };\n\n  defineSwitchSet({\n    field: 'active',\n    on: 'activate',\n    off: 'unactivate'\n  });\n\n  $$.elesfn.inactive = function(){\n    var ele = this[0];\n    if( ele ){\n      return !ele._private.active;\n    }\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // DAG functions\n  //////////////////////////\n\n  $$.fn.eles({\n    // get the root nodes in the DAG\n    roots: function( selector ){\n      var eles = this;\n      var roots = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        if( !ele.isNode() ){\n          continue;\n        }\n\n        var hasEdgesPointingIn = ele.connectedEdges(function(){\n          return this.data('target') === ele.id() && this.data('source') !== ele.id();\n        }).length > 0;\n\n        if( !hasEdgesPointingIn ){\n          roots.push( ele );\n        }\n      }\n\n      return new $$.Collection( this._private.cy, roots, { unique: true } ).filter( selector );\n    },\n\n    // get the leaf nodes in the DAG\n    leaves: function( selector ){\n      var eles = this;\n      var leaves = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        if( !ele.isNode() ){\n          continue;\n        }\n\n        var hasEdgesPointingOut = ele.connectedEdges(function(){\n          return this.data('source') === ele.id() && this.data('target') !== ele.id();\n        }).length > 0;\n\n        if( !hasEdgesPointingOut ){\n          leaves.push( ele );\n        }\n      }\n\n      return new $$.Collection( this._private.cy, leaves, { unique: true } ).filter( selector );\n    },\n\n    // normally called children in graph theory\n    // these nodes =edges=> outgoing nodes\n    outgoers: function( selector ){\n      var eles = this;\n      var oEles = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var eleId = ele.id();\n\n        if( !ele.isNode() ){ continue; }\n\n        var edges = ele._private.edges;\n        for( var j = 0; j < edges.length; j++ ){\n          var edge = edges[j];\n          var srcId = edge._private.data.source;\n          var tgtId = edge._private.data.target;\n\n          if( srcId === eleId && tgtId !== eleId ){\n            oEles.push( edge );\n            oEles.push( edge.target()[0] );\n          }\n        }\n      }\n\n      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );\n    },\n\n    // aka DAG descendants\n    successors: function( selector ){\n      var eles = this;\n      var sEles = [];\n      var sElesIds = {};\n\n      for(;;){\n        var outgoers = eles.outgoers();\n\n        if( outgoers.length === 0 ){ break; } // done if no outgoers left\n\n        var newOutgoers = false;\n        for( var i = 0; i < outgoers.length; i++ ){\n          var outgoer = outgoers[i];\n          var outgoerId = outgoer.id();\n\n          if( !sElesIds[ outgoerId ] ){\n            sElesIds[ outgoerId ] = true;\n            sEles.push( outgoer );\n            newOutgoers = true;\n          }\n        }\n\n        if( !newOutgoers ){ break; } // done if touched all outgoers already\n\n        eles = outgoers;\n      }\n\n      return new $$.Collection( this._private.cy, sEles, { unique: true } ).filter( selector );\n    },\n\n    // normally called parents in graph theory\n    // these nodes <=edges= incoming nodes\n    incomers: function( selector ){\n      var eles = this;\n      var oEles = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var eleId = ele.id();\n\n        if( !ele.isNode() ){ continue; }\n\n        var edges = ele._private.edges;\n        for( var j = 0; j < edges.length; j++ ){\n          var edge = edges[j];\n          var srcId = edge._private.data.source;\n          var tgtId = edge._private.data.target;\n\n          if( tgtId === eleId && srcId !== eleId ){\n            oEles.push( edge );\n            oEles.push( edge.source()[0] );\n          }\n        }\n      }\n\n      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );\n    },\n\n    // aka DAG ancestors\n    predecessors: function( selector ){\n      var eles = this;\n      var pEles = [];\n      var pElesIds = {};\n\n      for(;;){\n        var incomers = eles.incomers();\n\n        if( incomers.length === 0 ){ break; } // done if no incomers left\n\n        var newIncomers = false;\n        for( var i = 0; i < incomers.length; i++ ){\n          var incomer = incomers[i];\n          var incomerId = incomer.id();\n\n          if( !pElesIds[ incomerId ] ){\n            pElesIds[ incomerId ] = true;\n            pEles.push( incomer );\n            newIncomers = true;\n          }\n        }\n\n        if( !newIncomers ){ break; } // done if touched all incomers already\n\n        eles = incomers;\n      }\n\n      return new $$.Collection( this._private.cy, pEles, { unique: true } ).filter( selector );\n    }\n  });\n\n\n  // Neighbourhood functions\n  //////////////////////////\n\n  $$.fn.eles({\n    neighborhood: function(selector){\n      var elements = [];\n      var cy = this._private.cy;\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){ // for all nodes\n        var node = nodes[i];\n        var connectedEdges = node.connectedEdges();\n\n        // for each connected edge, add the edge and the other node\n        for( var j = 0; j < connectedEdges.length; j++ ){\n          var edge = connectedEdges[j];\n          var otherNode = edge.connectedNodes().not(node);\n\n          // need check in case of loop\n          if( otherNode.length > 0 ){\n            elements.push( otherNode[0] ); // add node 1 hop away\n          }\n          \n          // add connected edge\n          elements.push( edge[0] );\n        }\n\n      }\n      \n      return ( new $$.Collection( cy, elements, { unique: true } ) ).filter( selector );\n    },\n\n    closedNeighborhood: function(selector){\n      return this.neighborhood().add( this ).filter( selector );\n    },\n\n    openNeighborhood: function(selector){\n      return this.neighborhood( selector );\n    }\n  });  \n\n\n  // Edge functions\n  /////////////////\n\n  $$.fn.eles({\n    source: function( selector ){\n      var ele = this[0];\n      var src;\n\n      if( ele ){\n        src = ele._private.source;\n      }\n\n      return src && selector ? src.filter( selector ) : src;\n    },\n\n    target: function( selector ){\n      var ele = this[0];\n      var tgt;\n\n      if( ele ){\n        tgt = ele._private.target;\n      }\n\n      return tgt && selector ? tgt.filter( selector ) : tgt;\n    },\n\n    sources: defineSourceFunction({\n      attr: 'source'\n    }),\n\n    targets: defineSourceFunction({\n      attr: 'target'\n    })\n  });\n  \n  function defineSourceFunction( params ){\n    return function( selector ){\n      var sources = [];\n      var cy = this._private.cy;\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        var src = ele._private[ params.attr ];\n\n        if( src ){\n          sources.push( src );\n        }\n      }\n      \n      return new $$.Collection( cy, sources, { unique: true } ).filter( selector );\n    };\n  }\n\n  $$.fn.eles({\n    edgesWith: defineEdgesWithFunction(),\n\n    edgesTo: defineEdgesWithFunction({\n      thisIs: 'source'\n    })\n  });\n  \n  function defineEdgesWithFunction( params ){\n    \n    return function(otherNodes){\n      var elements = [];\n      var cy = this._private.cy;\n      var p = params || {};\n\n      // get elements if a selector is specified\n      if( $$.is.string(otherNodes) ){\n        otherNodes = cy.$( otherNodes );\n      }\n      \n      var edges = otherNodes.connectedEdges();\n      var thisIds = this._private.ids;\n      \n      for( var i = 0; i < edges.length; i++ ){\n        var edge = edges[i];\n        var foundId;\n        var edgeData = edge._private.data;\n\n        if( p.thisIs ){\n          var idToFind = edgeData[ p.thisIs ];\n          foundId = thisIds[ idToFind ];\n        } else {\n          foundId = thisIds[ edgeData.source ] || thisIds[ edgeData.target ];\n        }\n        \n        if( foundId ){\n          elements.push( edge );\n        }\n      }\n      \n      return new $$.Collection( cy, elements, { unique: true } );\n    };\n  }\n  \n  $$.fn.eles({\n    connectedEdges: function( selector ){\n      var retEles = [];\n      var cy = this._private.cy;\n      \n      var eles = this;\n      for( var i = 0; i < eles.length; i++ ){\n        var node = eles[i];\n        if( !node.isNode() ){ continue; }\n\n        var edges = node._private.edges;\n\n        for( var j = 0; j < edges.length; j++ ){\n          var edge = edges[j];          \n          retEles.push( edge );\n        }\n      }\n      \n      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );\n    },\n\n    connectedNodes: function( selector ){\n      var retEles = [];\n      var cy = this._private.cy;\n\n      var eles = this;\n      for( var i = 0; i < eles.length; i++ ){\n        var edge = eles[i];\n        if( !edge.isEdge() ){ continue; }\n\n        retEles.push( edge.source()[0] );\n        retEles.push( edge.target()[0] );\n      }\n\n      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );\n    },\n\n    parallelEdges: defineParallelEdgesFunction(),\n\n    codirectedEdges: defineParallelEdgesFunction({\n      codirected: true\n    })\n  });\n  \n  function defineParallelEdgesFunction(params){\n    var defaults = {\n      codirected: false\n    };\n    params = $$.util.extend({}, defaults, params);\n    \n    return function( selector ){\n      var cy = this._private.cy;\n      var elements = [];\n      var edges = this.edges();\n      var p = params;\n\n      // look at all the edges in the collection\n      for( var i = 0; i < edges.length; i++ ){\n        var edge1 = edges[i];\n        var src1 = edge1.source()[0];\n        var srcid1 = src1.id();\n        var tgt1 = edge1.target()[0];\n        var tgtid1 = tgt1.id();\n        var srcEdges1 = src1._private.edges;\n\n        // look at edges connected to the src node of this edge\n        for( var j = 0; j < srcEdges1.length; j++ ){\n          var edge2 = srcEdges1[j];\n          var edge2data = edge2._private.data;\n          var tgtid2 = edge2data.target;\n          var srcid2 = edge2data.source;\n\n          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n          \n          if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){\n            elements.push( edge2 );\n          }\n        }\n      }\n      \n      return new $$.Collection( cy, elements, { unique: true } ).filter( selector );\n    };\n  \n  }\n\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n\n    fit: function(){},\n    center: function(){}\n\n  });\n  \n})( cytoscape );\n;(function ($$) {\n  \"use strict\";\n\n  /*  Min and Max heap predefaults */\n  \n  $$.Minheap = function (cy, eles, valueFn) {\n    return new $$.Heap(cy, eles, $$.Heap.minHeapComparator, valueFn);\n  };\n\n  $$.Maxheap = function (cy, eles, valueFn) {\n    return new $$.Heap(cy, eles, $$.Heap.maxHeapComparator, valueFn);\n  };\n  \n  $$.Heap = function (cy, eles, comparator, valueFn) {\n    if (typeof comparator === \"undefined\" || typeof eles === \"undefined\") {\n      return;\n    }\n    \n    if (typeof valueFn === \"undefined\") {\n      valueFn = $$.Heap.idFn;\n    }\n\n    var sourceHeap = [],\n      pointers = {},\n      elements = [],\n      i = 0,\n      id,\n      heap,\n      elesLen;\n\n    eles = this.getArgumentAsCollection(eles, cy);\n    elesLen = eles.length;\n\n    for (i = 0; i < elesLen; i += 1) {\n      sourceHeap.push(valueFn.call(cy, eles[i], i, eles));\n\n      id = eles[i].id();\n      \n      if (pointers.hasOwnProperty(id)) {\n        throw \"ERROR: Multiple items with the same id found: \" + id;\n      }\n      \n      pointers[id] = i;\n      elements.push(id);\n    }\n\n    this._private = {\n      cy: cy,\n      heap: sourceHeap,\n      pointers: pointers,\n      elements: elements,\n      comparator: comparator,\n      extractor: valueFn,\n      length: elesLen\n    };\n\n    for (i = Math.floor(elesLen / 2); i >= 0; i -= 1) {\n      heap = this.heapify(i);\n    }\n\n    return heap;\n  };\n\n  /* static methods */\n  $$.Heap.idFn = function (node) {\n    return node.id();\n  };\n\n  $$.Heap.minHeapComparator = function (a, b) {\n    return a >= b;\n  };\n\n  $$.Heap.maxHeapComparator = function (a, b) {\n    return a <= b;\n  };\n\n  $$.fn.heap = function( fnMap, options ){\n    for( var name in fnMap ){\n      var fn = fnMap[name];\n      $$.Heap.prototype[ name ] = fn;\n    }\n  };\n\n  $$.heapfn = $$.Heap.prototype; // short alias\n\n  /* object methods */\n  $$.heapfn.size = function () {\n    return this._private.length;\n  };\n\n  $$.heapfn.getArgumentAsCollection = function (eles, cy) {\n    var result;\n    if(typeof cy === \"undefined\") {\n      cy = this._private.cy;\n    }\n\n    if ($$.is.elementOrCollection(eles)) {\n      result = eles;\n\n    } else {\n      var resultArray = [],\n        sourceEles = [].concat.apply([], [eles]);\n\n      for (var i = 0; i < sourceEles.length; i++) {\n        var id = sourceEles[i],\n          ele = cy.getElementById(id);\n\n        if(ele.length > 0) {\n          resultArray.push(ele);\n        }\n      }\n\n      result = new $$.Collection(cy, resultArray);\n    }\n\n    return result;\n  };\n\n  $$.heapfn.isHeap = function () {\n    var array = this._private.heap,\n      arrlen = array.length,\n      i,\n      left,\n      right,\n      lCheck,\n      rCheck,\n      comparator = this._private.comparator;\n\n    for (i = 0; i < arrlen; i += 1) {\n      left = 2 * i + 1;\n      right = left + 1;\n      lCheck = left < arrlen ? comparator(array[left], array[i]) : true;\n      rCheck = right < arrlen ? comparator(array[right], array[i]) : true;\n\n      if (!lCheck || !rCheck) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  $$.heapfn.heapSwap = function (i, j) {\n    var heap = this._private.heap,\n      pointers = this._private.pointers,\n      elements = this._private.elements,\n      swapValue = heap[i],\n      swapElems = elements[i],\n      idI = elements[i],\n      idJ = elements[j];\n\n    heap[i] = heap[j];\n    elements[i] = elements[j];\n\n    pointers[idI] = j;\n    pointers[idJ] = i;\n\n    heap[j] = swapValue;\n    elements[j] = swapElems;\n  };\n\n  $$.heapfn.heapify = function (i, rootToLeaf) {\n    var treeLen = 0,\n      condHeap = false,\n      array,\n      current,\n      left,\n      right,\n      best,\n      comparator,\n      parent;\n    \n    if (typeof rootToLeaf === \"undefined\") {\n      rootToLeaf = true;\n    }\n\n    array = this._private.heap;\n    treeLen = array.length;\n    comparator = this._private.comparator;\n    current = i;\n\n    while (!condHeap) {\n\n      if (rootToLeaf) {\n        left = 2 * current + 1;\n        right = left + 1;\n        best = current;\n        \n        if (left < treeLen && !comparator(array[left], array[best])) {\n          best = left;\n        }\n        \n        if (right < treeLen && !comparator(array[right], array[best])) {\n          best = right;\n        }\n        \n        condHeap = best === current;\n        \n        if (!condHeap) {\n          this.heapSwap(best, current);\n          current = best;\n        }\n\n      } else {\n        parent = Math.floor((current - 1) / 2);\n        best = current;\n        condHeap = parent < 0 || comparator(array[best], array[parent]);\n\n        if (!condHeap) {\n          this.heapSwap(best, parent);\n          current = parent;\n        }\n      }\n\n    } // while\n  };\n\n  /* collectionOrElement */\n  $$.heapfn.insert = function (eles) {\n    var elements = this.getArgumentAsCollection(eles),\n      elsize = elements.length,\n      element,\n      elindex,\n      elvalue,\n      elid,\n      i;\n\n    for (i = 0; i < elsize; i += 1) {\n      element = elements[i];\n      elindex = this._private.heap.length;\n      elvalue = this._private.extractor(element);\n      elid = element.id();\n\n      if (this._private.pointers.hasOwnProperty(elid)) {\n        throw \"ERROR: Multiple items with the same id found: \" + elid;\n      }\n\n      this._private.heap.push(elvalue);\n      this._private.elements.push(elid);\n      this._private.pointers[elid] = elindex;\n      this.heapify(elindex, false);\n    }\n\n    this._private.length = this._private.heap.length;\n  };\n\n  $$.heapfn.getValueById = function (elementId) {\n    if (this._private.pointers.hasOwnProperty(elementId)) {\n      var elementIndex = this._private.pointers[elementId];\n\n      return this._private.heap[elementIndex];\n    }\n  };\n  \n  $$.heapfn.contains = function (eles) {\n    var elements = this.getArgumentAsCollection(eles);\n\n    for (var i = 0; i < elements.length; i += 1) {\n      var elementId = elements[i].id();\n\n      if(!this._private.pointers.hasOwnProperty(elementId)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  \n  $$.heapfn.top = function () {\n    if (this._private.length > 0) {\n\n      return {\n        value: this._private.heap[0],\n        id: this._private.elements[0]\n      };\n\n    }\n  };\n\n  $$.heapfn.pop = function () {\n    if (this._private.length > 0) {\n      var top = this.top(),\n        lastIndex = this._private.length - 1,\n        removeCandidate,\n        removeValue,\n        remId;\n\n      this.heapSwap(0, lastIndex);\n\n      removeCandidate = this._private.elements[lastIndex];\n      removeValue = this._private.heap[lastIndex];\n      remId = removeCandidate;\n\n      this._private.heap.pop();\n      this._private.elements.pop();\n      this._private.length = this._private.heap.length;\n      this._private.pointers[remId] = undefined;\n\n      this.heapify(0);\n      return top;\n    }\n  };\n\n  $$.heapfn.findDirectionHeapify = function (index) {\n    var parent = Math.floor((index - 1) / 2),\n      array = this._private.heap,\n      condHeap = parent < 0 || this._private.comparator(array[index], array[parent]);\n\n    this.heapify(index, condHeap);\n  };\n\n  /* edit is a new value or function */\n  // only values in heap are updated. elements themselves are not!\n  $$.heapfn.edit = function (eles, edit) {\n    var elements = this.getArgumentAsCollection(eles);\n    \n    for (var i = 0; i < elements.length; i += 1) {\n      var elementId = elements[i].id(),\n        elementIndex = this._private.pointers[elementId],\n        elementValue = this._private.heap[elementIndex];\n      \n      if ($$.is.number(edit)) {\n        this._private.heap[elementIndex] = edit;\n        \n      } else if ($$.is.fn(edit)) {\n        this._private.heap[elementIndex] = edit.call(this._private.cy, elementValue, elementIndex);\n      }\n\n      this.findDirectionHeapify(elementIndex);\n    }\n  };\n\n  $$.heapfn.delete = function (eles) {\n    var elements = this.getArgumentAsCollection(eles);\n    \n    for (var i = 0; i < elements.length; i += 1) {\n      var elementId = elements[i].id(),\n        elementIndex = this._private.pointers[elementId],\n        lastIndex = this._private.length - 1,\n        removeCandidate,\n        removeValue,\n        remId;\n\n      if (elementIndex !== lastIndex) {\n        this.heapSwap(elementIndex, lastIndex);\n      }\n\n      removeCandidate = this._private.elements[lastIndex];\n      removeValue = this._private.heap[lastIndex];\n      remId = removeCandidate;\n\n      this._private.heap.pop();\n      this._private.elements.pop();\n      this._private.length = this._private.heap.length;\n      this._private.pointers[remId] = undefined;\n\n      this.findDirectionHeapify(elementIndex);\n    }\n\n    return removeValue;\n  };\n\n})(cytoscape);\n/*\n  The canvas renderer was written by Yue Dong.\n\n  Modifications tracked on Github.\n*/\n\n(function($$) { 'use strict';\n\n  function CanvasRenderer(options) {\n    \n    CanvasRenderer.CANVAS_LAYERS = 5;\n    CanvasRenderer.SELECT_BOX = 0;\n    CanvasRenderer.DRAG = 2;\n    CanvasRenderer.NODE = 4;\n    CanvasRenderer.TEXTURE_BUFFER = 0;\n    CanvasRenderer.BUFFER_COUNT = 2;\n\n    this.options = options;\n\n    this.data = {\n        \n      select: [undefined, undefined, undefined, undefined, 0], // Coordinates for selection box, plus enabled flag \n      renderer: this, cy: options.cy, container: options.cy.container(),\n      \n      canvases: new Array(CanvasRenderer.CANVAS_LAYERS),\n      contexts: new Array(CanvasRenderer.CANVAS_LAYERS),\n      canvasNeedsRedraw: new Array(CanvasRenderer.CANVAS_LAYERS),\n      \n      bufferCanvases: new Array(CanvasRenderer.BUFFER_COUNT),\n      bufferContexts: new Array(CanvasRenderer.CANVAS_LAYERS)\n\n    };\n    \n    //--Pointer-related data\n    this.hoverData = {down: null, last: null, \n        downTime: null, triggerMode: null, \n        dragging: false, \n        initialPan: [null, null], capture: false};\n    \n    this.timeoutData = {panTimeout: null};\n    \n    this.dragData = {possibleDragElements: []};\n    \n    this.touchData = {start: null, capture: false,\n        // These 3 fields related to tap, taphold events\n        startPosition: [null, null, null, null, null, null],\n        singleTouchStartTime: null,\n        singleTouchMoved: true,\n        \n        \n        now: [null, null, null, null, null, null], \n        earlier: [null, null, null, null, null, null] };\n    //--\n    \n    //--Wheel-related data \n    this.zoomData = {freeToZoom: false, lastPointerX: null};\n    //--\n    \n    this.redraws = 0;\n    this.showFps = options.showFps;\n\n    this.bindings = [];\n    \n    this.data.canvasContainer = document.createElement('div');\n    var containerStyle = this.data.canvasContainer.style;\n    containerStyle.position = 'absolute';\n    containerStyle.zIndex = '0';\n    containerStyle.overflow = 'hidden';\n\n    this.data.container.appendChild( this.data.canvasContainer );\n\n    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {\n      this.data.canvases[i] = document.createElement('canvas');\n      this.data.contexts[i] = this.data.canvases[i].getContext('2d');\n      this.data.canvases[i].style.position = 'absolute';\n      this.data.canvases[i].setAttribute('data-id', 'layer' + i);\n      this.data.canvases[i].style.zIndex = String(CanvasRenderer.CANVAS_LAYERS - i);\n      this.data.canvasContainer.appendChild(this.data.canvases[i]);\n      \n      this.data.canvasNeedsRedraw[i] = false;\n    }\n    this.data.topCanvas = this.data.canvases[0];\n\n    this.data.canvases[CanvasRenderer.NODE].setAttribute('data-id', 'layer' + CanvasRenderer.NODE + '-node');\n    this.data.canvases[CanvasRenderer.SELECT_BOX].setAttribute('data-id', 'layer' + CanvasRenderer.SELECT_BOX + '-selectbox');\n    this.data.canvases[CanvasRenderer.DRAG].setAttribute('data-id', 'layer' + CanvasRenderer.DRAG + '-drag');\n    \n    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {\n      this.data.bufferCanvases[i] = document.createElement('canvas');\n      this.data.bufferContexts[i] = this.data.bufferCanvases[i].getContext('2d');\n      this.data.bufferCanvases[i].style.position = 'absolute';\n      this.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n      this.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n      this.data.bufferCanvases[i].style.visibility = 'hidden';\n      //this.data.canvasContainer.appendChild(this.data.bufferCanvases[i]);\n    }\n\n    this.hideEdgesOnViewport = options.hideEdgesOnViewport;\n    this.hideLabelsOnViewport = options.hideLabelsOnViewport;\n    this.textureOnViewport = options.textureOnViewport;\n    this.wheelSensitivity = options.wheelSensitivity;\n    this.motionBlurEnabled = options.motionBlur === undefined ? true : options.motionBlur; // on by default\n    this.forcedPixelRatio = options.pixelRatio;\n    this.motionBlur = true; // for initial kick off\n    this.tapThreshold = options.tapThreshold;\n    this.tapThreshold2 = options.tapThreshold * options.tapThreshold;\n    this.tapholdDuration = 500;\n\n    this.load();\n  }\n\n  CanvasRenderer.panOrBoxSelectDelay = 400;\n  CanvasRenderer.isTouch = $$.is.touch();\n\n  // whether to use Path2D caching for drawing\n  var pathsImpld = typeof Path2D !== 'undefined';\n  CanvasRenderer.usePaths = function(){\n    return pathsImpld;\n  };\n\n  CanvasRenderer.prototype.notify = function(params) {\n    var types;\n\n    if( $$.is.array( params.type ) ){\n      types = params.type;\n\n    } else {\n      types = [ params.type ];\n    }\n\n    for( var i = 0; i < types.length; i++ ){\n      var type = types[i];\n\n      switch( type ){\n        case 'destroy':\n          this.destroy();\n          return;\n\n        case 'add':\n        case 'remove':\n        case 'load':\n          this.updateNodesCache();\n          this.updateEdgesCache();\n          break;\n\n        case 'viewport':\n          this.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          break;\n\n        case 'style':\n          this.updateCachedZSortedEles();\n          break;\n      }\n\n      if( type === 'load' || type === 'resize' ){\n        this.invalidateContainerClientCoordsCache();\n        this.matchCanvasSize(this.data.container);\n      }\n    } // for\n    \n    this.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n    this.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n    this.redraw();\n  };\n\n  CanvasRenderer.prototype.destroy = function(){\n    this.destroyed = true;\n\n    for( var i = 0; i < this.bindings.length; i++ ){\n      var binding = this.bindings[i];\n      var b = binding;\n\n      b.target.removeEventListener(b.event, b.handler, b.useCapture);\n    }\n\n    if( this.removeObserver ){\n      this.removeObserver.disconnect();\n    }\n  };\n\n  \n\n  // copy the math functions into the renderer prototype\n  // unfortunately these functions are used interspersed t/o the code\n  // and this makes sure things work just in case a ref was missed in refactoring\n  // TODO remove this eventually\n  for( var fnName in $$.math ){\n    CanvasRenderer.prototype[ fnName ] = $$.math[ fnName ];\n  }\n  \n  \n  $$('renderer', 'canvas', CanvasRenderer);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n  var rendFunc = CanvasRenderer.prototype;\n  var arrowShapes = CanvasRenderer.arrowShapes = {};\n\n  CanvasRenderer.arrowShapeHeight = 0.3;\n\n  // Contract for arrow shapes:\n  // 0, 0 is arrow tip\n  // (0, 1) is direction towards node\n  // (1, 0) is right\n  //\n  // functional api:\n  // collide: check x, y in shape\n  // roughCollide: called before collide, no false negatives\n  // draw: draw\n  // spacing: dist(arrowTip, nodeBoundary)\n  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n  var bbCollide = function(x, y, centerX, centerY, width, height, direction, padding){\n    var x1 = centerX - width/2;\n    var x2 = centerX + width/2;\n    var y1 = centerY - height/2;\n    var y2 = centerY + height/2;\n\n    return (x1 <= x && x <= x2) && (y1 <= y && y <= y2);\n  };\n\n  var transform = function(x, y, size, angle, translation){\n    angle = -angle; // b/c of notation used in arrow draw fn\n\n    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n    \n    var xScaled = xRotated * size;\n    var yScaled = yRotated * size;\n\n    var xTranslated = xScaled + translation.x;\n    var yTranslated = yScaled + translation.y;\n    \n    return {\n      x: xTranslated,\n      y: yTranslated\n    };\n  };\n\n  arrowShapes['arrow'] = {\n    _points: [\n      -0.15, -0.3,\n      0, 0,\n      0.15, -0.3\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['arrow']._points;\n      \n//      console.log(\"collide(): \" + direction);\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['arrow']._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['triangle'] = arrowShapes['arrow'];\n  \n  arrowShapes['triangle-backcurve'] = {\n    _ctrlPt: [ 0, -0.15 ],\n\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['triangle']._points;\n      \n//      console.log(\"collide(): \" + direction);\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['triangle']._points;\n      var firstPt;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        if( i === 0 ){\n          firstPt = pt;\n        }\n\n        context.lineTo(pt.x, pt.y);\n      }\n\n      var ctrlPt = this._ctrlPt;\n      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );\n\n      context.quadraticCurveTo( ctrlPtTrans.x, ctrlPtTrans.y, firstPt.x, firstPt.y );\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n  \n\n  arrowShapes['triangle-tee'] = {\n    _points: [\n      -0.15, -0.3,\n      0, 0,\n      0.15, -0.3,\n      -0.15, -0.3\n    ],\n\n    _pointsTee: [\n      -0.15, -0.4,\n      -0.15, -0.5,\n      0.15, -0.5,\n      0.15, -0.4\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var triPts = arrowShapes['triangle-tee']._points;\n      var teePts = arrowShapes['triangle-tee']._pointsTee;\n      \n      var inside = $$.math.pointInsidePolygon(x, y, teePts, centerX, centerY, width, height, direction, padding) \n        || $$.math.pointInsidePolygon(x, y, triPts, centerX, centerY, width, height, direction, padding);\n\n      return inside;\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var triPts = arrowShapes['triangle-tee']._points;\n      for (var i = 0; i < triPts.length / 2; i++){\n        var pt = transform( triPts[ i * 2 ],  triPts[ i * 2 + 1 ], size, angle, translation );\n        \n        context.lineTo( pt.x, pt.y );\n      }\n\n      var teePts = arrowShapes['triangle-tee']._pointsTee;\n      var firstTeePt = transform( teePts[0], teePts[1], size, angle, translation );\n      context.moveTo( firstTeePt.x, firstTeePt.y );\n\n      for (var i = 0; i < teePts.length / 2; i++){\n        var pt = transform( teePts[ i * 2 ],  teePts[ i * 2 + 1 ], size, angle, translation );\n        \n        context.lineTo( pt.x, pt.y );\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['half-triangle-overshot'] = {\n    _points: [\n      0, -0.25,\n      -0.5, -0.25,\n      0.5, 0.25\n    ],\n    \n    leavePathOpen: true,\n    matchEdgeWidth: true,\n\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = this._points;\n      \n//      console.log(\"collide(): \" + direction);\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = this._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['none'] = {\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      return false;\n    },\n    \n    roughCollide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      return false;\n    },\n    \n    draw: function(context) {\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return 0;\n    }\n  };\n  \n  arrowShapes['circle'] = {\n    _baseRadius: 0.15,\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      // Transform x, y to get non-rotated ellipse\n      \n      if (width != height) {                  \n        var aspectRatio = (height + padding) / (width + padding);\n        y /= aspectRatio;\n        centerY /= aspectRatio;\n        \n        return (Math.pow(centerX - x, 2) \n          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)\n            * arrowShapes['circle']._baseRadius, 2));\n      } else {\n        return (Math.pow(centerX - x, 2) \n          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)\n            * arrowShapes['circle']._baseRadius, 2));\n      }\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      context.arc(translation.x, translation.y, arrowShapes['circle']._baseRadius * size, 0, Math.PI * 2, false);\n    },\n    \n    spacing: function(edge) {\n      return rendFunc.getArrowWidth(edge._private.style['width'].pxValue)\n        * arrowShapes['circle']._baseRadius;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n  \n  arrowShapes['inhibitor'] = {\n    _points: [\n      -0.25, 0,\n      -0.25, -0.1,\n      0.25, -0.1,\n      0.25, 0\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['inhibitor']._points;\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['inhibitor']._points;\n      \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 1;\n    },\n    \n    gap: function(edge) {\n      return 1;\n    }\n  };\n\n  arrowShapes['tee'] = arrowShapes['inhibitor'];\n\n  arrowShapes['square'] = {\n    _points: [\n      -0.15, 0.00,\n      0.15, 0.00,\n      0.15, -0.3,\n      -0.15, -0.3\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['square']._points;\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['square']._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n\n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['diamond'] = {\n    _points: [\n      -0.15, -0.15,\n      0, -0.3,\n      0.15, -0.15,\n      0, 0\n    ],\n\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['diamond']._points;\n          \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n\n    roughCollide: bbCollide,\n\n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['diamond']._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue;\n    }\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.getCachedNodes = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    if (data.cache.cachedNodes == null) {\n      data.cache.cachedNodes = cy.nodes();\n    }\n    \n    return data.cache.cachedNodes;\n  };\n  \n  CanvasRenderer.prototype.updateNodesCache = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    data.cache.cachedNodes = cy.nodes();\n  };\n  \n  CanvasRenderer.prototype.getCachedEdges = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    if (data.cache.cachedEdges == null) {\n      data.cache.cachedEdges = cy.edges();\n    }\n    \n    return data.cache.cachedEdges;\n  };\n  \n  CanvasRenderer.prototype.updateEdgesCache = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    data.cache.cachedEdges = cy.edges();\n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // Project mouse\n  CanvasRenderer.prototype.projectIntoViewport = function(clientX, clientY) {\n    var offsets = this.findContainerClientCoords();\n    var offsetLeft = offsets[0];\n    var offsetTop = offsets[1];\n    \n    var x = clientX - offsetLeft; \n    var y = clientY - offsetTop;\n    \n    x -= this.data.cy.pan().x; y -= this.data.cy.pan().y; x /= this.data.cy.zoom(); y /= this.data.cy.zoom();\n    return [x, y];\n  };\n\n  CanvasRenderer.prototype.findContainerClientCoords = function() {\n    var container = this.data.container;\n\n    var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();\n\n    return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];\n  };\n\n  CanvasRenderer.prototype.invalidateContainerClientCoordsCache = function(){\n    this.containerBB = null;\n  };\n\n  // Find nearest element\n  CanvasRenderer.prototype.findNearestElement = function(x, y, visibleElementsOnly){\n    var self = this;\n    var eles = this.getCachedZSortedEles();\n    var near = [];\n    var isTouch = CanvasRenderer.isTouch;\n    var zoom = this.data.cy.zoom();\n    var hasCompounds = this.data.cy.hasCompoundNodes();\n    var edgeThreshold = (isTouch ? 256 : 32) / zoom;\n    var nodeThreshold = (isTouch ? 16 : 0) /  zoom;\n\n    function checkNode(node){\n      var width = node.outerWidth();\n      var height = node.outerHeight();\n      var hw = width/2;\n      var hh = height/2;\n      var pos = node._private.position;\n\n      if(\n        pos.x - hw <= x && x <= pos.x + hw // bb check x\n          &&\n        pos.y - hh <= y && y <= pos.y + hh // bb check y\n      ){\n        var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );\n\n        // exit early if invisible edge and must be visible\n        if( visibleElementsOnly && !visible ){\n          return;\n        }\n\n        var shape = CanvasRenderer.nodeShapes[ self.getNodeShape(node) ];\n        var borderWO = node._private.style['border-width'].pxValue / 2;\n\n        if(\n          shape.checkPoint(x, y, borderWO, width + nodeThreshold, height + nodeThreshold, pos.x, pos.y)\n        ){\n            near.push( node );\n        }\n\n      }\n    }\n\n    function checkEdge(edge){\n      var rs = edge._private.rscratch;\n      var style = edge._private.style;\n      var width = style['width'].pxValue;\n      var widthSq = width * width;\n      var width2 = width * 2;\n      var src = edge._private.source;\n      var tgt = edge._private.target;\n      var inEdgeBB = false;\n\n      // exit early if invisible edge and must be visible\n      var passedVisibilityCheck;\n      var passesVisibilityCheck = function(){\n        if( passedVisibilityCheck !== undefined ){\n          return passedVisibilityCheck;\n        }\n\n        if( !visibleElementsOnly ){\n          passedVisibilityCheck = true;\n          return true;\n        }\n\n        var visible = edge.visible() && !edge.transparent();\n        if( visible ){\n          passedVisibilityCheck = true;\n          return true;\n        }\n\n        passedVisibilityCheck = false;\n        return false;\n      };\n\n      if (rs.edgeType === 'self') {\n        if(\n            (\n              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY, widthSq))\n                && passesVisibilityCheck() &&\n              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY) )\n            )\n              ||\n            (\n              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY, widthSq))\n                && passesVisibilityCheck() &&\n              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY) )\n            )\n        ){\n          near.push( edge );\n        }\n      \n      } else if (rs.edgeType === 'haystack') {\n        var radius = style['haystack-radius'].value;\n        var halfRadius = radius/2; // b/c have to half width/height\n\n        var tgtPos = tgt._private.position;\n        var tgtW = tgt.width();\n        var tgtH = tgt.height();\n        var srcPos = src._private.position;\n        var srcW = src.width();\n        var srcH = src.height();\n\n        var startX = srcPos.x + rs.source.x * srcW * halfRadius;\n        var startY = srcPos.y + rs.source.y * srcH * halfRadius;\n        var endX = tgtPos.x + rs.target.x * tgtW * halfRadius;\n        var endY = tgtPos.y + rs.target.y * tgtH * halfRadius;\n\n        if( \n          (inEdgeBB = $$.math.inLineVicinity(x, y, startX, startY, endX, endY, width2))\n            && passesVisibilityCheck() &&\n          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine( x, y, startX, startY, endX, endY )\n        ){\n          near.push( edge );\n        }\n      \n      } else if (rs.edgeType === 'straight') {\n        if(\n          (inEdgeBB = $$.math.inLineVicinity(x, y, rs.startX, rs.startY, rs.endX, rs.endY, width2))\n            && passesVisibilityCheck() &&\n          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine(x, y, rs.startX, rs.startY, rs.endX, rs.endY)\n        ){\n          near.push( edge );\n        }\n      \n      } else if (rs.edgeType === 'bezier') {\n        if(\n          (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY, widthSq))\n            && passesVisibilityCheck() &&\n          (widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY))\n        ){\n          near.push( edge );\n        }\n      }\n      \n      if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){\n        var srcShape = CanvasRenderer.arrowShapes[ style['source-arrow-shape'].value ];\n        var tgtShape = CanvasRenderer.arrowShapes[ style['target-arrow-shape'].value ];\n\n        var src = src || edge._private.source;\n        var tgt = tgt || edge._private.target;\n\n        var tgtPos = tgt._private.position;\n        var srcPos = src._private.position;\n\n        var srcArW = self.getArrowWidth( style['width'].pxValue );\n        var srcArH = self.getArrowHeight( style['width'].pxValue );\n\n        var tgtArW = srcArW;\n        var tgtArH = srcArH;\n\n        if(\n          (\n            srcShape.roughCollide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)\n              && \n            srcShape.collide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)\n          )\n            ||\n          (\n            tgtShape.roughCollide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)\n              &&\n            tgtShape.collide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)\n          )\n        ){\n          near.push( edge );\n        }\n      }\n\n      // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n      if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){\n        checkNode( src );\n        checkNode( tgt );\n      }\n    }\n\n    for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence\n      var ele = eles[i];\n\n      if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early\n\n      if( ele._private.group === 'nodes' ){ \n        checkNode( eles[i] );\n\n      } else  { // then edge\n        checkEdge( eles[i] );\n      }\n\n    }\n  \n    \n    if( near.length > 0 ){\n      return near[ near.length - 1 ];\n    } else {\n      return null;\n    }\n  }; \n\n  // 'Give me everything from this box'\n  CanvasRenderer.prototype.getAllInBox = function(x1, y1, x2, y2) {\n    var nodes = this.getCachedNodes();\n    var edges = this.getCachedEdges();\n    var box = [];\n    \n    var x1c = Math.min(x1, x2);\n    var x2c = Math.max(x1, x2);\n    var y1c = Math.min(y1, y2);\n    var y2c = Math.max(y1, y2); \n\n    x1 = x1c; \n    x2 = x2c; \n    y1 = y1c; \n    y2 = y2c; \n\n    var heur;\n    \n    for ( var i = 0; i < nodes.length; i++ ){\n      var pos = nodes[i]._private.position;\n      var nShape = this.getNodeShape(nodes[i]);\n      var w = this.getNodeWidth(nodes[i]);\n      var h = this.getNodeHeight(nodes[i]);\n      var border = nodes[i]._private.style['border-width'].pxValue / 2;\n      var shapeObj = CanvasRenderer.nodeShapes[ nShape ];\n\n      if ( shapeObj.intersectBox(x1, y1, x2, y2, w, h, pos.x, pos.y, border) ){\n        box.push(nodes[i]);\n      }\n    }\n    \n    for ( var i = 0; i < edges.length; i++ ){\n      var rs = edges[i]._private.rscratch;\n\n      if (edges[i]._private.rscratch.edgeType == 'self') {\n        if ((heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.cp2ax, rs.cp2ay,\n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              &&\n            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.cp2ax, rs.cp2ay,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))\n                ||\n          (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.cp2cx, rs.cp2cy,\n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              &&\n            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.cp2cx, rs.cp2cy,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))\n          )\n        { box.push(edges[i]); }\n      }\n      \n      if (rs.edgeType == 'bezier' &&\n        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.cp2x, rs.cp2y,\n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              &&\n            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.cp2x, rs.cp2y,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))\n        { box.push(edges[i]); }\n    \n      if (rs.edgeType == 'straight' &&\n        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.startX * 0.5 + rs.endX * 0.5, \n            rs.startY * 0.5 + rs.endY * 0.5, \n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              && /* console.log('test', heur) == undefined && */\n            (heur == 2 || (heur == 1 && $$.math.checkStraightEdgeInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))\n        { box.push(edges[i]); }\n\n\n      if (rs.edgeType == 'haystack'){\n        var tgt = edges[i].target()[0];\n        var tgtPos = tgt.position();\n        var src = edges[i].source()[0];\n        var srcPos = src.position();\n\n        var startX = srcPos.x + rs.source.x;\n        var startY = srcPos.y + rs.source.y;\n        var endX = tgtPos.x + rs.target.x;\n        var endY = tgtPos.y + rs.target.y;\n\n        var startInBox = (x1 <= startX && startX <= x2) && (y1 <= startY && startY <= y2);\n        var endInBox = (x1 <= endX && endX <= x2) && (y1 <= endY && endY <= y2);\n\n        if( startInBox && endInBox ){\n          box.push( edges[i] );\n        }\n      }\n      \n    }\n    \n    return box;\n  };\n\n\n  /**\n   * Returns the width of the given node. If the width is set to auto,\n   * returns the value of the autoWidth field.\n   *\n   * @param node          a node\n   * @return {number}     width of the node\n   */\n  CanvasRenderer.prototype.getNodeWidth = function(node)\n  {\n    return node.width();\n  };\n\n  /**\n   * Returns the height of the given node. If the height is set to auto,\n   * returns the value of the autoHeight field.\n   *\n   * @param node          a node\n   * @return {number}     width of the node\n   */\n  CanvasRenderer.prototype.getNodeHeight = function(node)\n  {\n    return node.height();\n  };\n\n  /**\n   * Returns the shape of the given node. If the height or width of the given node\n   * is set to auto, the node is considered to be a compound.\n   *\n   * @param node          a node\n   * @return {String}     shape of the node\n   */\n  CanvasRenderer.prototype.getNodeShape = function(node)\n  {\n    // TODO only allow rectangle for a compound node?\n//    if (node._private.style['width'].value == 'auto' ||\n//        node._private.style['height'].value == 'auto')\n//    {\n//      return 'rectangle';\n//    }\n\n    var shape = node._private.style['shape'].value;\n\n    if( node.isParent() ){\n      if( shape === 'rectangle' || shape === 'roundrectangle' ){\n        return shape;\n      } else {\n        return 'rectangle';\n      }\n    }\n\n    return shape;\n  };\n\n\n  CanvasRenderer.prototype.getNodePadding = function(node)\n  {\n    var left = node._private.style['padding-left'].pxValue;\n    var right = node._private.style['padding-right'].pxValue;\n    var top = node._private.style['padding-top'].pxValue;\n    var bottom = node._private.style['padding-bottom'].pxValue;\n\n    if (isNaN(left))\n    {\n      left = 0;\n    }\n\n    if (isNaN(right))\n    {\n      right = 0;\n    }\n\n    if (isNaN(top))\n    {\n      top = 0;\n    }\n\n    if (isNaN(bottom))\n    {\n      bottom = 0;\n    }\n\n    return {left : left,\n      right : right,\n      top : top,\n      bottom : bottom};\n  };\n\n  CanvasRenderer.prototype.zOrderSort = $$.Collection.zIndexSort;\n\n  CanvasRenderer.prototype.updateCachedZSortedEles = function(){\n    this.getCachedZSortedEles( true );\n  };\n\n  CanvasRenderer.prototype.getCachedZSortedEles = function( forceRecalc ){\n    var lastNodes = this.lastZOrderCachedNodes;\n    var lastEdges = this.lastZOrderCachedEdges;\n    var nodes = this.getCachedNodes();\n    var edges = this.getCachedEdges();\n    var eles = [];\n\n    if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){ \n      //console.time('cachezorder')\n      \n      for( var i = 0; i < nodes.length; i++ ){\n        if( nodes[i].visible() && !nodes[i].transparent() ){\n          eles.push( nodes[i] );\n        }\n      }\n\n      for( var i = 0; i < edges.length; i++ ){\n        if( edges[i].visible() && !edges[i].transparent() ){\n          eles.push( edges[i] );\n        }\n      }\n\n      eles.sort( this.zOrderSort );\n      this.cachedZSortedEles = eles;\n      //console.log('make cache')\n\n      //console.timeEnd('cachezorder')\n    } else {\n      eles = this.cachedZSortedEles;\n      //console.log('read cache')\n    }\n\n    this.lastZOrderCachedNodes = nodes;\n    this.lastZOrderCachedEdges = edges;\n\n    return eles;\n  };\n\n  CanvasRenderer.prototype.projectBezier = function(edge){\n    var qbezierAt = $$.math.qbezierAt;\n    var rs = edge._private.rscratch;\n    var bpts = edge._private.rstyle.bezierPts = [];\n\n    function pushBezierPts(pts){\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )\n      });\n\n      var mid = {\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )\n      };\n\n      bpts.push( mid );\n\n      if( rs.edgeType === 'self' ){\n        rs.midX = rs.selfEdgeMidX;\n        rs.midY = rs.selfEdgeMidY;\n      } else {\n        rs.midX = mid.x;\n        rs.midY = mid.y;\n      }\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )\n      });\n    }\n\n    if( rs.edgeType === 'self' ){\n      pushBezierPts( [rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY] );\n      pushBezierPts( [rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY] );\n    } else if( rs.edgeType === 'bezier' ){\n      pushBezierPts( [rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY] );\n    }\n  };\n\n  CanvasRenderer.prototype.recalculateNodeLabelProjection = function( node ){\n    var content = node._private.style['content'].strValue;\n    if( !content || content.match(/^\\s+$/) ){ return; }\n\n    var textX, textY;\n    var nodeWidth = node.outerWidth();\n    var nodeHeight = node.outerHeight();\n    var nodePos = node._private.position;\n    var textHalign = node._private.style['text-halign'].strValue;\n    var textValign = node._private.style['text-valign'].strValue;\n    var rs = node._private.rscratch;\n    var rstyle = node._private.rstyle;\n\n    switch( textHalign ){\n      case 'left':\n        textX = nodePos.x - nodeWidth / 2;\n        break;\n\n      case 'right':\n        textX = nodePos.x + nodeWidth / 2;\n        break;\n\n      default: // e.g. center\n        textX = nodePos.x;\n    }\n\n    switch( textValign ){\n      case 'top':\n        textY = nodePos.y - nodeHeight / 2;\n        break;\n\n      case 'bottom':\n        textY = nodePos.y + nodeHeight / 2;\n        break;\n\n      default: // e.g. middle\n        textY = nodePos.y;\n    }\n  \n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n\n    this.applyLabelDimensions( node );\n  };\n\n  CanvasRenderer.prototype.recalculateEdgeLabelProjection = function( edge ){\n    var content = edge._private.style['content'].strValue;\n    if( !content || content.match(/^\\s+$/) ){ return; }\n\n    var textX, textY;  \n    var edgeCenterX, edgeCenterY;\n    var rs = edge._private.rscratch;\n    var rstyle = edge._private.rstyle;\n    \n    if (rs.edgeType == 'self') {\n      edgeCenterX = rs.selfEdgeMidX;\n      edgeCenterY = rs.selfEdgeMidY;\n    } else if (rs.edgeType == 'straight') {\n      edgeCenterX = (rs.startX + rs.endX) / 2;\n      edgeCenterY = (rs.startY + rs.endY) / 2;\n    } else if (rs.edgeType == 'bezier') {\n      edgeCenterX = $$.math.qbezierAt( rs.startX, rs.cp2x, rs.endX, 0.5 );\n      edgeCenterY = $$.math.qbezierAt( rs.startY, rs.cp2y, rs.endY, 0.5 );\n    } else if (rs.edgeType == 'haystack') {\n      var srcPos = edge._private.source._private.position;\n      var tgtPos = edge._private.target._private.position;\n\n      edgeCenterX = (srcPos.x + rs.source.x + tgtPos.x + rs.target.x)/2;\n      edgeCenterY = (srcPos.y + rs.source.y + tgtPos.y + rs.target.y)/2;\n    }\n    \n    textX = edgeCenterX;\n    textY = edgeCenterY;\n\n    // add center point to style so bounding box calculations can use it\n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n\n    this.applyLabelDimensions( edge );\n  };\n\n  CanvasRenderer.prototype.applyLabelDimensions = function( ele ){\n    var rs = ele._private.rscratch;\n    var rstyle = ele._private.rstyle;\n\n    var text = this.getLabelText( ele );\n    var labelDims = this.calculateLabelDimensions( ele, text );\n \n    rstyle.labelWidth = labelDims.width;\n    rs.labelWidth = labelDims.width;\n \n    rstyle.labelHeight = labelDims.height;\n    rs.labelHeight = labelDims.height;\n  };\n\n  CanvasRenderer.prototype.getLabelText = function( ele ){\n    var style = ele._private.style;\n    var text = ele._private.style['content'].strValue;\n    var textTransform = style['text-transform'].value;\n    \n    if (textTransform == 'none') {\n    } else if (textTransform == 'uppercase') {\n      text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n      text = text.toLowerCase();\n    }\n\n    return text;\n  };\n\n  CanvasRenderer.prototype.calculateLabelDimensions = function( ele, text ){\n    var r = this;\n    var style = ele._private.style;\n    var fStyle = style['font-style'].strValue;\n    var size = style['font-size'].pxValue + 'px';\n    var family = style['font-family'].strValue;\n    // var variant = style['font-variant'].strValue;\n    var weight = style['font-weight'].strValue;\n\n    var cacheKey = ele._private.labelKey;\n    var cache = r.labelDimCache || (r.labelDimCache = {});\n\n    if( cache[cacheKey] ){\n      return cache[cacheKey];\n    }\n\n    var div = this.labelCalcDiv;\n\n    if( !div ){\n      div = this.labelCalcDiv = document.createElement('div');\n      document.body.appendChild( div );\n    }\n\n    var ds = div.style;\n\n    // from ele style\n    ds.fontFamily = family;\n    ds.fontStyle = fStyle;\n    ds.fontSize = size;\n    // ds.fontVariant = variant;\n    ds.fontWeight = weight;\n\n    // forced style\n    ds.position = 'absolute';\n    ds.left = '-9999px';\n    ds.top = '-9999px';\n    ds.zIndex = '-1';\n    ds.visibility = 'hidden';\n    ds.pointerEvents = 'none';\n    ds.padding = '0';\n    ds.lineHeight = '1';\n\n    // put label content in div\n    div.textContent = text;\n\n    cache[cacheKey] = {\n      width: div.clientWidth,\n      height: div.clientHeight\n    };\n\n    return cache[cacheKey];\n  };  \n\n  CanvasRenderer.prototype.recalculateRenderedStyle = function( eles ){\n    var edges = [];\n    var nodes = [];\n    var handledEdge = {};\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[i];\n      var _p = ele._private;\n      var rs = _p.rscratch;\n      var rstyle = _p.rstyle;\n      var id = _p.data.id;\n      var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;\n      var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;\n      var styleSame = bbStyleSame && labelStyleSame;\n\n      if( ele._private.group === 'nodes' ){\n        var pos = _p.position;\n        var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;\n\n        if( !posSame || !styleSame ){\n          nodes.push( ele );\n        }\n\n        rstyle.nodeX = pos.x;\n        rstyle.nodeY = pos.y;\n      } else { // edges\n\n        var srcPos = ele._private.source._private.position;\n        var tgtPos = ele._private.target._private.position;\n        var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;\n        var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;\n        var positionsSame = srcSame && tgtSame;\n\n        if( !positionsSame || !styleSame ){\n          var curveType = _p.style['curve-style'].value;\n\n          if( curveType === 'bezier' ){\n            if( !handledEdge[ id ] ){\n              edges.push( ele );\n              handledEdge[ id ] = true;\n\n              var parallelEdges = ele.parallelEdges();\n              for( var i = 0; i < parallelEdges.length; i++ ){\n                var pEdge = parallelEdges[i];\n                var pId = pEdge._private.data.id;\n\n                if( !handledEdge[ pId ] ){\n                  edges.push( pEdge );\n                  handledEdge[ pId ] = true;\n                }\n                \n              }\n            }\n          } else {\n            edges.push( ele );\n          }\n        } // if positions diff\n\n        // update rstyle positions\n        rstyle.srcX = srcPos.x;\n        rstyle.srcY = srcPos.y;\n        rstyle.tgtX = tgtPos.x;\n        rstyle.tgtY = tgtPos.y;\n\n      } // if edges\n\n      rs.boundingBoxKey = _p.boundingBoxKey;\n      rs.labelKey = _p.labelKey;\n    }\n\n    this.recalculateEdgeProjections( edges );\n    this.recalculateLabelProjections( nodes, edges );\n  };\n\n  CanvasRenderer.prototype.recalculateLabelProjections = function( nodes, edges ){\n    for( var i = 0; i < nodes.length; i++ ){\n      this.recalculateNodeLabelProjection( nodes[i] );\n    }\n\n    for( var i = 0; i < edges.length; i++ ){\n      this.recalculateEdgeLabelProjection( edges[i] );\n    }\n  };\n\n  CanvasRenderer.prototype.recalculateEdgeProjections = function( edges ){\n    this.findEdgeControlPoints( edges );\n  };\n\n\n  // Find edge control points\n  CanvasRenderer.prototype.findEdgeControlPoints = function(edges) {\n    if( !edges || edges.length === 0 ){ return; }\n\n    var hashTable = {};\n    var pairIds = [];\n    var haystackEdges = [];\n\n    // create a table of edge (src, tgt) => list of edges between them\n    var pairId;\n    for (var i = 0; i < edges.length; i++){\n      var edge = edges[i];\n      var style = edge._private.style;\n      var edgeIsUnbundled = style['curve-style'].value === 'unbundled-bezier';\n\n      // ignore edges who are not to be displayed\n      // they shouldn't take up space\n      if( style.display.value === 'none' ){\n        continue;\n      }\n\n      if( style['curve-style'].value === 'haystack' ){\n        haystackEdges.push( edge );\n        continue;\n      }\n\n      var srcId = edge._private.data.source;\n      var tgtId = edge._private.data.target;\n\n      pairId = srcId > tgtId ?\n        tgtId + '-' + srcId :\n        srcId + '-' + tgtId ;\n\n      if( edgeIsUnbundled ){\n        pairId = 'unbundled' + edge._private.data.id;\n      }\n\n      if (hashTable[pairId] == null) {\n        hashTable[pairId] = [];\n        pairIds.push( pairId );\n      }\n      \n      hashTable[pairId].push( edge );\n\n      if( edgeIsUnbundled ){\n        hashTable[pairId].hasUnbundled = true;\n      }\n    }\n\n    var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape, srcBorder, tgtBorder;\n    var vectorNormInverse;\n    var badBezier;\n    \n    // for each pair (src, tgt), create the ctrl pts\n    // Nested for loop is OK; total number of iterations for both loops = edgeCount  \n    for (var p = 0; p < pairIds.length; p++) {\n      pairId = pairIds[p];\n      var pairEdges = hashTable[pairId];\n    \n      // for each pair id, the edges should be sorted by index\n      pairEdges.sort(function(edge1, edge2){\n        return edge1._private.index - edge2._private.index;\n      });\n\n      src = pairEdges[0]._private.source;\n      tgt = pairEdges[0]._private.target;\n\n      // make sure src/tgt distinction is consistent\n      // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)\n      if( src._private.data.id > tgt._private.data.id ){\n        var temp = src;\n        src = tgt;\n        tgt = temp;\n      }\n\n      srcPos = src._private.position;\n      tgtPos = tgt._private.position;\n\n      srcW = this.getNodeWidth(src);\n      srcH = this.getNodeHeight(src);\n\n      tgtW = this.getNodeWidth(tgt);\n      tgtH = this.getNodeHeight(tgt);\n\n      srcShape = CanvasRenderer.nodeShapes[ this.getNodeShape(src) ];\n      tgtShape = CanvasRenderer.nodeShapes[ this.getNodeShape(tgt) ];\n\n      srcBorder = src._private.style['border-width'].pxValue;\n      tgtBorder = tgt._private.style['border-width'].pxValue;\n\n      badBezier = false;\n      \n\n      if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){\n\n        // pt outside src shape to calc distance/displacement from src to tgt\n        var srcOutside = srcShape.intersectLine(\n          srcPos.x,\n          srcPos.y,\n          srcW,\n          srcH,\n          tgtPos.x,\n          tgtPos.y,\n          srcBorder / 2\n        );\n\n        // pt outside tgt shape to calc distance/displacement from src to tgt\n        var tgtOutside = tgtShape.intersectLine(\n          tgtPos.x,\n          tgtPos.y,\n          tgtW,\n          tgtH,\n          srcPos.x,\n          srcPos.y,\n          tgtBorder / 2\n        );\n\n        var midptSrcPts = {\n          x1: srcOutside[0],\n          x2: tgtOutside[0],\n          y1: srcOutside[1],\n          y2: tgtOutside[1]\n        };\n\n        var dy = ( tgtOutside[1] - srcOutside[1] );\n        var dx = ( tgtOutside[0] - srcOutside[0] );\n        var l = Math.sqrt( dx*dx + dy*dy );\n\n        var vector = {\n          x: dx,\n          y: dy\n        };\n        \n        var vectorNorm = {\n          x: vector.x/l,\n          y: vector.y/l\n        };\n        vectorNormInverse = {\n          x: -vectorNorm.y,\n          y: vectorNorm.x\n        };\n\n        // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw\n        if( \n          tgtShape.checkPoint( srcOutside[0], srcOutside[1], tgtBorder/2, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||\n          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], srcBorder/2, srcW, srcH, srcPos.x, srcPos.y ) \n        ){\n          vectorNormInverse = {};\n          badBezier = true;\n        }\n        \n      }\n      \n      var edge;\n      var rs;\n      \n      for (var i = 0; i < pairEdges.length; i++) {\n        edge = pairEdges[i];\n        rs = edge._private.rscratch;\n        \n        var edgeIndex1 = rs.lastEdgeIndex;\n        var edgeIndex2 = i;\n\n        var numEdges1 = rs.lastNumEdges;\n        var numEdges2 = pairEdges.length;\n\n        var eStyle = edge._private.style;\n        var stepSize = eStyle['control-point-step-size'].pxValue;\n        var stepDist = eStyle['control-point-distance'] !== undefined ? eStyle['control-point-distance'].pxValue : undefined;\n        var stepWeight = eStyle['control-point-weight'].value;\n        var edgeIsUnbundled = eStyle['curve-style'].value === 'unbundled-bezier';\n\n        var srcX1 = rs.lastSrcCtlPtX;\n        var srcX2 = srcPos.x;\n        var srcY1 = rs.lastSrcCtlPtY;\n        var srcY2 = srcPos.y;\n        var srcW1 = rs.lastSrcCtlPtW;\n        var srcW2 = src.outerWidth();\n        var srcH1 = rs.lastSrcCtlPtH;\n        var srcH2 = src.outerHeight();\n\n        var tgtX1 = rs.lastTgtCtlPtX;\n        var tgtX2 = tgtPos.x;\n        var tgtY1 = rs.lastTgtCtlPtY;\n        var tgtY2 = tgtPos.y;\n        var tgtW1 = rs.lastTgtCtlPtW;\n        var tgtW2 = tgt.outerWidth();\n        var tgtH1 = rs.lastTgtCtlPtH;\n        var tgtH2 = tgt.outerHeight();\n\n        if( badBezier ){\n          rs.badBezier = true;\n        } else {\n          rs.badBezier = false;\n        }\n\n        if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2\n        &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2\n        &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){\n          // console.log('edge ctrl pt cache HIT')\n          continue; // then the control points haven't changed and we can skip calculating them\n        } else {\n          rs.lastSrcCtlPtX = srcX2;\n          rs.lastSrcCtlPtY = srcY2;\n          rs.lastSrcCtlPtW = srcW2;\n          rs.lastSrcCtlPtH = srcH2;\n          rs.lastTgtCtlPtX = tgtX2;\n          rs.lastTgtCtlPtY = tgtY2;\n          rs.lastTgtCtlPtW = tgtW2;\n          rs.lastTgtCtlPtH = tgtH2;\n          rs.lastEdgeIndex = edgeIndex2;\n          rs.lastNumEdges = numEdges2;\n          // console.log('edge ctrl pt cache MISS')\n        }\n\n        // Self-edge\n        if ( src === tgt ) {\n            \n          rs.edgeType = 'self';\n          \n          var j = i;\n          var loopDist = stepSize;\n\n          if( edgeIsUnbundled ){\n            j = 0;\n            loopDist = stepDist;\n          }\n\n          // New -- fix for large nodes\n          rs.cp2ax = srcPos.x;\n          rs.cp2ay = srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1);\n          \n          rs.cp2cx = src._private.position.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1);\n          rs.cp2cy = srcPos.y;\n          \n          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;\n          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;\n          \n        // Straight edge\n        } else if (pairEdges.length % 2 === 1\n          && i === Math.floor(pairEdges.length / 2)\n          && !edgeIsUnbundled ) {\n          \n          rs.edgeType = 'straight';\n          \n        // Bezier edge\n        } else {\n          var normStepDist = (0.5 - pairEdges.length / 2 + i) * stepSize;\n          var manStepDist;\n          var sign = $$.math.signum( normStepDist );\n\n          if( edgeIsUnbundled ){\n            manStepDist = stepDist;\n          } else {\n            manStepDist = stepDist !== undefined ? sign * stepDist : undefined; \n          }\n\n          var distanceFromMidpoint = manStepDist !== undefined ? manStepDist : normStepDist;\n          \n          var w1 = (1 - stepWeight);\n          var w2 = stepWeight;\n\n          var swappedDirection = edge._private.source !== src;\n          if( swappedDirection ){\n            w1 = stepWeight;\n            w2 = (1 - stepWeight);\n          }\n\n          var adjustedMidpt = {\n            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,\n            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2\n          };\n\n          rs.edgeType = 'bezier';\n          \n          rs.cp2x = adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint;\n          rs.cp2y = adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint;\n          \n          // console.log(edge, midPointX, displacementX, distanceFromMidpoint);\n        }\n\n        // find endpts for edge\n        this.findEndpoints( edge );\n\n        var badStart = !$$.is.number( rs.startX ) || !$$.is.number( rs.startY );\n        var badAStart = !$$.is.number( rs.arrowStartX ) || !$$.is.number( rs.arrowStartY );\n        var badEnd = !$$.is.number( rs.endX ) || !$$.is.number( rs.endY );\n        var badAEnd = !$$.is.number( rs.arrowEndX ) || !$$.is.number( rs.arrowEndY );\n\n        var minCpADistFactor = 3;\n        var arrowW = this.getArrowWidth( edge._private.style['width'].pxValue ) * CanvasRenderer.arrowShapeHeight;\n        var minCpADist = minCpADistFactor * arrowW;\n        var startACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.startX, y: rs.startY } );\n        var closeStartACp = startACpDist < minCpADist;\n        var endACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.endX, y: rs.endY } );\n        var closeEndACp = endACpDist < minCpADist;\n\n        if( rs.edgeType === 'bezier' ){\n          var overlapping = false;\n\n          if( badStart || badAStart || closeStartACp ){\n            overlapping = true;\n\n            // project control point along line from src centre to outside the src shape\n            // (otherwise intersection will yield nothing)\n            var cpD = { // delta\n              x: rs.cp2x - srcPos.x,\n              y: rs.cp2y - srcPos.y\n            };\n            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line\n            var cpM = { // normalised delta\n              x: cpD.x / cpL,\n              y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = { // *2 radius guarantees outside shape\n              x: rs.cp2x + cpM.x * 2 * radius,\n              y: rs.cp2y + cpM.y * 2 * radius\n            };\n\n            var srcCtrlPtIntn = srcShape.intersectLine(\n              srcPos.x,\n              srcPos.y,\n              srcW,\n              srcH,\n              cpProj.x,\n              cpProj.y,\n              srcBorder / 2\n            );\n\n            if( closeStartACp ){\n              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - startACpDist); \n              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - startACpDist);\n            } else {\n              rs.cp2x = srcCtrlPtIntn[0] + cpM.x * minCpADist; \n              rs.cp2y = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n          }\n\n          if( badEnd || badAEnd || closeEndACp ){\n            overlapping = true;\n\n            // project control point along line from tgt centre to outside the tgt shape\n            // (otherwise intersection will yield nothing)\n            var cpD = { // delta\n              x: rs.cp2x - tgtPos.x,\n              y: rs.cp2y - tgtPos.y\n            };\n            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line\n            var cpM = { // normalised delta\n              x: cpD.x / cpL,\n              y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = { // *2 radius guarantees outside shape\n              x: rs.cp2x + cpM.x * 2 * radius,\n              y: rs.cp2y + cpM.y * 2 * radius\n            };\n\n            var tgtCtrlPtIntn = tgtShape.intersectLine(\n              tgtPos.x,\n              tgtPos.y,\n              tgtW,\n              tgtH,\n              cpProj.x,\n              cpProj.y,\n              tgtBorder / 2\n            );\n\n            if( closeEndACp ){\n              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - endACpDist); \n              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - endACpDist);\n            } else {\n              rs.cp2x = tgtCtrlPtIntn[0] + cpM.x * minCpADist; \n              rs.cp2y = tgtCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n            \n          }\n\n          if( overlapping ){\n            // recalc endpts\n            this.findEndpoints( edge );\n          }\n        } else if( rs.edgeType === 'straight' ){\n          rs.midX = ( srcX2 + tgtX2 )/2;\n          rs.midY = ( srcY2 + tgtY2 )/2;\n        }\n\n        // project the edge into rstyle\n        this.projectBezier( edge );\n\n      }\n    }\n      \n    for( var i = 0; i < haystackEdges.length; i++ ){\n      var edge = haystackEdges[i];\n      var rscratch = edge._private.rscratch;\n\n      if( !rscratch.haystack ){\n        var angle = Math.random() * 2 * Math.PI;\n\n        rscratch.source = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n\n        var angle = Math.random() * 2 * Math.PI;\n\n        rscratch.target = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n\n        rscratch.edgeType = 'haystack';\n        rscratch.haystack = true;\n      }  \n    }\n\n    return hashTable;\n  };\n\n  CanvasRenderer.prototype.findEndpoints = function(edge) {\n    var intersect;\n\n    var source = edge.source()[0];\n    var target = edge.target()[0];\n    \n    var tgtArShape = edge._private.style['target-arrow-shape'].value;\n    var srcArShape = edge._private.style['source-arrow-shape'].value;\n\n    var tgtBorderW = target._private.style['border-width'].pxValue;\n    var srcBorderW = source._private.style['border-width'].pxValue;\n\n    var rs = edge._private.rscratch;\n    \n    if (edge._private.rscratch.edgeType == 'self') {\n      \n      var cp = [rs.cp2cx, rs.cp2cy];\n      \n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(\n        target._private.position.x,\n        target._private.position.y,\n        this.getNodeWidth(target),\n        this.getNodeHeight(target),\n        cp[0],\n        cp[1], \n        tgtBorderW / 2\n      );\n      \n      var arrowEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));\n      var edgeEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));\n      \n      rs.endX = edgeEnd[0];\n      rs.endY = edgeEnd[1];\n      \n      rs.arrowEndX = arrowEnd[0];\n      rs.arrowEndY = arrowEnd[1];\n      \n      var cp = [rs.cp2ax, rs.cp2ay];\n\n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(\n        source._private.position.x,\n        source._private.position.y,\n        this.getNodeWidth(source),\n        this.getNodeHeight(source),\n        cp[0], //halfPointX,\n        cp[1], //halfPointY\n        srcBorderW / 2\n      );\n      \n      var arrowStart = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));\n      var edgeStart = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[srcArShape].gap(edge));\n      \n      rs.startX = edgeStart[0];\n      rs.startY = edgeStart[1];\n\n\n      rs.arrowStartX = arrowStart[0];\n      rs.arrowStartY = arrowStart[1];\n      \n    } else if (rs.edgeType == 'straight') {\n    \n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(\n        target._private.position.x,\n        target._private.position.y,\n        this.getNodeWidth(target),\n        this.getNodeHeight(target),\n        source.position().x,\n        source.position().y,\n        tgtBorderW / 2);\n        \n      if (intersect.length === 0) {\n        rs.noArrowPlacement = true;\n  //      return;\n      } else {\n        rs.noArrowPlacement = false;\n      }\n      \n      var arrowEnd = $$.math.shortenIntersection(intersect,\n        [source.position().x, source.position().y],\n        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));\n      var edgeEnd = $$.math.shortenIntersection(intersect,\n        [source.position().x, source.position().y],\n        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));\n\n      rs.endX = edgeEnd[0];\n      rs.endY = edgeEnd[1];\n      \n      rs.arrowEndX = arrowEnd[0];\n      rs.arrowEndY = arrowEnd[1];\n    \n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(\n        source._private.position.x,\n        source._private.position.y,\n        this.getNodeWidth(source),\n        this.getNodeHeight(source),\n        target.position().x,\n        target.position().y,\n        srcBorderW / 2);\n      \n      if (intersect.length === 0) {\n        rs.noArrowPlacement = true;\n  //      return;\n      } else {\n        rs.noArrowPlacement = false;\n      }\n      \n      /*\n      console.log(\"1: \"\n        + CanvasRenderer.arrowShapes[srcArShape],\n          srcArShape);\n      */\n      var arrowStart = $$.math.shortenIntersection(intersect,\n        [target.position().x, target.position().y],\n        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));\n      var edgeStart = $$.math.shortenIntersection(intersect,\n        [target.position().x, target.position().y],\n        CanvasRenderer.arrowShapes[srcArShape].gap(edge));\n\n      rs.startX = edgeStart[0];\n      rs.startY = edgeStart[1];\n      \n      rs.arrowStartX = arrowStart[0];\n      rs.arrowStartY = arrowStart[1];\n            \n    } else if (rs.edgeType == 'bezier') {\n      // if( window.badArrow) debugger;\n      var cp = [rs.cp2x, rs.cp2y];\n      \n      intersect = CanvasRenderer.nodeShapes[\n        this.getNodeShape(target)].intersectLine(\n        target._private.position.x,\n        target._private.position.y,\n        this.getNodeWidth(target),\n        this.getNodeHeight(target),\n        cp[0], //halfPointX,\n        cp[1], //halfPointY\n        tgtBorderW / 2\n      );\n      \n      /*\n      console.log(\"2: \"\n        + CanvasRenderer.arrowShapes[srcArShape],\n          srcArShape);\n      */\n      var arrowEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));\n      var edgeEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));\n      \n      rs.endX = edgeEnd[0];\n      rs.endY = edgeEnd[1];\n      \n      rs.arrowEndX = arrowEnd[0];\n      rs.arrowEndY = arrowEnd[1];\n      \n      intersect = CanvasRenderer.nodeShapes[\n        this.getNodeShape(source)].intersectLine(\n        source._private.position.x,\n        source._private.position.y,\n        this.getNodeWidth(source),\n        this.getNodeHeight(source),\n        cp[0], //halfPointX,\n        cp[1], //halfPointY\n        srcBorderW / 2\n      );\n      \n      var arrowStart = $$.math.shortenIntersection(\n        intersect, \n        cp,\n        CanvasRenderer.arrowShapes[srcArShape].spacing(edge)\n      );\n      var edgeStart = $$.math.shortenIntersection(\n        intersect, \n        cp,\n        CanvasRenderer.arrowShapes[srcArShape].gap(edge)\n      );\n    \n      rs.startX = edgeStart[0];\n      rs.startY = edgeStart[1];\n      \n      rs.arrowStartX = arrowStart[0];\n      rs.arrowStartY = arrowStart[1];\n      \n      // if( isNaN(rs.startX) || isNaN(rs.startY) ){\n      //   debugger;\n      // }\n\n    } else if (rs.isArcEdge) {\n      return;\n    }\n  };\n\n  // Find adjacent edges\n  CanvasRenderer.prototype.findEdges = function(nodeSet) {\n    \n    var edges = this.getCachedEdges();\n    \n    var hashTable = {};\n    var adjacentEdges = [];\n    \n    for (var i = 0; i < nodeSet.length; i++) {\n      hashTable[nodeSet[i]._private.data.id] = nodeSet[i];\n    }\n    \n    for (var i = 0; i < edges.length; i++) {\n      if (hashTable[edges[i]._private.data.source]\n        || hashTable[edges[i]._private.data.target]) {\n        \n        adjacentEdges.push(edges[i]);\n      }\n    }\n    \n    return adjacentEdges;\n  };\n\n  CanvasRenderer.prototype.getArrowWidth = CanvasRenderer.prototype.getArrowHeight = function(edgeWidth) {\n    var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n\n    var cachedVal = cache[edgeWidth];\n    if( cachedVal ){\n      return cachedVal;\n    }\n\n    cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);\n    cache[edgeWidth] = cachedVal;\n\n    return cachedVal;\n  };\n\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n// Draw edge\n  CanvasRenderer.prototype.drawEdge = function(context, edge, drawOverlayInstead) {\n    var rs = edge._private.rscratch;\n    var usePaths = CanvasRenderer.usePaths();\n\n    // if bezier ctrl pts can not be calculated, then die\n    if( rs.badBezier || ( (rs.edgeType === 'bezier' || rs.edgeType === 'straight') && isNaN(rs.startX)) ){ // extra isNaN() for safari 7.1 b/c it mangles ctrlpt calcs\n      return;\n    }\n\n    var style = edge._private.style;\n    \n    // Edge line width\n    if (style['width'].pxValue <= 0) {\n      return;\n    }\n\n    var overlayPadding = style['overlay-padding'].pxValue;\n    var overlayOpacity = style['overlay-opacity'].value;\n    var overlayColor = style['overlay-color'].value;\n\n    // Edge color & opacity\n    if( drawOverlayInstead ){\n\n      if( overlayOpacity === 0 ){ // exit early if no overlay\n        return;\n      }\n\n      this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);\n      context.lineCap = 'round';\n\n      if( edge._private.rscratch.edgeType == 'self' && !usePaths ){\n        context.lineCap = 'butt';\n      }\n\n    } else {\n      var lineColor = style['line-color'].value;\n\n      this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);\n      \n      context.lineCap = 'butt'; \n    }\n    \n    var startNode, endNode, source, target;\n    source = startNode = edge._private.source;\n    target = endNode = edge._private.target;\n\n    var targetPos = target._private.position;\n    var targetW = target.width();\n    var targetH = target.height();\n    var sourcePos = source._private.position;\n    var sourceW = source.width();\n    var sourceH = source.height();\n\n\n    var edgeWidth = style['width'].pxValue + (drawOverlayInstead ? 2 * overlayPadding : 0);\n    var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;\n    context.lineWidth = edgeWidth;\n    \n    if( rs.edgeType !== 'haystack' ){\n      //this.findEndpoints(edge);\n    }\n    \n    if( rs.edgeType === 'haystack' ){\n      var radius = style['haystack-radius'].value;\n      var halfRadius = radius/2; // b/c have to half width/height\n\n      this.drawStyledEdge(\n        edge, \n        context, \n        rs.haystackPts = [\n          rs.source.x * sourceW * halfRadius + sourcePos.x,\n          rs.source.y * sourceH * halfRadius + sourcePos.y,\n          rs.target.x * targetW * halfRadius + targetPos.x,\n          rs.target.y * targetH * halfRadius + targetPos.y\n        ],\n        lineStyle,\n        edgeWidth\n      );\n    } else if (rs.edgeType === 'self') {\n      \n      var details = edge._private.rscratch;\n      var points = [details.startX, details.startY, details.cp2ax,\n        details.cp2ay, details.selfEdgeMidX, details.selfEdgeMidY,\n        details.selfEdgeMidX, details.selfEdgeMidY,\n        details.cp2cx, details.cp2cy, details.endX, details.endY];\n\n      var details = edge._private.rscratch;\n      this.drawStyledEdge(edge, context, points, lineStyle, edgeWidth);\n      \n    } else if (rs.edgeType === 'straight') {\n      \n      var nodeDirectionX = endNode._private.position.x - startNode._private.position.x;\n      var nodeDirectionY = endNode._private.position.y - startNode._private.position.y;\n      \n      var edgeDirectionX = rs.endX - rs.startX;\n      var edgeDirectionY = rs.endY - rs.startY;\n      \n      if (nodeDirectionX * edgeDirectionX\n        + nodeDirectionY * edgeDirectionY < 0) {\n        \n        rs.straightEdgeTooShort = true;  \n      } else {\n        \n        var details = rs;\n        this.drawStyledEdge(edge, context, [details.startX, details.startY,\n                                      details.endX, details.endY],\n                                      lineStyle,\n                                      edgeWidth);\n        \n        rs.straightEdgeTooShort = false;  \n      }  \n    } else {\n      \n      var details = rs;\n      \n      this.drawStyledEdge(edge, context, [details.startX, details.startY,\n        details.cp2x, details.cp2y, details.endX, details.endY],\n        lineStyle,\n        edgeWidth);\n      \n    }\n    \n    if( rs.edgeType === 'haystack' ){\n      this.drawArrowheads(context, edge, drawOverlayInstead);\n    } else if ( rs.noArrowPlacement !== true && rs.startX !== undefined ){\n      this.drawArrowheads(context, edge, drawOverlayInstead);\n    }\n\n  };\n  \n  \n  CanvasRenderer.prototype.drawStyledEdge = function(\n      edge, context, pts, type, width) {\n\n    // 3 points given -> assume Bezier\n    // 2 -> assume straight\n    \n    var rs = edge._private.rscratch;\n    var canvasCxt = context;\n    var path;\n    var pathCacheHit = false;\n    var usePaths = CanvasRenderer.usePaths();\n\n\n    if( usePaths ){\n\n      var pathCacheKey = pts;\n      var keyLengthMatches = rs.pathCacheKey && pathCacheKey.length === rs.pathCacheKey.length;\n      var keyMatches = keyLengthMatches;\n\n      for( var i = 0; keyMatches && i < pathCacheKey.length; i++ ){\n        if( rs.pathCacheKey[i] !== pathCacheKey[i] ){\n          keyMatches = false;\n        }\n      }\n\n      if( keyMatches ){\n        path = context = rs.pathCache;\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        rs.pathCacheKey = pathCacheKey;\n        rs.pathCache = path;\n      }\n\n    }\n\n    if( canvasCxt.setLineDash ){ // for very outofdate browsers\n      switch( type ){\n        case 'dotted':\n          canvasCxt.setLineDash([ 1, 1 ]);\n          break;\n\n        case 'dashed':\n          canvasCxt.setLineDash([ 6, 3 ]);\n          break;\n\n        case 'solid':\n          canvasCxt.setLineDash([ ]);\n          break;\n      }\n    }\n\n    if( !pathCacheHit ){\n      if( context.beginPath ){ context.beginPath(); }\n      context.moveTo(pts[0], pts[1]);\n      \n      if (pts.length === 3 * 2) { // bezier\n        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);\n      } else if( pts.length === 3 * 2 * 2 ){ // double bezier loop\n        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);\n        context.quadraticCurveTo(pts[8], pts[9], pts[10], pts[11]);\n      } else { // line\n        context.lineTo(pts[2], pts[3]);\n      }\n    }\n\n    context = canvasCxt;\n    if( usePaths ){\n      context.stroke( path );\n    } else {\n      context.stroke();\n    }\n  \n    // reset any line dashes\n    if( context.setLineDash ){ // for very outofdate browsers\n      context.setLineDash([ ]);\n    }\n\n  };\n\n  CanvasRenderer.prototype.drawArrowheads = function(context, edge, drawOverlayInstead) {\n    if( drawOverlayInstead ){ return; } // don't do anything for overlays \n\n    var rs = edge._private.rscratch;\n    var self = this;\n    var isHaystack = rs.edgeType === 'haystack';\n\n    // Displacement gives direction for arrowhead orientation\n    var dispX, dispY;\n    var startX, startY, endX, endY;\n\n    var srcPos = edge.source().position();\n    var tgtPos = edge.target().position();\n\n    if( isHaystack ){\n      startX = rs.haystackPts[0];\n      startY = rs.haystackPts[1];\n      endX = rs.haystackPts[2];\n      endY = rs.haystackPts[3];\n    } else {\n      startX = rs.arrowStartX;\n      startY = rs.arrowStartY;\n      endX = rs.arrowEndX;\n      endY = rs.arrowEndY;\n    }\n\n    var style = edge._private.style;\n    \n    function drawArrowhead( prefix, x, y, dispX, dispY ){\n      var arrowShape = style[prefix + '-arrow-shape'].value;\n\n      if( arrowShape === 'none' ){\n        return;\n      }\n\n      var gco = context.globalCompositeOperation;\n\n      context.globalCompositeOperation = 'destination-out';\n      \n      self.fillStyle(context, 255, 255, 255, 1);\n\n\n      var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';\n      var arrowFill = style[prefix + '-arrow-fill'].value;\n\n      if( arrowShape === 'half-triangle-overshot' ){\n        arrowFill = 'hollow';\n        arrowClearFill = 'hollow';\n      }\n\n      self.drawArrowShape( edge, prefix, context, \n        arrowClearFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, \n        x, y, dispX, dispY\n      );\n\n      context.globalCompositeOperation = gco;\n\n      var color = style[prefix + '-arrow-color'].value;\n      self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);\n\n      self.drawArrowShape( edge, prefix, context, \n        arrowFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, \n        x, y, dispX, dispY\n      );\n    }\n\n    dispX = startX - srcPos.x;\n    dispY = startY - srcPos.y;\n\n    if( !isHaystack && !isNaN(startX) && !isNaN(startY) && !isNaN(dispX) && !isNaN(dispY) ){\n      drawArrowhead( 'source', startX, startY, dispX, dispY );\n\n    } else {\n      // window.badArrow = true;\n      // debugger;\n    }\n    \n    var midX = rs.midX;\n    var midY = rs.midY;\n\n    if( isHaystack ){\n      midX = ( startX + endX )/2;\n      midY = ( startY + endY )/2;\n    }\n\n    dispX = startX - endX;\n    dispY = startY - endY;\n\n    if( rs.edgeType === 'self' ){\n      dispX = 1;\n      dispY = -1;\n    }\n\n    if( !isNaN(midX) && !isNaN(midY) ){\n      drawArrowhead( 'mid-target', midX, midY, dispX, dispY );\n    }\n\n    dispX *= -1;\n    dispY *= -1;\n\n    if( !isNaN(midX) && !isNaN(midY) ){\n      drawArrowhead( 'mid-source', midX, midY, dispX, dispY );\n    }\n    \n    dispX = endX - tgtPos.x;\n    dispY = endY - tgtPos.y;\n    \n    if( !isHaystack && !isNaN(endX) && !isNaN(endY) && !isNaN(dispX) && !isNaN(dispY) ){\n      drawArrowhead( 'target', endX, endY, dispX, dispY );\n    }\n  };\n  \n  // Draw arrowshape\n  CanvasRenderer.prototype.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, dispX, dispY) {\n    var usePaths = CanvasRenderer.usePaths();\n    var rs = edge._private.rscratch;\n    var pathCacheHit = false;\n    var path;\n    var canvasContext = context;\n    var translation = { x: x, y: y };\n\n    // Negative of the angle\n    var angle = Math.asin(dispY / (Math.sqrt(dispX * dispX + dispY * dispY)));\n  \n    if (dispX < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = - (Math.PI / 2 + angle);\n    }\n    \n    var size = this.getArrowWidth( edgeWidth );\n    var shapeImpl = CanvasRenderer.arrowShapes[shape];\n\n    // context.translate(x, y);\n\n    if( usePaths ){\n      var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;\n      rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};\n      rs.arrowPathCache = rs.arrowPathCache || {};\n\n      var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;\n      if( alreadyCached ){\n        path = context = rs.arrowPathCache[arrowType];\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        rs.arrowPathCacheKey[arrowType] = pathCacheKey;\n        rs.arrowPathCache[arrowType] = path;\n      }\n    }\n\n    if( context.beginPath ){ context.beginPath(); }\n\n    if( !pathCacheHit ){\n      shapeImpl.draw(context, size, angle, translation);\n    }\n    \n    if( !shapeImpl.leavePathOpen && context.closePath ){\n      context.closePath();\n    }\n\n    context = canvasContext;\n\n    if( fill === 'filled' || fill === 'both' ){\n      if( usePaths ){\n        context.fill( path );\n      } else {\n        context.fill();\n      }\n    }\n\n    if( fill === 'hollow' || fill === 'both' ){\n      context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );\n      context.lineJoin = 'miter';\n\n      if( usePaths ){\n        context.stroke( path );\n      } else {\n        context.stroke();\n      }\n      \n    }\n\n    // context.translate(-x, -y);\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.getCachedImage = function(url, onLoad) {\n    var r = this;\n    var imageCache = r.imageCache = r.imageCache || {};\n\n    if( imageCache[url] && imageCache[url].image ){\n      return imageCache[url].image;\n    }\n    \n    var cache = imageCache[url] = imageCache[url] || {};\n\n    var image = cache.image = new Image();\n    image.addEventListener('load', onLoad);\n    image.src = url;\n    \n    return image;\n  };\n    \n  CanvasRenderer.prototype.drawInscribedImage = function(context, img, node) {\n    var r = this;\n    var nodeX = node._private.position.x;\n    var nodeY = node._private.position.y;\n    var style = node._private.style;\n    var fit = style['background-fit'].value;\n    var xPos = style['background-position-x'];\n    var yPos = style['background-position-y'];\n    var repeat = style['background-repeat'].value;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var rs = node._private.rscratch;\n    var clip = style['background-clip'].value;\n    var shouldClip = clip === 'node';\n    var imgOpacity = style['background-image-opacity'].value;\n    \n    var w = img.width;\n    var h = img.height;\n\n    if( w === 0 || h === 0 ){\n      return; // no point in drawing empty image (and chrome is broken in this case)\n    }\n\n    if( fit === 'contain' ){\n      var scale = Math.min( nodeW/w, nodeH/h );\n\n      w *= scale;\n      h *= scale;\n\n    } else if( fit === 'cover' ){\n      var scale = Math.max( nodeW/w, nodeH/h );\n\n      w *= scale;\n      h *= scale;\n    }\n\n    var x = (nodeX - nodeW/2); // left\n    if( xPos.units === '%' ){\n      x += (nodeW - w) * xPos.value/100;\n    } else {\n      x += xPos.pxValue;\n    }\n\n    var y = (nodeY - nodeH/2); // top\n    if( yPos.units === '%' ){\n      y += (nodeH - h) * yPos.value/100;\n    } else {\n      y += yPos.pxValue;\n    }\n\n    if( rs.pathCache ){\n      x -= nodeX;\n      y -= nodeY;\n\n      nodeX = 0;\n      nodeY = 0;\n    }\n\n    var gAlpha = context.globalAlpha;\n\n    context.globalAlpha = imgOpacity;\n\n    if( repeat === 'no-repeat' ){\n\n      if( shouldClip ){\n        context.save();\n\n        if( rs.pathCache ){\n          context.clip( rs.pathCache );\n        } else {\n          CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(\n            context,\n            nodeX, nodeY, \n            nodeW, nodeH);\n\n          context.clip();\n        }\n      }\n\n      context.drawImage( img, 0, 0, img.width, img.height, x, y, w, h );\n\n      if( shouldClip ){\n        context.restore();\n      }\n    } else {\n      var pattern = context.createPattern( img, repeat );\n      context.fillStyle = pattern;\n\n      CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(\n          context,\n          nodeX, nodeY, \n          nodeW, nodeH);\n\n        context.translate(x, y);\n        context.fill();\n        context.translate(-x, -y);\n    }\n\n    context.globalAlpha = gAlpha;\n    \n  };\n\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // Draw edge text\n  CanvasRenderer.prototype.drawEdgeText = function(context, edge) {\n    var text = edge._private.style['content'].strValue;\n\n    if( !text || text.match(/^\\s+$/) ){\n      return;\n    }\n\n    if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching\n\n    var computedSize = edge._private.style['font-size'].pxValue * edge.cy().zoom();\n    var minSize = edge._private.style['min-zoomed-font-size'].pxValue;\n\n    if( computedSize < minSize ){\n      return;\n    }\n  \n    // Calculate text draw position\n    \n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    \n    // this.recalculateEdgeLabelProjection( edge );\n    \n    var rs = edge._private.rscratch;\n    this.drawText(context, edge, rs.labelX, rs.labelY);\n  };\n\n  // Draw node text\n  CanvasRenderer.prototype.drawNodeText = function(context, node) {\n    var text = node._private.style['content'].strValue;\n\n    if ( !text || text.match(/^\\s+$/) ) {\n      return;\n    }\n\n    var computedSize = node._private.style['font-size'].pxValue * node.cy().zoom();\n    var minSize = node._private.style['min-zoomed-font-size'].pxValue;\n\n    if( computedSize < minSize ){\n      return;\n    }\n      \n    // this.recalculateNodeLabelProjection( node );\n\n    var textHalign = node._private.style['text-halign'].strValue;\n    var textValign = node._private.style['text-valign'].strValue;\n    var rs = node._private.rscratch;\n\n    switch( textHalign ){\n      case 'left':\n        context.textAlign = 'right';\n        break;\n\n      case 'right':\n        context.textAlign = 'left';\n        break;\n\n      default: // e.g. center\n        context.textAlign = 'center';\n    }\n\n    switch( textValign ){\n      case 'top':\n        context.textBaseline = 'bottom';\n        break;\n\n      case 'bottom':\n        context.textBaseline = 'top';\n        break;\n\n      default: // e.g. center\n        context.textBaseline = 'middle';\n    }\n\n    this.drawText(context, node, rs.labelX, rs.labelY);\n  };\n  \n  CanvasRenderer.prototype.getFontCache = function(context){\n    var cache;\n\n    this.fontCaches = this.fontCaches || [];\n\n    for( var i = 0; i < this.fontCaches.length; i++ ){\n      cache = this.fontCaches[i];\n\n      if( cache.context === context ){\n        return cache;\n      }\n    }\n\n    cache = {\n      context: context\n    };\n    this.fontCaches.push(cache);\n\n    return cache;\n  };\n\n  // set up canvas context with font\n  // returns transformed text string\n  CanvasRenderer.prototype.setupTextStyle = function( context, element ){\n    // Font style\n    var parentOpacity = element.effectiveOpacity();\n    var style = element._private.style;\n    var labelStyle = style['font-style'].strValue;\n    var labelSize = style['font-size'].pxValue + 'px';\n    var labelFamily = style['font-family'].strValue;\n    var labelWeight = style['font-weight'].strValue;\n    var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;\n    var outlineOpacity = style['text-outline-opacity'].value * opacity;\n    var color = style['color'].value;\n    var outlineColor = style['text-outline-color'].value;\n\n    var fontCacheKey = element._private.fontKey;\n    var cache = this.getFontCache(context);\n\n    if( cache.key !== fontCacheKey ){\n      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n\n      cache.key = fontCacheKey;\n    }\n\n    var text = String(style['content'].value);\n    var textTransform = style['text-transform'].value;\n    \n    if (textTransform == 'none') {\n    } else if (textTransform == 'uppercase') {\n      text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n      text = text.toLowerCase();\n    }\n    \n    // Calculate text draw position based on text alignment\n    \n    // so text outlines aren't jagged\n    context.lineJoin = 'round';\n\n    this.fillStyle(context, color[0], color[1], color[2], opacity);\n    \n    this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n\n    return text;\n  };\n\n  // Draw text\n  CanvasRenderer.prototype.drawText = function(context, element, textX, textY) {\n    var style = element._private.style;\n    var parentOpacity = element.effectiveOpacity();\n    if( parentOpacity === 0 ){ return; }\n\n    var text = this.setupTextStyle( context, element );\n    \n    if ( text != null && !isNaN(textX) && !isNaN(textY) ) {\n     \n      var lineWidth = 2  * style['text-outline-width'].value; // *2 b/c the stroke is drawn centred on the middle\n      if (lineWidth > 0) {\n        context.lineWidth = lineWidth;\n        context.strokeText(text, textX, textY);\n      }\n\n      context.fillText(text, textX, textY);\n    }\n  };\n\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // Draw node\n  CanvasRenderer.prototype.drawNode = function(context, node, drawOverlayInstead) {\n\n    var r = this;\n    var nodeWidth, nodeHeight;\n    var style = node._private.style;\n    var rs = node._private.rscratch;\n    \n    var usePaths = CanvasRenderer.usePaths();\n    var canvasContext = context;\n    var path;\n    var pathCacheHit = false;\n\n    var overlayPadding = style['overlay-padding'].pxValue;\n    var overlayOpacity = style['overlay-opacity'].value;\n    var overlayColor = style['overlay-color'].value;\n\n    if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw\n      return;\n    }\n\n    var parentOpacity = node.effectiveOpacity();\n    if( parentOpacity === 0 ){ return; }\n\n    nodeWidth = this.getNodeWidth(node);\n    nodeHeight = this.getNodeHeight(node);\n    \n    context.lineWidth = style['border-width'].pxValue;\n\n    if( drawOverlayInstead === undefined || !drawOverlayInstead ){\n\n      // Node color & opacity\n\n      var bgColor = style['background-color'].value;\n      var borderColor = style['border-color'].value;\n      var borderStyle = style['border-style'].value;\n\n      this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * style['opacity'].value * parentOpacity);\n      \n      this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * style['opacity'].value * parentOpacity);\n\n      context.lineJoin = 'miter'; // so borders are square with the node shape\n\n      if( context.setLineDash ){ // for very outofdate browsers\n        switch( borderStyle ){\n          case 'dotted':\n            context.setLineDash([ 1, 1 ]);\n            break;\n\n          case 'dashed':\n            context.setLineDash([ 4, 2 ]);\n            break;\n\n          case 'solid':\n          case 'double':\n            context.setLineDash([ ]);\n            break;\n        }\n      }\n\n      //var image = this.getCachedImage('url');\n      \n      var url = style['background-image'].value[2] ||\n        style['background-image'].value[1];\n      \n      var styleShape = style['shape'].strValue;\n\n      var pos = node._private.position;\n\n      if( usePaths ){\n        var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;\n\n        context.translate( pos.x, pos.y );\n\n        if( rs.pathCacheKey === pathCacheKey ){\n          path = context = rs.pathCache;\n          pathCacheHit = true;\n        } else {\n          path = context = new Path2D();\n          rs.pathCacheKey = pathCacheKey;\n          rs.pathCache = path;\n        }\n      }\n\n      if( !pathCacheHit ){\n\n        var npos = pos;\n\n        if( usePaths ){\n          npos = {\n            x: 0,\n            y: 0\n          };\n        }\n\n        CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(\n              context,\n              npos.x,\n              npos.y,\n              nodeWidth,\n              nodeHeight);\n      }\n\n      context = canvasContext;\n\n      if( usePaths ){\n        context.fill( path );\n      } else {\n        context.fill();\n      }\n\n      if (url !== undefined) {\n        \n        // get image, and if not loaded then ask to redraw when later loaded\n        var image = this.getCachedImage(url, function(){\n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n          \n          r.redraw();\n        });\n        \n        if( image.complete ){\n          this.drawInscribedImage(context, image, node);\n        }\n        \n      } \n      \n      var darkness = style['background-blacken'].value;\n      var borderWidth = style['border-width'].pxValue;\n\n      if( this.hasPie(node) ){\n        this.drawPie(context, node);\n\n        // redraw path for blacken and border\n        if( darkness !== 0 || borderWidth !== 0 ){\n\n          if( !usePaths ){\n            CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(\n                context,\n                pos.x,\n                pos.y,\n                nodeWidth,\n                nodeHeight);\n          }\n        }\n      }\n\n      if( darkness > 0 ){\n        this.fillStyle(context, 0, 0, 0, darkness);\n\n        if( usePaths ){\n          context.fill( path );\n        } else {\n          context.fill();\n        }\n        \n      } else if( darkness < 0 ){\n        this.fillStyle(context, 255, 255, 255, -darkness);\n        \n        if( usePaths ){\n          context.fill( path );\n        } else {\n          context.fill();\n        }\n      }\n\n      // Border width, draw border\n      if (borderWidth > 0) {\n\n        if( usePaths ){\n          context.stroke( path );\n        } else {\n          context.stroke();\n        }\n\n        if( borderStyle === 'double' ){\n          context.lineWidth = style['border-width'].pxValue/3;\n\n          var gco = context.globalCompositeOperation;\n          context.globalCompositeOperation = 'destination-out';\n\n          if( usePaths ){\n            context.stroke( path );\n          } else {\n            context.stroke();\n          }\n\n          context.globalCompositeOperation = gco;\n        }\n\n      }\n\n      if( usePaths ){\n        context.translate( -pos.x, -pos.y );\n      }\n\n      // reset in case we changed the border style\n      if( context.setLineDash ){ // for very outofdate browsers\n        context.setLineDash([ ]);\n      }\n\n    // draw the overlay\n    } else {\n\n      if( overlayOpacity > 0 ){\n        this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);\n\n        CanvasRenderer.nodeShapes['roundrectangle'].drawPath(\n          context,\n          node._private.position.x,\n          node._private.position.y,\n          nodeWidth + overlayPadding * 2,\n          nodeHeight + overlayPadding * 2\n        );\n\n        context.fill();\n      }\n    }\n\n  };\n\n  // does the node have at least one pie piece?\n  CanvasRenderer.prototype.hasPie = function(node){\n    node = node[0]; // ensure ele ref\n    \n    return node._private.hasPie;\n  };\n\n  CanvasRenderer.prototype.drawPie = function(context, node){\n    node = node[0]; // ensure ele ref\n\n    var pieSize = node._private.style['pie-size'];\n    var nodeW = this.getNodeWidth( node );\n    var nodeH = this.getNodeHeight( node );\n    var x = node._private.position.x;\n    var y = node._private.position.y;\n    var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = CanvasRenderer.usePaths();\n\n    if( usePaths ){\n      x = 0;\n      y = 0;\n    }\n\n    if( pieSize.units === '%' ){\n      radius = radius * pieSize.value / 100;\n    } else if( pieSize.pxValue !== undefined ){\n      radius = pieSize.pxValue / 2;\n    }\n\n    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N\n      var size = node._private.style['pie-' + i + '-background-size'].value;\n      var color = node._private.style['pie-' + i + '-background-color'].value;\n      var opacity = node._private.style['pie-' + i + '-background-opacity'].value;\n      var percent = size / 100; // map integer range [0, 100] to [0, 1]\n      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n      var angleDelta = 2 * Math.PI * percent;\n      var angleEnd = angleStart + angleDelta;\n\n      // ignore if\n      // - zero size\n      // - we're already beyond the full circle\n      // - adding the current slice would go beyond the full circle\n      if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){\n        continue;\n      }\n\n      context.beginPath();\n      context.moveTo(x, y);\n      context.arc( x, y, radius, angleStart, angleEnd );\n      context.closePath();\n\n      this.fillStyle(context, color[0], color[1], color[2], opacity);\n\n      context.fill();\n\n      lastPercent += percent;\n    }\n\n  };\n\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // var isFirefox = typeof InstallTrigger !== 'undefined';\n\n  CanvasRenderer.prototype.getPixelRatio = function(){ \n    var context = this.data.contexts[0];\n\n    if( this.forcedPixelRatio != null ){\n      return this.forcedPixelRatio;\n    }\n\n    var backingStore = context.backingStorePixelRatio ||\n      context.webkitBackingStorePixelRatio ||\n      context.mozBackingStorePixelRatio ||\n      context.msBackingStorePixelRatio ||\n      context.oBackingStorePixelRatio ||\n      context.backingStorePixelRatio || 1;\n\n    //console.log(window.devicePixelRatio, backingStore);\n\n    // if( isFirefox ){ // because ff can't scale canvas properly\n    //   return 1;\n    // }\n\n    return (window.devicePixelRatio || 1) / backingStore;\n  };\n\n  CanvasRenderer.prototype.paintCache = function(context){\n    var caches = this.paintCaches = this.paintCaches || [];\n    var needToCreateCache = true;\n    var cache;\n\n    for(var i = 0; i < caches.length; i++ ){\n      cache = caches[i];\n\n      if( cache.context === context ){\n        needToCreateCache = false;\n        break;\n      }\n    }\n\n    if( needToCreateCache ){\n      cache = {\n        context: context\n      };\n      caches.push( cache );\n    }\n\n    return cache;\n  };\n\n  CanvasRenderer.prototype.fillStyle = function(context, r, g, b, a){\n    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    \n    // turn off for now, seems context does its own caching\n\n    // var cache = this.paintCache(context);\n\n    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n    // if( cache.fillStyle !== fillStyle ){\n    //   context.fillStyle = cache.fillStyle = fillStyle;\n    // }\n  };\n\n  CanvasRenderer.prototype.strokeStyle = function(context, r, g, b, a){\n    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    \n    // turn off for now, seems context does its own caching\n\n    // var cache = this.paintCache(context);\n\n    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n    // if( cache.strokeStyle !== strokeStyle ){\n    //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n    // }\n  };\n\n  // Resize canvas\n  CanvasRenderer.prototype.matchCanvasSize = function(container) {\n    var data = this.data;\n    var width = container.clientWidth;\n    var height = container.clientHeight;\n    var pixelRatio = this.getPixelRatio();\n    var canvasWidth = width * pixelRatio;\n    var canvasHeight = height * pixelRatio;\n    var canvas;\n\n    if( canvasWidth === this.canvasWidth && canvasHeight === this.canvasHeight ){\n      return; // save cycles if same\n    }\n\n    this.fontCaches = null; // resizing resets the style\n\n    var canvasContainer = data.canvasContainer;\n    canvasContainer.style.width = width + 'px';\n    canvasContainer.style.height = height + 'px';\n\n    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {\n\n      canvas = data.canvases[i];\n      \n      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n        \n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n      }\n    }\n    \n    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {\n      \n      canvas = data.bufferCanvases[i];\n      \n      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n        \n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n      }\n    }\n\n    this.textureMult = 1;\n    if( pixelRatio <= 1 ){\n      canvas = data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];\n\n      this.textureMult = 2;\n      canvas.width = canvasWidth * this.textureMult;\n      canvas.height = canvasHeight * this.textureMult;\n    }\n\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n\n  };\n\n  CanvasRenderer.prototype.renderTo = function( cxt, zoom, pan, pxRatio ){\n    this.redraw({\n      forcedContext: cxt,\n      forcedZoom: zoom,\n      forcedPan: pan,\n      drawAllLayers: true,\n      forcedPxRatio: pxRatio\n    });\n  };\n\n  CanvasRenderer.prototype.timeToRender = function(){\n    return this.redrawTotalTime / this.redrawCount;\n  };\n\n  CanvasRenderer.minRedrawLimit = 1000/60; // people can't see much better than 60fps\n  CanvasRenderer.maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth\n  CanvasRenderer.motionBlurDelay = 100;\n\n  // Redraw frame\n  CanvasRenderer.prototype.redraw = function( options ) {\n    options = options || {};\n\n    // console.log('redraw');\n\n    var forcedContext = options.forcedContext;\n    var drawAllLayers = options.drawAllLayers;\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var forcedZoom = options.forcedZoom;\n    var forcedPan = options.forcedPan;\n    var r = this;\n    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n    var cy = r.data.cy; var data = r.data; \n    var needDraw = data.canvasNeedsRedraw;\n    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled;\n\n    if( motionBlur && r.motionBlurTimeout ){\n      clearTimeout( r.motionBlurTimeout );\n    }\n\n    if( !forcedContext && this.redrawTimeout ){\n      clearTimeout( this.redrawTimeout );\n    }\n    this.redrawTimeout = null;\n\n    if( this.averageRedrawTime === undefined ){ this.averageRedrawTime = 0; }\n\n    var minRedrawLimit = CanvasRenderer.minRedrawLimit; \n    var maxRedrawLimit = CanvasRenderer.maxRedrawLimit;\n\n    var redrawLimit = this.averageRedrawTime; // estimate the ideal redraw limit based on how fast we can draw\n    redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;\n    redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;\n\n    //console.log('--\\nideal: %i; effective: %i', this.averageRedrawTime, redrawLimit);\n\n    if( this.lastDrawTime === undefined ){ this.lastDrawTime = 0; }\n\n    var nowTime = +new Date();\n    var timeElapsed = nowTime - this.lastDrawTime;\n    var callAfterLimit = timeElapsed >= redrawLimit;\n\n    if( !forcedContext ){\n      if( !callAfterLimit || this.currentlyDrawing ){\n        // console.log('-- skip');\n\n        // we have new things to draw but we're busy, so try again when possibly free\n        this.redrawTimeout = setTimeout(function(){\n          r.redraw();\n        }, redrawLimit);\n        return;\n      }\n\n      this.lastDrawTime = nowTime;\n      this.currentlyDrawing = true;\n    }\n\n\n    var startTime = +new Date();\n\n    //console.log('-- redraw --')\n\n\n    function drawToContext(){ \n      // startTime = +new Date();\n      // console.profile('draw' + startTime)\n      var edges = r.getCachedEdges();\n      var coreStyle = cy.style()._private.coreStyle;\n      \n      var zoom = cy.zoom();\n      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n      var pan = cy.pan();\n      var effectivePan = {\n        x: pan.x,\n        y: pan.y\n      };\n\n      if( forcedPan ){\n        effectivePan = forcedPan;\n      }\n\n      // apply pixel ratio\n\n      effectiveZoom *= pixelRatio;\n      effectivePan.x *= pixelRatio;\n      effectivePan.y *= pixelRatio;\n      \n      var eles = {\n        drag: {\n          nodes: [],\n          edges: [],\n          eles: []\n        },\n        nondrag: {\n          nodes: [],\n          edges: [],\n          eles: []\n        }\n      };\n\n      function setContextTransform(context, clear){\n        context.setTransform(1, 0, 0, 1, 0, 0);\n\n        if( clear === 'motionBlur' ){\n          var gco = context.globalCompositeOperation;\n\n          context.globalCompositeOperation = 'destination-out';\n          r.fillStyle( context, 255, 255, 255, 0.666 );\n          context.fillRect(0, 0, r.canvasWidth, r.canvasHeight);\n\n          context.globalCompositeOperation = gco;\n        } else if( !forcedContext && (clear === undefined || clear) ){\n          context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n        }\n        \n        if( !drawAllLayers ){\n          context.translate(effectivePan.x, effectivePan.y);\n          context.scale(effectiveZoom, effectiveZoom);\n        }\n        if( forcedPan ){\n          context.translate(forcedPan.x, forcedPan.y);\n        } \n        if( forcedZoom ){\n          context.scale(forcedZoom, forcedZoom);\n        }\n      }\n\n      var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n\n      if( textureDraw ){\n\n        var bb;\n\n        if( !r.textureCache ){\n          r.textureCache = {};\n\n          bb = r.textureCache.bb = cy.elements().boundingBox();\n\n          r.textureCache.texture = r.data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];\n\n          var cxt = r.data.bufferContexts[ CanvasRenderer.TEXTURE_BUFFER ];\n\n          cxt.setTransform(1, 0, 0, 1, 0, 0);\n          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n          \n          r.redraw({\n            forcedContext: cxt,\n            drawOnlyNodeLayer: true,\n            forcedPxRatio: pixelRatio * r.textureMult\n          });\n\n          var vp = r.textureCache.viewport = {\n            zoom: cy.zoom(),\n            pan: cy.pan(),\n            width: r.canvasWidth,\n            height: r.canvasHeight\n          };\n\n          vp.mpan = {\n            x: (0 - vp.pan.x)/vp.zoom,\n            y: (0 - vp.pan.y)/vp.zoom\n          };\n        }\n\n        needDraw[CanvasRenderer.DRAG] = false;\n        needDraw[CanvasRenderer.NODE] = false;\n\n        var context = data.contexts[CanvasRenderer.NODE];\n\n        var texture = r.textureCache.texture;\n        var vp = r.textureCache.viewport;\n        bb = r.textureCache.bb;\n\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.clearRect(0, 0, vp.width, vp.height);\n\n        var outsideBgColor = coreStyle['outside-texture-bg-color'].value;\n        var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;\n        r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );\n        context.fillRect( 0, 0, vp.width, vp.height );\n\n        var zoom = cy.zoom();\n        \n        setContextTransform( context, false );\n\n        context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );\n        context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );\n\n      } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it\n        r.textureCache = null;\n      }\n\n      var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);\n      var hideEdges = r.hideEdgesOnViewport && vpManip;\n      var hideLabels = r.hideLabelsOnViewport && vpManip;\n\n      if (needDraw[CanvasRenderer.DRAG] || needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer) {\n        //NB : VERY EXPENSIVE\n\n        if( hideEdges ){ \n        } else {\n          r.findEdgeControlPoints(edges);\n        }\n\n        var zEles = r.getCachedZSortedEles();\n        var extent = cy.extent();\n\n        for (var i = 0; i < zEles.length; i++) {\n          var ele = zEles[i];\n          var list;\n          var bb = forcedContext ? null : ele.boundingBox();\n          var insideExtent = forcedContext ? true : $$.math.boundingBoxesIntersect( extent, bb );\n\n          if( !insideExtent ){ continue; } // no need to render\n\n          if ( ele._private.rscratch.inDragLayer ) {\n            list = eles.drag;\n          } else {\n            list = eles.nondrag;\n          }\n\n          list.eles.push( ele );\n        }\n\n      }\n      \n      \n      function drawElements( list, context ){\n        var eles = list.eles;\n\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          if( ele.isNode() ){\n            r.drawNode(context, ele);\n\n            if( !hideLabels ){\n              r.drawNodeText(context, ele);\n            }\n\n            r.drawNode(context, ele, true);\n          } else if( !hideEdges ) {\n            r.drawEdge(context, ele);\n\n            if( !hideLabels ){\n              r.drawEdgeText(context, ele);\n            }\n\n            r.drawEdge(context, ele, true);\n          }\n          \n          \n        }\n\n      }\n\n      var nodeLayerNeedsMotionClear = needDraw[CanvasRenderer.DRAG] && !needDraw[CanvasRenderer.NODE] && motionBlur && !r.clearedNodeLayerForMotionBlur;\n      if( nodeLayerNeedsMotionClear ){ r.clearedNodeLayerForMotionBlur = true; }\n\n      if( needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer || nodeLayerNeedsMotionClear ){\n        // console.log('redrawing node layer');\n        \n        var context = forcedContext || data.contexts[CanvasRenderer.NODE];\n\n        setContextTransform( context, motionBlur && !nodeLayerNeedsMotionClear ? 'motionBlur' : undefined );\n        drawElements(eles.nondrag, context);\n        \n        if( !drawAllLayers ){\n          needDraw[CanvasRenderer.NODE] = false; \n        }\n      }\n      \n      if ( !drawOnlyNodeLayer && (needDraw[CanvasRenderer.DRAG] || drawAllLayers) ) {\n        \n        var context = forcedContext || data.contexts[CanvasRenderer.DRAG];\n        \n        setContextTransform( context, motionBlur ? 'motionBlur' : undefined );\n        drawElements(eles.drag, context);\n        \n        if( !drawAllLayers ){\n          needDraw[CanvasRenderer.DRAG] = false;\n        }\n      }\n      \n      if( r.showFps || (!drawOnlyNodeLayer && (needDraw[CanvasRenderer.SELECT_BOX] && !drawAllLayers)) ) {\n        // console.log('redrawing selection box');\n        \n        var context = forcedContext || data.contexts[CanvasRenderer.SELECT_BOX];\n\n        setContextTransform( context );\n\n        if( data.select[4] == 1 && r.hoverData.selecting ){\n          var zoom = data.cy.zoom();\n          var borderWidth = coreStyle['selection-box-border-width'].value / zoom;\n          \n          context.lineWidth = borderWidth;\n          context.fillStyle = \"rgba(\" \n            + coreStyle['selection-box-color'].value[0] + \",\"\n            + coreStyle['selection-box-color'].value[1] + \",\"\n            + coreStyle['selection-box-color'].value[2] + \",\"\n            + coreStyle['selection-box-opacity'].value + \")\";\n          \n          context.fillRect(\n            data.select[0],\n            data.select[1],\n            data.select[2] - data.select[0],\n            data.select[3] - data.select[1]);\n          \n          if (borderWidth > 0) {\n            context.strokeStyle = \"rgba(\" \n              + coreStyle['selection-box-border-color'].value[0] + \",\"\n              + coreStyle['selection-box-border-color'].value[1] + \",\"\n              + coreStyle['selection-box-border-color'].value[2] + \",\"\n              + coreStyle['selection-box-opacity'].value + \")\";\n            \n            context.strokeRect(\n              data.select[0],\n              data.select[1],\n              data.select[2] - data.select[0],\n              data.select[3] - data.select[1]);\n          }\n        }\n\n        if( data.bgActivePosistion && !r.hoverData.selecting ){\n          var zoom = data.cy.zoom();\n          var pos = data.bgActivePosistion;\n\n          context.fillStyle = \"rgba(\" \n            + coreStyle['active-bg-color'].value[0] + \",\"\n            + coreStyle['active-bg-color'].value[1] + \",\"\n            + coreStyle['active-bg-color'].value[2] + \",\"\n            + coreStyle['active-bg-opacity'].value + \")\";\n\n          context.beginPath();\n          context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pxValue / zoom, 0, 2 * Math.PI); \n          context.fill();\n        }\n        \n        var timeToRender = r.averageRedrawTime;\n        if( r.showFps && timeToRender ){\n          timeToRender = Math.round( timeToRender );\n          var fps = Math.round(1000/timeToRender);\n\n          context.setTransform(1, 0, 0, 1, 0, 0);\n\n          //context.font = '20px helvetica';\n          context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n          context.lineWidth = 1;\n          context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n\n          var maxFps = 60;\n          context.strokeRect(0, 30, 250, 20);\n          context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);\n        }\n\n        if( !drawAllLayers ){\n          needDraw[CanvasRenderer.SELECT_BOX] = false; \n        }\n      }\n\n\n      var endTime = +new Date();\n\n      if( r.averageRedrawTime === undefined ){\n        r.averageRedrawTime = endTime - startTime;\n      }\n\n      if( r.redrawCount === undefined ){\n        r.redrawCount = 0;\n      }\n\n      r.redrawCount++;\n\n      if( r.redrawTotalTime === undefined ){\n        r.redrawTotalTime = 0;\n      }\n\n      r.redrawTotalTime += endTime - startTime;\n      r.lastRedrawTime = endTime - startTime;\n\n      // use a weighted average with a bias from the previous average so we don't spike so easily\n      r.averageRedrawTime = r.averageRedrawTime/2 + (endTime - startTime)/2;\n      //console.log('actual: %i, average: %i', endTime - startTime, this.averageRedrawTime);\n\n      r.currentlyDrawing = false;\n\n      // console.profileEnd('draw' + startTime)\n\n      if( r.clearingMotionBlur ){\n        r.clearingMotionBlur = false;\n        r.motionBlurCleared = true;\n        r.motionBlur = true;\n      }\n\n      if( motionBlur ){ \n        r.motionBlurTimeout = setTimeout(function(){\n          r.motionBlurTimeout = null;\n          // console.log('motion blur clear');\n\n          r.clearedNodeLayerForMotionBlur = false;\n          r.motionBlur = false;\n          r.clearingMotionBlur = true;\n\n          needDraw[CanvasRenderer.NODE] = true; \n          needDraw[CanvasRenderer.DRAG] = true; \n\n          r.redraw();\n        }, CanvasRenderer.motionBlurDelay);\n      }\n    } // draw to context\n\n    if( !forcedContext ){\n      $$.util.requestAnimationFrame(drawToContext); // makes direct renders to screen a bit more responsive\n    } else {\n      drawToContext();\n    }\n\n    if( !forcedContext && !r.initrender ){\n      r.initrender = true;\n      cy.trigger('initrender');\n    }\n    \n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // @O Polygon drawing\n  CanvasRenderer.prototype.drawPolygonPath = function(\n    context, x, y, width, height, points) {\n\n    var halfW = width / 2;\n    var halfH = height / 2;\n\n    if( context.beginPath ){ context.beginPath(); }\n\n    context.moveTo( x + halfW * points[0], y + halfH * points[1] );\n\n    for (var i = 1; i < points.length / 2; i++) {\n      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );\n    }\n    \n    context.closePath();\n  };\n  \n  CanvasRenderer.prototype.drawPolygon = function(\n    context, x, y, width, height, points) {\n\n    // Draw path\n    this.drawPolygonPath(context, x, y, width, height, points);\n    \n    // Fill path\n    context.fill();\n  };\n  \n  // Round rectangle drawing\n  CanvasRenderer.prototype.drawRoundRectanglePath = function(\n    context, x, y, width, height, radius) {\n    \n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = $$.math.getRoundRectangleRadius(width, height);\n    \n    if( context.beginPath ){ context.beginPath(); }\n    \n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    // Arc from middle top to right side\n    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n    // Arc from right side to bottom\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    // Arc from bottom to left side\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    // Arc from left side to topBorder\n    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n    // Join line\n    context.lineTo(x, y - halfHeight);\n    \n    \n    context.closePath();\n  };\n  \n  CanvasRenderer.prototype.drawRoundRectangle = function(\n    context, x, y, width, height, radius) {\n    \n    this.drawRoundRectanglePath(context, x, y, width, height, radius);\n    \n    context.fill();\n  };\n\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.createBuffer = function(w, h) {\n    var buffer = document.createElement('canvas');\n    buffer.width = w;\n    buffer.height = h;\n    \n    return [buffer, buffer.getContext('2d')];\n  };\n\n  CanvasRenderer.prototype.bufferCanvasImage = function( options ){\n    var data = this.data;\n    var cy = data.cy;\n    var bb = cy.elements().boundingBox();\n    var width = options.full ? Math.ceil(bb.w) : this.data.container.clientWidth;\n    var height = options.full ? Math.ceil(bb.h) : this.data.container.clientHeight;\n    var scale = 1;\n\n    if( options.scale !== undefined ){\n      width *= options.scale;\n      height *= options.scale;\n\n      scale = options.scale;\n    }\n\n    var buffCanvas = document.createElement('canvas');\n\n    buffCanvas.width = width;\n    buffCanvas.height = height;\n\n    buffCanvas.style.width = width + 'px';\n    buffCanvas.style.height = height + 'px';\n\n    var buffCxt = buffCanvas.getContext('2d');\n\n    // Rasterize the layers, but only if container has nonzero size\n    if (width > 0 && height > 0) {\n\n      buffCxt.clearRect( 0, 0, width, height );\n\n      if( options.bg ){\n        buffCxt.fillStyle = options.bg;\n        buffCxt.rect( 0, 0, width, height );\n        buffCxt.fill();\n      }\n\n      buffCxt.globalCompositeOperation = 'source-over';\n\n      if( options.full ){ // draw the full bounds of the graph\n        this.redraw({\n          forcedContext: buffCxt,\n          drawAllLayers: true,\n          forcedZoom: scale,\n          forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },\n          forcedPxRatio: 1\n        });\n      } else { // draw the current view\n        var cyPan = cy.pan();\n        var pan = {\n          x: cyPan.x * scale,\n          y: cyPan.y * scale\n        };\n        var zoom = cy.zoom() * scale;\n\n        this.redraw({\n          forcedContext: buffCxt,\n          drawAllLayers: true,\n          forcedZoom: zoom,\n          forcedPan: pan,\n          forcedPxRatio: 1\n        });\n      }\n    }\n\n    return buffCanvas;\n  }; \n\n  CanvasRenderer.prototype.png = function( options ){\n    return this.bufferCanvasImage( options ).toDataURL('image/png');\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.registerBinding = function(target, event, handler, useCapture){\n    this.bindings.push({\n      target: target,\n      event: event,\n      handler: handler,\n      useCapture: useCapture\n    });\n\n    target.addEventListener(event, handler, useCapture);\n  };\n\n  CanvasRenderer.prototype.nodeIsDraggable = function(node) {\n    if (node._private.style['opacity'].value !== 0\n      && node._private.style['visibility'].value == 'visible'\n      && node._private.style['display'].value == 'element'\n      && !node.locked()\n      && node.grabbable() ) {\n\n      return true;\n    }\n    \n    return false;\n  };\n\n  CanvasRenderer.prototype.load = function() {\n    var r = this;\n\n    var getDragListIds = function(opts){\n      var listHasId;\n\n      if( opts.addToList && r.data.cy.hasCompoundNodes() ){ // only needed for compound graphs\n        if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist\n          opts.addToList.hasId = {};\n\n          for( var i = 0; i < opts.addToList.length; i++ ){\n            var ele = opts.addToList[i];\n\n            opts.addToList.hasId[ ele.id() ] = true;\n          }\n        }\n\n        listHasId = opts.addToList.hasId;\n      }\n\n      return listHasId || {};\n    };\n\n    // helper function to determine which child nodes and inner edges\n    // of a compound node to be dragged as well as the grabbed and selected nodes\n    var addDescendantsToDrag = function(node, opts){\n      if( !node._private.cy.hasCompoundNodes() ){\n        return;\n      }\n\n      var listHasId = getDragListIds( opts );\n\n      var innerNodes = node.descendants();\n\n      // TODO do not drag hidden children & children of hidden children?\n      for( var i = 0; i < innerNodes.size(); i++ ){\n        var iNode = innerNodes[i];\n        var _p = iNode._private;\n\n        if( opts.inDragLayer ){\n          _p.rscratch.inDragLayer = true;\n        }\n\n        if( opts.addToList && !listHasId[ iNode.id() ] ){\n          opts.addToList.push( iNode );\n          listHasId[ iNode.id() ] = true;\n\n          _p.grabbed = true; \n        }\n\n        var edges = _p.edges;\n        for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){\n          edges[j]._private.rscratch.inDragLayer = true;\n        }\n      }\n    };\n\n    // adds the given nodes, and its edges to the drag layer\n    var addNodeToDrag = function(node, opts){\n\n      var _p = node._private;\n      var listHasId = getDragListIds( opts );\n\n      if( opts.inDragLayer ){\n        _p.rscratch.inDragLayer = true;\n      }\n\n      if( opts.addToList && !listHasId[ node.id() ] ){\n        opts.addToList.push( node );\n        listHasId[ node.id() ] = true;\n\n        _p.grabbed = true; \n      }\n\n      var edges = _p.edges;\n      for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){\n        edges[i]._private.rscratch.inDragLayer = true;\n      }\n\n      addDescendantsToDrag( node, opts ); // always add to drag\n\n      // also add nodes and edges related to the topmost ancestor\n      updateAncestorsInDragLayer( node, {\n        inDragLayer: true\n      } );\n    };\n\n    // helper function to determine which ancestor nodes and edges should go\n    // to the drag layer (or should be removed from drag layer).\n    var updateAncestorsInDragLayer = function(node, opts) {\n      // find top-level parent\n      var parent = node;\n\n      if( !node._private.cy.hasCompoundNodes() ){\n        return;\n      }\n\n      while( parent.parent().nonempty() ){\n        parent = parent.parent()[0];\n      }\n\n      // no parent node: no nodes to add to the drag layer\n      if( parent == node ){\n        return;\n      }\n\n      var nodes = parent\n        .descendants()\n        .add( parent )\n        .not( node )\n        .not( node.descendants() )\n      ;\n\n      var edges = nodes.connectedEdges();\n\n      var listHasId = getDragListIds( opts );\n\n      for( var i = 0; i < nodes.size(); i++ ){\n        if( opts.inDragLayer !== undefined ){\n          nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;\n        }\n\n        if( opts.addToList && !listHasId[ nodes[i].id() ] ){\n          opts.addToList.push( nodes[i] );\n          listHasId[ nodes[i].id() ] = true;\n\n          nodes[i]._private.grabbed = true;\n        }\n      }\n\n      for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {\n        edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;\n      }\n    };\n\n    if( typeof MutationObserver !== 'undefined' ){\n      r.removeObserver = new MutationObserver(function( mutns ){\n        for( var i = 0; i < mutns.length; i++ ){\n          var mutn = mutns[i];\n          var rNodes = mutn.removedNodes;\n\n          if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){\n            var rNode = rNodes[j];\n\n            if( rNode === r.data.container ){\n              r.destroy();\n              break;\n            }\n          } }\n        }\n      });\n\n      r.removeObserver.observe( r.data.container.parentNode, { childList: true } );\n    } else {\n      r.registerBinding(r.data.container, 'DOMNodeRemoved', function(e){\n        r.destroy();\n      });\n    }\n\n\n\n    // auto resize\n    r.registerBinding(window, 'resize', $$.util.debounce( function(e) {\n      r.invalidateContainerClientCoordsCache();\n\n      r.matchCanvasSize(r.data.container);\n      r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n      r.redraw();\n    }, 100 ) );\n\n    var invalCtnrBBOnScroll = function(domEle){\n      r.registerBinding(domEle, 'scroll', function(e){\n        r.invalidateContainerClientCoordsCache();\n      } );\n    };\n\n    var bbCtnr = r.data.cy.container();\n\n    for( ;; ){\n      \n      invalCtnrBBOnScroll( bbCtnr );\n\n      if( bbCtnr.parentNode ){\n        bbCtnr = bbCtnr.parentNode;\n      } else {\n        break;\n      }\n      \n    }\n\n    // stop right click menu from appearing on cy\n    r.registerBinding(r.data.container, 'contextmenu', function(e){\n      e.preventDefault();\n    });\n\n    var inBoxSelection = function(){\n      return r.data.select[4] !== 0;\n    };\n\n    // Primary key\n    r.registerBinding(r.data.container, 'mousedown', function(e) { \n      e.preventDefault();\n      r.hoverData.capture = true;\n      r.hoverData.which = e.which;\n      \n      var cy = r.data.cy; \n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var select = r.data.select;\n      var near = r.findNearestElement(pos[0], pos[1], true);\n      var draggedElements = r.dragData.possibleDragElements;\n\n      r.hoverData.mdownPos = pos;\n\n      var checkForTaphold = function(){\n        r.hoverData.tapholdCancelled = false;\n\n        clearTimeout( r.hoverData.tapholdTimeout );\n\n        r.hoverData.tapholdTimeout = setTimeout(function(){\n\n          if( r.hoverData.tapholdCancelled ){\n            return;\n          } else {\n            var ele = r.hoverData.down;\n\n            if( ele ){\n              ele.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }) );\n            } else {\n              cy.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }) );\n            }\n          }\n\n        }, r.tapholdDuration);\n      };\n\n      // Right click button\n      if( e.which == 3 ){\n\n        r.hoverData.cxtStarted = true;\n\n        var cxtEvt = new $$.Event(e, {\n          type: 'cxttapstart', \n          cyPosition: { x: pos[0], y: pos[1] } \n        });\n\n        if( near ){\n          near.activate();\n          near.trigger( cxtEvt );\n\n          r.hoverData.down = near;\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        r.hoverData.downTime = (new Date()).getTime();\n        r.hoverData.cxtDragged = false;\n\n      // Primary button\n      } else if (e.which == 1) {\n        \n        if( near ){\n          near.activate();\n        }\n\n        // Element dragging\n        {\n          // If something is under the cursor and it is draggable, prepare to grab it\n          if (near != null) {\n\n            if( r.nodeIsDraggable(near) ){\n\n              var grabEvent = new $$.Event(e, {\n                type: 'grab',\n                cyPosition: { x: pos[0], y: pos[1] }\n              });\n\n              if ( near.isNode() && !near.selected() ){\n\n                draggedElements = r.dragData.possibleDragElements = [];\n                addNodeToDrag( near, { addToList: draggedElements } );\n\n                near.trigger(grabEvent);\n\n              } else if ( near.isNode() && near.selected() ){\n                draggedElements = r.dragData.possibleDragElements = [  ];\n\n                var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });\n\n                for( var i = 0; i < selectedNodes.length; i++ ){\n\n                  // Only add this selected node to drag if it is draggable, eg. has nonzero opacity\n                  if( r.nodeIsDraggable( selectedNodes[i] ) ){\n                    addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );\n                  }\n                }\n\n                near.trigger( grabEvent );\n              }\n\n              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n              r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            }\n            \n            near\n              .trigger(new $$.Event(e, {\n                type: 'mousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapstart',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n            \n          } else if (near == null) {\n            cy\n              .trigger(new $$.Event(e, {\n                type: 'mousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapstart',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n          }\n          \n          r.hoverData.down = near;\n          r.hoverData.downTime = (new Date()).getTime();\n\n        }\n      \n        // Selection box\n        if ( near == null || near.isEdge() ) {\n          select[4] = 1;\n          var timeUntilActive = Math.max( 0, CanvasRenderer.panOrBoxSelectDelay - (+new Date() - r.hoverData.downTime) );\n\n          clearTimeout( r.bgActiveTimeout );\n\n          if( cy.boxSelectionEnabled() || ( near && near.isEdge() ) ){\n            r.bgActiveTimeout = setTimeout(function(){\n              if( near ){\n                near.unactivate();\n              }\n\n              r.data.bgActivePosistion = {\n                x: pos[0],\n                y: pos[1]\n              };\n\n              checkForTaphold();\n\n              r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n      \n              r.redraw();\n            }, timeUntilActive);\n          } else {\n            r.data.bgActivePosistion = {\n              x: pos[0],\n              y: pos[1]\n            };\n\n            checkForTaphold();\n\n            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n    \n            r.redraw();\n          }\n          \n        }\n      \n      } \n      \n      // Initialize selection box coordinates\n      select[0] = select[2] = pos[0];\n      select[1] = select[3] = pos[1];\n      \n    }, false);\n    \n    r.registerBinding(window, 'mousemove', $$.util.throttle( function(e) {\n      var preventDefault = false;\n      var capture = r.hoverData.capture;\n\n      // save cycles if mouse events aren't to be captured\n      if ( !capture ){\n        var containerPageCoords = r.findContainerClientCoords();\n\n        if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth\n          && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight\n        ) {\n          // inside container bounds so OK\n        } else {\n          return;\n        }\n\n        var cyContainer = r.data.container;\n        var target = e.target;\n        var tParent = target.parentNode;\n        var containerIsTarget = false;\n\n        while( tParent ){\n          if( tParent === cyContainer ){\n            containerIsTarget = true;\n            break;\n          }\n\n          tParent = tParent.parentNode;\n        }\n\n        if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us\n      }\n\n      var cy = r.data.cy;\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var select = r.data.select;\n      \n      var near = null;\n      if( !r.hoverData.draggingEles ){\n        near = r.findNearestElement(pos[0], pos[1], true);\n      }\n      var last = r.hoverData.last;\n      var down = r.hoverData.down;\n      \n      var disp = [pos[0] - select[2], pos[1] - select[3]];\n\n      var draggedElements = r.dragData.possibleDragElements;\n\n      var dx = select[2] - select[0];\n      var dx2 = dx * dx;\n      var dy = select[3] - select[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom;\n\n      r.hoverData.tapholdCancelled = true;\n\n      var updateDragDelta = function(){\n        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\n        if( dragDelta.length === 0 ){\n          dragDelta.push(0);\n          dragDelta.push(0);\n        } else {\n          dragDelta[0] += disp[0];\n          dragDelta[1] += disp[1];\n        }\n      };\n      \n\n      preventDefault = true;\n\n      // Mousemove event\n      {\n        if (near != null) {\n          near\n            .trigger(new $$.Event(e, {\n              type: 'mousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapdrag',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n          ;\n          \n        } else if (near == null) {\n          cy\n            .trigger(new $$.Event(e, {\n              type: 'mousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapdrag',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n          ;\n        }\n\n      }\n\n      // trigger context drag if rmouse down\n      if( r.hoverData.which === 3 ){\n        var cxtEvt = new $$.Event(e, {\n          type: 'cxtdrag',\n          cyPosition: { x: pos[0], y: pos[1] }\n        });\n\n        if( down ){\n          down.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        r.hoverData.cxtDragged = true;\n\n        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){\n\n          if( r.hoverData.cxtOver ){\n            r.hoverData.cxtOver.trigger( new $$.Event(e, {\n              type: 'cxtdragout',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) );\n\n            // console.log('cxtdragout ' + r.hoverData.cxtOver.id());\n          }\n\n          r.hoverData.cxtOver = near;\n\n          if( near ){\n            near.trigger( new $$.Event(e, {\n              type: 'cxtdragover',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) );\n\n            // console.log('cxtdragover ' + near.id());\n          }\n\n        }\n\n      // Check if we are drag panning the entire graph\n      } else if (r.hoverData.dragging) {\n        preventDefault = true;\n\n        if( cy.panningEnabled() && cy.userPanningEnabled() ){\n          var deltaP;\n\n          if( r.hoverData.justStartedPan ){\n            var mdPos = r.hoverData.mdownPos;\n\n            deltaP = {\n              x: ( pos[0] - mdPos[0] ) * zoom,\n              y: ( pos[1] - mdPos[1] ) * zoom\n            };\n\n            r.hoverData.justStartedPan = false;\n\n          } else {\n            deltaP = {\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            };\n\n          }\n\n          cy.panBy( deltaP );\n          \n        }\n        \n        // Needs reproject due to pan changing viewport\n        pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      // Checks primary button down & out of time & mouse not moved much\n      } else if(\n          select[4] == 1 && (down == null || down.isEdge())\n          && ( !cy.boxSelectionEnabled() || (+new Date() - r.hoverData.downTime >= CanvasRenderer.panOrBoxSelectDelay) )\n          //&& (Math.abs(select[3] - select[1]) + Math.abs(select[2] - select[0]) < 4)\n          && !r.hoverData.selecting\n          && rdist2 >= r.tapThreshold2\n          && cy.panningEnabled() && cy.userPanningEnabled()\n      ){\n        r.hoverData.dragging = true;\n        r.hoverData.selecting = false;\n        r.hoverData.justStartedPan = true;\n        select[4] = 0;\n\n      } else {\n        // deactivate bg on box selection\n        if (cy.boxSelectionEnabled() && Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]){\n          clearTimeout( r.bgActiveTimeout );\n          r.data.bgActivePosistion = undefined;\n          r.hoverData.selecting = true;\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          r.redraw();\n        }\n        \n        if( down && down.isEdge() && down.active() ){ down.unactivate(); }\n\n        if (near != last) {\n          \n          if (last) {\n            last.trigger( new $$.Event(e, {\n              type: 'mouseout',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n\n            last.trigger( new $$.Event(e, {\n              type: 'tapdragout',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n          }\n          \n          if (near) {\n            near.trigger( new $$.Event(e, {\n              type: 'mouseover',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n\n            near.trigger( new $$.Event(e, {\n              type: 'tapdragover',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n          }\n          \n          r.hoverData.last = near;\n        }\n\n        if( down && down.isNode() && r.nodeIsDraggable(down) ){\n\n          if( rdist2 >= r.tapThreshold2 ){ // then drag\n\n            var justStartedDrag = !r.dragData.didDrag;\n\n            if( justStartedDrag ) {\n              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n            }\n\n            r.dragData.didDrag = true; // indicate that we actually did drag the node\n\n            var toTrigger = [];\n\n            for( var i = 0; i < draggedElements.length; i++ ){\n              var dEle = draggedElements[i];\n\n              // now, add the elements to the drag layer if not done already\n              if( !r.hoverData.draggingEles ){ \n                addNodeToDrag( dEle, { inDragLayer: true } );\n              }\n\n              // Locked nodes not draggable, as well as non-visible nodes\n              if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){\n                var dPos = dEle._private.position;\n\n                toTrigger.push( dEle );\n                \n                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){\n                  dPos.x += disp[0];\n                  dPos.y += disp[1];\n\n                  if( justStartedDrag ){\n                    var dragDelta = r.hoverData.dragDelta;\n\n                    if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){\n                      dPos.x += dragDelta[0];\n                      dPos.y += dragDelta[1];\n                    }\n                  }\n                }\n\n              }\n            }\n\n            r.hoverData.draggingEles = true;\n            \n            var tcol = (new $$.Collection(cy, toTrigger));\n\n            tcol.updateCompoundBounds();\n            tcol.trigger('position drag');\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n            r.redraw();\n\n          } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n            updateDragDelta();\n          }\n        }\n\n        // prevent the dragging from triggering text selection on the page\n        preventDefault = true;\n      }\n      \n      select[2] = pos[0]; select[3] = pos[1];\n      \n      if( preventDefault ){ \n        if(e.stopPropagation) e.stopPropagation();\n          if(e.preventDefault) e.preventDefault();\n          return false;\n        }\n    }, 1000/30, { trailing: true }), false);\n    \n    r.registerBinding(window, 'mouseup', function(e) {\n      // console.log('--\\nmouseup', e)\n\n      var capture = r.hoverData.capture;\n      if (!capture) { return; }\n      r.hoverData.capture = false;\n    \n      var cy = r.data.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.data.select;\n      var near = r.findNearestElement(pos[0], pos[1], true); \n      var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;\n      var shiftDown = e.shiftKey;\n      \n      if( r.data.bgActivePosistion ){\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n        r.redraw();\n      }\n\n      r.data.bgActivePosistion = undefined; // not active bg now\n      clearTimeout( r.bgActiveTimeout );\n\n      r.hoverData.cxtStarted = false;\n      r.hoverData.draggingEles = false;\n      r.hoverData.selecting = false;\n\n      if( down ){\n        down.unactivate();\n      }\n\n      if( r.hoverData.which === 3 ){\n        var cxtEvt = new $$.Event(e, {\n          type: 'cxttapend',\n          cyPosition: { x: pos[0], y: pos[1] }\n        });\n\n        if( down ){\n          down.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        if( !r.hoverData.cxtDragged ){\n          var cxtTap = new $$.Event(e, {\n            type: 'cxttap',\n            cyPosition: { x: pos[0], y: pos[1] }\n          });\n\n          if( down ){\n            down.trigger( cxtTap );\n          } else {\n            cy.trigger( cxtTap );\n          }\n        }\n\n        r.hoverData.cxtDragged = false;\n        r.hoverData.which = null;\n\n      // if not right mouse\n      } else {\n\n        // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n        if ( (down == null) // not mousedown on node\n          && !r.dragData.didDrag // didn't move the node around\n          && !(Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]) // not box selection\n          && !r.hoverData.dragging // not panning\n        ) {\n\n          cy.$(function(){\n            return this.selected();\n          }).unselect();\n          \n          if (draggedElements.length > 0) {\n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n          }\n          \n          r.dragData.possibleDragElements = draggedElements = [];\n        }\n      \n        \n        // Mouseup event\n        {\n          // console.log('trigger mouseup et al');\n\n          if (near != null) {\n            near\n              .trigger(new $$.Event(e, {\n                type: 'mouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n          } else if (near == null) {\n            cy\n              .trigger(new $$.Event(e, {\n                type: 'mouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n          }\n        }\n        \n        // Click event\n        {\n          // console.log('trigger click et al');\n\n          if (Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) === 0) {\n            if (near != null) {\n              near\n                .trigger( new $$.Event(e, {\n                  type: 'click',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'tap',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'vclick',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n              ;\n            } else if (near == null) {\n              cy\n                .trigger( new $$.Event(e, {\n                  type: 'click',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'tap',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'vclick',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n              ;\n            }\n          }\n        }\n\n        // Single selection\n        if (near == down && !r.dragData.didDrag) {\n          if (near != null && near._private.selectable) {\n            \n            // console.log('single selection')\n\n            if( r.hoverData.dragging ){\n              // if panning, don't change selection state\n            } else if( cy.selectionType() === 'additive' || shiftDown ){\n              if( near.selected() ){\n                near.unselect();\n              } else {\n                near.select();\n              }\n            } else {\n              if( !shiftDown ){\n                cy.$(':selected').not( near ).unselect();\n                near.select();\n              }               \n            }\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n            \n          }\n      \n        } \n        \n        if ( cy.boxSelectionEnabled() &&  Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4] ) {         \n          var newlySelected = [];\n          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n          if( box.length > 0 ) { \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          }\n\n          for( var i = 0; i < box.length; i++ ){ \n            if( box[i]._private.selectable ){\n              newlySelected.push( box[i] );\n            }\n          }\n\n          var newlySelCol = new $$.Collection( cy, newlySelected );\n\n          if( cy.selectionType() === 'additive' ){\n            newlySelCol.select();\n          } else {\n            if( !shiftDown ){\n              cy.$(':selected').not( newlySelCol ).unselect();\n            }\n\n            newlySelCol.select();\n          }\n\n          // always need redraw in case eles unselectable\n          r.redraw();\n          \n        }\n        \n        // Cancel drag pan\n        if( r.hoverData.dragging ){\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          r.redraw();\n        }\n\n        r.hoverData.dragging = false;\n        \n        if (!select[4]) {\n          // console.log('free at end', draggedElements)\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; \n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          \n          for (var i=0; i < draggedElements.length; i++) {\n            \n            if(draggedElements[i]._private.group === 'nodes') { \n              draggedElements[i]._private.rscratch.inDragLayer = false;\n              draggedElements[i]._private.grabbed = false;\n              \n              var sEdges = draggedElements[i]._private.edges;\n              for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }\n\n              // for compound nodes, also remove related nodes and edges from the drag layer\n              updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });\n              \n            } else if( draggedElements[i]._private.group === 'edges' ){\n              draggedElements[i]._private.rscratch.inDragLayer = false;\n            }\n            \n          }\n\n          if( down ){ down.trigger('free'); }\n\n  //        draggedElements = r.dragData.possibleDragElements = [];\n          \n        }\n      \n      } // else not right mouse\n\n      select[4] = 0; r.hoverData.down = null;\n      \n      //r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true; \n      \n//      console.log('mu', pos[0], pos[1]);\n//      console.log('ss', select);\n      \n      r.dragData.didDrag = false;\n      r.hoverData.dragDelta = [];\n      \n    }, false);\n\n    var wheelHandler = function(e) { \n      if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom\n\n      var cy = r.data.cy;\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var rpos = [pos[0] * cy.zoom() + cy.pan().x,\n                    pos[1] * cy.zoom() + cy.pan().y];\n      \n      if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom\n        e.preventDefault();\n        return;\n      }\n\n      if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){\n        e.preventDefault();\n        \n        r.data.wheelZooming = true;\n        clearTimeout( r.data.wheelTimeout );\n        r.data.wheelTimeout = setTimeout(function(){\n          r.data.wheelZooming = false;\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          r.redraw();\n        }, 150);\n\n        var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;\n        diff = diff * r.wheelSensitivity;\n\n        var needsWheelFix = e.deltaMode === 1;\n        if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows\n          diff *= 33;\n        }\n\n        cy.zoom({\n          level: cy.zoom() * Math.pow(10, diff),\n          renderedPosition: { x: rpos[0], y: rpos[1] }\n        });\n      }\n\n    };\n    \n    // Functions to help with whether mouse wheel should trigger zooming\n    // --\n    r.registerBinding(r.data.container, 'wheel', wheelHandler, true);\n\n    // disable nonstandard wheel events\n    // r.registerBinding(r.data.container, 'mousewheel', wheelHandler, true);\n    // r.registerBinding(r.data.container, 'DOMMouseScroll', wheelHandler, true);\n    // r.registerBinding(r.data.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n    r.registerBinding(window, 'scroll', function(e){\n      r.scrollingPage = true;\n\n      clearTimeout( r.scrollingPageTimeout );\n      r.scrollingPageTimeout = setTimeout(function(){\n        r.scrollingPage = false;\n      }, 250);\n    }, true);\n    \n    // Functions to help with handling mouseout/mouseover on the Cytoscape container\n          // Handle mouseout on Cytoscape container\n    r.registerBinding(r.data.container, 'mouseout', function(e) { \n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      r.data.cy.trigger(new $$.Event(e, {\n        type: 'mouseout',\n        cyPosition: { x: pos[0], y: pos[1] }\n      }));\n    }, false);\n    \n    r.registerBinding(r.data.container, 'mouseover', function(e) { \n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      r.data.cy.trigger(new $$.Event(e, {\n        type: 'mouseover',\n        cyPosition: { x: pos[0], y: pos[1] }\n      }));\n    }, false);\n    \n    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n    var center1, modelCenter1; // center point on start pinch to zoom\n    var offsetLeft, offsetTop;\n    var containerWidth, containerHeight;\n    var twoFingersStartInside;\n\n    var distance = function(x1, y1, x2, y2){\n      return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );\n    };\n\n    var distanceSq = function(x1, y1, x2, y2){\n      return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\n    };\n\n    r.registerBinding(r.data.container, 'touchstart', function(e) {\n\n      clearTimeout( this.threeFingerSelectTimeout );\n\n      if( e.target !== r.data.link ){\n        e.preventDefault();\n      }\n    \n      r.touchData.capture = true;\n      r.data.bgActivePosistion = undefined;\n\n      var cy = r.data.cy; \n      var nodes = r.getCachedNodes();\n      var edges = r.getCachedEdges();\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n      \n      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n    \n\n      // record starting points for pinch-to-zoom\n      if( e.touches[1] ){\n\n        // anything in the set of dragged eles should be released\n        var release = function( eles ){\n          for( var i = 0; i < eles.length; i++ ){\n            eles[i]._private.grabbed = false;\n            eles[i]._private.rscratch.inDragLayer = false;\n            if( eles[i].active() ){ eles[i].unactivate(); }\n          }\n        };\n        release(nodes);\n        release(edges);\n\n        var offsets = r.findContainerClientCoords();\n        offsetLeft = offsets[0];\n        offsetTop = offsets[1];\n        containerWidth = offsets[2];\n        containerHeight = offsets[3];\n\n        f1x1 = e.touches[0].clientX - offsetLeft;\n        f1y1 = e.touches[0].clientY - offsetTop;\n        \n        f2x1 = e.touches[1].clientX - offsetLeft;\n        f2y1 = e.touches[1].clientY - offsetTop;\n\n        twoFingersStartInside = \n             0 <= f1x1 && f1x1 <= containerWidth\n          && 0 <= f2x1 && f2x1 <= containerWidth\n          && 0 <= f1y1 && f1y1 <= containerHeight\n          && 0 <= f2y1 && f2y1 <= containerHeight\n        ;\n\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n\n        distance1 = distance( f1x1, f1y1, f2x1, f2y1 );\n        distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );\n        center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];\n        modelCenter1 = [ \n          (center1[0] - pan.x) / zoom,\n          (center1[1] - pan.y) / zoom\n        ];\n\n        // consider context tap\n        var cxtDistThreshold = 200;\n        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n        if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){\n\n          var near1 = r.findNearestElement(now[0], now[1], true);\n          var near2 = r.findNearestElement(now[2], now[3], true);\n\n          //console.log(distance1)\n\n          if( near1 && near1.isNode() ){\n            near1.activate().trigger( new $$.Event(e, {\n              type: 'cxttapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n            r.touchData.start = near1;\n          \n          } else if( near2 && near2.isNode() ){\n            near2.activate().trigger( new $$.Event(e, {\n              type: 'cxttapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n            r.touchData.start = near2;\n          \n          } else {\n            cy.trigger( new $$.Event(e, {\n              type: 'cxttapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n            r.touchData.start = null;\n          } \n\n          if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n          r.touchData.cxt = true;\n          r.touchData.cxtDragged = false;\n          r.data.bgActivePosistion = undefined;\n\n          //console.log('cxttapstart')\n\n          r.redraw();\n          return;\n          \n        }\n\n        // console.log(center1);\n        // console.log('touchstart ptz');\n        // console.log(offsetLeft, offsetTop);\n        // console.log(f1x1, f1y1);\n        // console.log(f2x1, f2y1);\n        // console.log(distance1);\n        // console.log(center1);\n      }\n\n      // console.log('another tapstart')\n      \n      \n      if (e.touches[2]) {\n      \n      } else if (e.touches[1]) {\n        \n      } else if (e.touches[0]) {\n        var near = r.findNearestElement(now[0], now[1], true);\n\n        if (near != null) {\n          near.activate();\n\n          r.touchData.start = near;\n          \n          if( near.isNode() && r.nodeIsDraggable(near) ){\n\n            var draggedEles = r.dragData.touchDragEles = [];\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            if( near.selected() ){\n              // reset drag elements, since near will be added again\n\n              var selectedNodes = cy.$(function(){\n                return this.isNode() && this.selected();\n              });\n\n              for( var k = 0; k < selectedNodes.length; k++ ){\n                var selectedNode = selectedNodes[k];\n\n                if( r.nodeIsDraggable(selectedNode) ){\n                  addNodeToDrag( selectedNode, { addToList: draggedEles } );\n                }\n              }\n            } else {\n              addNodeToDrag( near, { addToList: draggedEles } );\n            }\n\n            near.trigger( new $$.Event(e, {\n              type: 'grab',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n          }\n          \n          near\n            .trigger(new $$.Event(e, {\n              type: 'touchstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousdown',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n          ;\n        } if (near == null) {\n          cy\n            .trigger(new $$.Event(e, {\n              type: 'touchstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousedown',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n          ;\n\n          r.data.bgActivePosistion = {\n            x: pos[0],\n            y: pos[1]\n          };\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          r.redraw();\n        }\n        \n        \n        // Tap, taphold\n        // -----\n        \n        for (var i=0; i<now.length; i++) {\n          earlier[i] = now[i];\n          r.touchData.startPosition[i] = now[i];\n        }\n        \n        r.touchData.singleTouchMoved = false;\n        r.touchData.singleTouchStartTime = +new Date();\n        \n        clearTimeout( r.touchData.tapholdTimeout );\n        r.touchData.tapholdTimeout = setTimeout(function() {\n          if(\n              r.touchData.singleTouchMoved === false\n              && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n\n              // This time double constraint prevents multiple quick taps\n              // followed by a taphold triggering multiple taphold events\n              //&& Date.now() - r.touchData.singleTouchStartTime > 250\n          ){\n            if (r.touchData.start) {\n              r.touchData.start.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n            } else {\n              r.data.cy.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n\n              cy.$(':selected').unselect();\n            }\n\n//            console.log('taphold');\n          }\n        }, r.tapholdDuration);\n      }\n      \n      //r.redraw();\n      \n    }, false);\n    \n// console.log = function(m){ $('#console').append('<div>'+m+'</div>'); };\n\n    r.registerBinding(window, 'touchmove', $$.util.throttle(function(e) {\n    \n      var select = r.data.select;\n      var capture = r.touchData.capture; //if (!capture) { return; }; \n      if( capture ){ e.preventDefault(); }\n    \n      var cy = r.data.cy; \n      var now = r.touchData.now; var earlier = r.touchData.earlier;\n      var zoom = cy.zoom();\n      \n      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }\n      \n      var startPos = r.touchData.startPosition;\n\n      var dx = now[0] - startPos[0];\n      var dx2 = dx * dx;\n      var dy = now[1] - startPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom;\n\n      if( capture && r.touchData.cxt ){\n        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n        // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n        var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n        var factorSq = distance2Sq / distance1Sq;\n\n        var distThreshold = 150;\n        var distThresholdSq = distThreshold * distThreshold;\n        var factorThreshold = 1.5;\n        var factorThresholdSq = factorThreshold * factorThreshold;\n\n        //console.log(factor, distance2)\n\n        // cancel ctx gestures if the distance b/t the fingers increases\n        if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){\n          r.touchData.cxt = false;\n          if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }\n          r.data.bgActivePosistion = undefined;\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n          var cxtEvt = new $$.Event(e, {\n            type: 'cxttapend',\n            cyPosition: { x: now[0], y: now[1] }\n          });\n          if( r.touchData.start ){\n            r.touchData.start.trigger( cxtEvt );\n          } else {\n            cy.trigger( cxtEvt );\n          }\n        }\n\n      }  \n\n      if( capture && r.touchData.cxt ){ \n        var cxtEvt = new $$.Event(e, {\n          type: 'cxtdrag',\n          cyPosition: { x: now[0], y: now[1] }\n        });\n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        if( r.touchData.start ){\n          r.touchData.start.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n        r.touchData.cxtDragged = true;\n\n        //console.log('cxtdrag')\n\n        var near = r.findNearestElement(now[0], now[1], true);\n\n        if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){\n\n          if( r.touchData.cxtOver ){\n            r.touchData.cxtOver.trigger( new $$.Event(e, {\n              type: 'cxtdragout',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n\n            // console.log('cxtdragout');\n          }\n\n          r.touchData.cxtOver = near;\n\n          if( near ){\n            near.trigger( new $$.Event(e, {\n              type: 'cxtdragover',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n\n            // console.log('cxtdragover');\n          }\n\n        }\n\n      } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){ \n        r.data.bgActivePosistion = undefined;\n        clearTimeout( this.threeFingerSelectTimeout );\n        this.lastThreeTouch = +new Date();\n\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        if( !select || select.length === 0 || select[0] === undefined ){\n          select[0] = (now[0] + now[2] + now[4])/3;\n          select[1] = (now[1] + now[3] + now[5])/3;\n          select[2] = (now[0] + now[2] + now[4])/3 + 1;\n          select[3] = (now[1] + now[3] + now[5])/3 + 1;\n        } else {\n          select[2] = (now[0] + now[2] + now[4])/3;\n          select[3] = (now[1] + now[3] + now[5])/3;\n        }\n\n        select[4] = 1;\n\n        r.redraw();\n\n      } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom\n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        var draggedEles = r.dragData.touchDragEles;\n        if( draggedEles ){ \n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n          for( var i = 0; i < draggedEles.length; i++ ){\n            draggedEles[i]._private.grabbed = false;\n            draggedEles[i]._private.rscratch.inDragLayer = false;\n          }\n        }\n\n        // console.log('touchmove ptz');\n\n        // (x2, y2) for fingers 1 and 2\n        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n\n        // console.log( f1x2, f1y2 )\n        // console.log( f2x2, f2y2 )\n\n        var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n        // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n        var factor = distance2 / distance1;\n\n        // console.log(distance2)\n        // console.log(factor)\n\n        if( factor != 1 && twoFingersStartInside){\n\n          // console.log(factor)\n          // console.log(distance2 + ' / ' + distance1);\n          // console.log('--');\n\n          // delta finger1\n          var df1x = f1x2 - f1x1;\n          var df1y = f1y2 - f1y1;\n\n          // delta finger 2\n          var df2x = f2x2 - f2x1;\n          var df2y = f2y2 - f2y1;\n\n          // translation is the normalised vector of the two fingers movement\n          // i.e. so pinching cancels out and moving together pans\n          var tx = (df1x + df2x)/2;\n          var ty = (df1y + df2y)/2;\n\n          // adjust factor by the speed multiplier\n          // var speed = 1.5;\n          // if( factor > 1 ){\n          //   factor = (factor - 1) * speed + 1;\n          // } else {\n          //   factor = 1 - (1 - factor) * speed;\n          // }\n\n          // now calculate the zoom\n          var zoom1 = cy.zoom();\n          var zoom2 = zoom1 * factor;\n          var pan1 = cy.pan();\n\n          // the model center point converted to the current rendered pos\n          var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n          var ctry = modelCenter1[1] * zoom1 + pan1.y;\n\n          var pan2 = {\n            x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,\n            y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry\n          };\n\n          // console.log(pan2);\n          // console.log(zoom2);\n\n          // remove dragged eles\n          if( r.touchData.start ){\n            var draggedEles = r.dragData.touchDragEles;\n\n            if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){\n              draggedEles[i]._private.grabbed = false;\n              draggedEles[i]._private.rscratch.inDragLayer = false;\n            } }\n\n            r.touchData.start._private.active = false;\n            r.touchData.start._private.grabbed = false;\n            r.touchData.start._private.rscratch.inDragLayer = false;\n\n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            r.touchData.start\n              .trigger('free')\n              .trigger('unactivate')\n            ;\n          }\n\n          cy.viewport({\n            zoom: zoom2,\n            pan: pan2,\n            cancelOnFailedZoom: true\n          });\n\n          distance1 = distance2;  \n          f1x1 = f1x2;\n          f1y1 = f1y2;\n          f2x1 = f2x2;\n          f2y1 = f2y2;\n\n          r.pinching = true;\n        }\n        \n        // Re-project\n        if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n        if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n        if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n\n      } else if (e.touches[0]) {\n        var start = r.touchData.start;\n        var last = r.touchData.last;\n        var near = near || r.findNearestElement(now[0], now[1], true);\n\n        if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){\n\n          if( rdist2 >= r.tapThreshold2 ){ // then dragging can happen\n            var draggedEles = r.dragData.touchDragEles;\n\n            for( var k = 0; k < draggedEles.length; k++ ){\n              var draggedEle = draggedEles[k];\n\n              if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){\n                r.dragData.didDrag = true;\n                var dPos = draggedEle._private.position;\n                var justStartedDrag = !r.hoverData.draggingEles;\n\n                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){\n                  dPos.x += disp[0];\n                  dPos.y += disp[1];\n                }\n\n                if( justStartedDrag ){\n                  addNodeToDrag( draggedEle, { inDragLayer: true } );\n\n                  var dragDelta = r.touchData.dragDelta;\n\n                  if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){\n                    dPos.x += dragDelta[0];\n                    dPos.y += dragDelta[1];\n                  }\n\n                }\n              }\n            }\n\n            var tcol = new $$.Collection(cy, draggedEle);\n            \n            tcol.updateCompoundBounds();\n            tcol.trigger('position drag');\n\n            r.hoverData.draggingEles = true;\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            if( \n                 r.touchData.startPosition[0] == earlier[0]\n              && r.touchData.startPosition[1] == earlier[1]\n            ){\n              \n              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n            }\n            \n            r.redraw();\n          } else { // otherise keep track of drag delta for later\n            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\n            if( dragDelta.length === 0 ){\n              dragDelta.push(0);\n              dragDelta.push(0);\n            } else {\n              dragDelta[0] += disp[0];\n              dragDelta[1] += disp[1];\n            }\n          }\n        }\n        \n        // Touchmove event\n        {\n\n          if (start != null) {\n            start.trigger( new $$.Event(e, {\n              type: 'touchmove',\n              cyPosition: { x: now[0], y: now[1] }\n            }) ); \n\n            start.trigger( new $$.Event(e, {\n              type: 'tapdrag',\n              cyPosition: { x: now[0], y: now[1] }\n            }) ); \n\n            start.trigger( new $$.Event(e, {\n              type: 'vmousemove',\n              cyPosition: { x: now[0], y: now[1] }\n            }) ); \n          }\n          \n          if (start == null) { \n\n            if (near != null) { \n              near.trigger( new $$.Event(e, {\n                type: 'touchmove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n\n              near.trigger( new $$.Event(e, {\n                type: 'tapdrag',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n\n              near.trigger( new $$.Event(e, {\n                type: 'vmousemove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n            }\n\n            if (near == null) { \n              cy.trigger( new $$.Event(e, {\n                type: 'touchmove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n\n              cy.trigger( new $$.Event(e, {\n                type: 'tapdrag',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n\n              cy.trigger( new $$.Event(e, {\n                type: 'vmousemove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n            }\n          }\n\n          if (near != last) {\n            if (last) { last.trigger(new $$.Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }\n            if (near) { near.trigger(new $$.Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }\n          }\n\n          r.touchData.last = near;\n        }\n        \n        // Check to cancel taphold\n        for (var i=0;i<now.length;i++) {\n          if (now[i] \n            && r.touchData.startPosition[i]\n            && Math.abs(now[i] - r.touchData.startPosition[i]) > 4) {\n            \n            r.touchData.singleTouchMoved = true;\n          }\n        }\n        \n        if(\n            capture\n            && ( start == null || start.isEdge() )\n            && cy.panningEnabled() && cy.userPanningEnabled()\n        ){\n\n          if( r.swipePanning ){\n            cy.panBy({\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            });\n\n          } else if( rdist2 >= r.tapThreshold2 ){\n            r.swipePanning = true;\n\n            cy.panBy({\n              x: dx * zoom,\n              y: dy * zoom\n            });\n          }\n\n          if( start ){\n            start.unactivate();\n\n            if( !r.data.bgActivePosistion ){\n              r.data.bgActivePosistion = {\n                x: now[0],\n                y: now[1]\n              };\n            }\n\n            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n            r.touchData.start = null;\n          }\n          \n          // Re-project\n          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n          now[0] = pos[0]; now[1] = pos[1];\n        }\n      }\n\n      for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }\n      //r.redraw();\n      \n    }, 1000/30, { trailing: true }), false);\n    \n    r.registerBinding(window, 'touchcancel', function(e) {\n      var start = r.touchData.start;\n\n      r.touchData.capture = false;\n\n      if( start ){\n        start.unactivate();\n      }\n    });\n\n    r.registerBinding(window, 'touchend', function(e) {\n      var start = r.touchData.start;\n\n      var capture = r.touchData.capture; \n\n      if( capture ){\n        r.touchData.capture = false;\n      } else {\n        return;\n      }\n      \n      e.preventDefault();\n      var select = r.data.select;\n\n      r.swipePanning = false;\n      r.hoverData.draggingEles = false;\n      \n      var cy = r.data.cy; \n      var zoom = cy.zoom();\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n\n      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n      \n      if( start ){\n        start.unactivate();\n      }\n\n      var ctxTapend;\n      if( r.touchData.cxt ){\n        ctxTapend = new $$.Event(e, {\n          type: 'cxttapend',\n          cyPosition: { x: now[0], y: now[1] }\n        });\n\n        if( start ){\n          start.trigger( ctxTapend );\n        } else {\n          cy.trigger( ctxTapend );\n        }\n\n        //console.log('cxttapend')\n\n        if( !r.touchData.cxtDragged ){\n          var ctxTap = new $$.Event(e, {\n            type: 'cxttap',\n            cyPosition: { x: now[0], y: now[1] }\n          });\n\n          if( start ){\n            start.trigger( ctxTap );\n          } else {\n            cy.trigger( ctxTap );\n          }\n\n          //console.log('cxttap')\n        }\n\n        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n        r.touchData.cxt = false;\n        r.touchData.start = null;\n\n        r.redraw();\n        return;\n      }\n\n      // no more box selection if we don't have three fingers\n      if( !e.touches[2] && cy.boxSelectionEnabled() ){\n        clearTimeout( this.threeFingerSelectTimeout );\n        //this.threeFingerSelectTimeout = setTimeout(function(){\n          var newlySelected = [];\n          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );\n\n          select[0] = undefined;\n          select[1] = undefined;\n          select[2] = undefined;\n          select[3] = undefined;\n          select[4] = 0;\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n          // console.log(box);\n          for( var i = 0; i< box.length; i++ ) { \n            if( box[i]._private.selectable ){\n              newlySelected.push( box[i] );\n            }\n          }\n\n          var newlySelCol = new $$.Collection( cy, newlySelected );\n\n          if( cy.selectionType() === 'single' ){\n            cy.$(':selected').not( newlySelCol ).unselect();\n          }\n\n          newlySelCol.select();\n          \n          if( newlySelCol.length > 0 ) { \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          } else {\n            r.redraw();\n          }\n\n        //}, 100);\n      }\n\n      var updateStartStyle = false;\n\n      if( start != null ){\n        start._private.active = false;\n        updateStartStyle = true;\n        start.unactivate();\n      }\n\n      if (e.touches[2]) {\n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n      } else if (e.touches[1]) {\n        \n      } else if (e.touches[0]) {\n      \n      // Last touch released\n      } else if (!e.touches[0]) {\n        \n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        if (start != null ) {\n\n          if( start._private.grabbed ){\n            start._private.grabbed = false;\n            start.trigger('free');\n            start._private.rscratch.inDragLayer = false;\n          }\n          \n          var sEdges = start._private.edges;\n          for (var j=0;j<sEdges.length;j++) { sEdges[j]._private.rscratch.inDragLayer = false; }\n          updateAncestorsInDragLayer(start, false);\n          \n          if( start.selected() ){\n            var selectedNodes = cy.$('node:selected');\n\n            for( var k = 0; k < selectedNodes.length; k++ ){\n\n              var selectedNode = selectedNodes[k];\n              selectedNode._private.rscratch.inDragLayer = false;\n              selectedNode._private.grabbed = false;\n\n              var sEdges = selectedNode._private.edges;\n              for (var j=0; j<sEdges.length; j++) {\n                sEdges[j]._private.rscratch.inDragLayer = false;\n              }\n\n              updateAncestorsInDragLayer(selectedNode, false);\n            }\n          }\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; \n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          \n          start\n            .trigger(new $$.Event(e, {\n              type: 'touchend',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapend',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmouseup',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n          ;\n          \n          start.unactivate();\n\n          r.touchData.start = null;\n          \n        } else {\n          var near = r.findNearestElement(now[0], now[1], true);\n        \n          if (near != null) { \n            near\n              .trigger(new $$.Event(e, {\n                type: 'touchend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          }\n\n          if (near == null) { \n            cy\n              .trigger(new $$.Event(e, {\n                type: 'touchend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          }\n        }\n\n        var dx = r.touchData.startPosition[0] - now[0];\n        var dx2 = dx * dx;\n        var dy = r.touchData.startPosition[1] - now[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        var rdist2 = dist2 * zoom * zoom;\n        \n        // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n        if (start != null \n            && !r.dragData.didDrag // didn't drag nodes around\n            && start._private.selectable \n            && rdist2 < r.tapThreshold2\n            && !r.pinching // pinch to zoom should not affect selection\n        ) {\n\n          if( cy.selectionType() === 'single' ){\n            cy.$(':selected').not( start ).unselect();\n            start.select();\n          } else {\n            if( start.selected() ){\n              start.unselect();\n            } else {\n              start.select();\n            }\n          }\n\n          updateStartStyle = true;\n\n          \n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n        }\n        \n        // Tap event, roughly same as mouse click event for touch\n        if ( r.touchData.singleTouchMoved === false ) {\n\n          if (start) {\n            start\n              .trigger(new $$.Event(e, {\n                type: 'tap',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vclick',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          } else {\n            cy\n              .trigger(new $$.Event(e, {\n                type: 'tap',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vclick',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          }\n          \n//          console.log('tap');\n        }\n        \n        r.touchData.singleTouchMoved = true;\n      }\n      \n      for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }\n\n      r.dragData.didDrag = false; // reset for next mousedown\n\n      if( e.touches[0] ){\n        r.touchData.dragDelta = [];\n      }\n\n      if( updateStartStyle && start ){\n        start.updateStyle(false);\n      }\n\n      if( e.touches.length < 2 ){\n        r.pinching = false;\n        r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n        r.redraw();\n      }\n\n      //r.redraw();\n      \n    }, false);\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n  var renderer = CanvasRenderer.prototype;\n  var usePaths = CanvasRenderer.usePaths();\n\n  // Node shape contract:\n  //\n  // draw: draw\n  // intersectLine: report intersection from x, y, to node center\n  // checkPoint: check x, y in node\n\n  var nodeShapes = CanvasRenderer.nodeShapes = {};\n\n  var sin0 = Math.sin(0);\n  var cos0 = Math.cos(0);\n\n  var sin = {};\n  var cos = {};\n\n  var ellipseStepSize = 0.1;\n\n  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {\n    sin[i] = Math.sin(i);\n    cos[i] = Math.cos(i);\n  }\n\n  nodeShapes['ellipse'] = {\n    draw: function(context, centerX, centerY, width, height) {\n      nodeShapes['ellipse'].drawPath(context, centerX, centerY, width, height);\n      context.fill();\n      \n//      console.log('drawing ellipse');\n//      console.log(arguments);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      \n      if( usePaths ){\n        if( context.beginPath ){ context.beginPath(); }\n\n        var xPos, yPos;\n        var rw = width/2;\n        var rh = height/2;\n        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {\n            xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;\n            yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;\n\n            if (i === 0) {\n                context.moveTo(xPos, yPos);\n            } else {\n                context.lineTo(xPos, yPos);\n            }\n        }\n        context.closePath();\n\n      } else {\n\n        if( context.beginPath ){ context.beginPath(); }\n        context.translate(centerX, centerY);\n        context.scale(width / 2, height / 2);\n        // At origin, radius 1, 0 to 2pi\n        context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle\n        context.closePath();\n\n        context.scale(2/width, 2/height);\n        context.translate(-centerX, -centerY);\n\n      }\n      \n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      var intersect = $$.math.intersectLineEllipse(\n        x, y,\n        nodeX,\n        nodeY,\n        width / 2 + padding,\n        height / 2 + padding);\n      \n      return intersect;\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      return $$.math.boxIntersectEllipse(\n        x1, y1, x2, y2, padding, width, height, centerX, centerY);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n//      console.log(arguments);\n      \n      x -= centerX;\n      y -= centerY;\n      \n      x /= (width / 2 + padding);\n      y /= (height / 2 + padding);\n      \n      return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);\n    }\n  };\n  \n  nodeShapes['triangle'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(3, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['triangle'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['triangle'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.polygonIntersectLine(\n        x, y,\n        nodeShapes['triangle'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    \n      /*\n      polygonIntersectLine(x, y, basePoints, centerX, centerY, \n        width, height, padding);\n      */\n      \n      \n      /*\n      return renderer.polygonIntersectLine(\n        node, width, height,\n        x, y, nodeShapes['triangle'].points);\n      */\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['triangle'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(\n        x, y, nodeShapes['triangle'].points,\n        centerX, centerY, width, height,\n        [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['square'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['square'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['square'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.polygonIntersectLine(\n          x, y,\n          nodeShapes['square'].points,\n          nodeX,\n          nodeY,\n          width / 2, height / 2,\n          padding);\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2,\n      width, height, centerX, \n      centerY, padding) {\n      \n      var points = nodeShapes['square'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, \n        centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['square'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['rectangle'] = nodeShapes['square'];\n  \n  nodeShapes['octogon'] = {};\n  \n  nodeShapes['roundrectangle'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawRoundRectangle(context,\n        centerX, centerY,\n        width, height,\n        10);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawRoundRectanglePath(context,\n        centerX, centerY,\n        width, height,\n        10);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.roundRectangleIntersectLine(\n          x, y,\n          nodeX,\n          nodeY,\n          width, height,\n          padding);\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2,\n      width, height, centerX, \n      centerY, padding) {\n\n      return $$.math.roundRectangleIntersectBox(\n        x1, y1, x2, y2, \n        width, height, centerX, centerY, padding);\n    },\n    \n    // Looks like the width passed into this function is actually the total width / 2\n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      var cornerRadius = $$.math.getRoundRectangleRadius(width, height);\n      \n      // Check hBox\n      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,\n        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding)) {\n        return true;\n      }\n      \n      // Check vBox\n      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,\n        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding)) {\n        return true;\n      }\n      \n      var checkInEllipse = function(x, y, centerX, centerY, width, height, padding) {\n        x -= centerX;\n        y -= centerY;\n        \n        x /= (width / 2 + padding);\n        y /= (height / 2 + padding);\n        \n        return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);\n      };\n      \n      \n      // Check top left quarter circle\n      if (checkInEllipse(x, y,\n        centerX - width / 2 + cornerRadius,\n        centerY - height / 2 + cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      /*\n      if (renderer.boxIntersectEllipse(x, y, x, y, padding, \n        cornerRadius * 2, cornerRadius * 2,\n        centerX - width + cornerRadius,\n        centerY - height + cornerRadius)) {\n        return true;\n      }\n      */\n      \n      // Check top right quarter circle\n      if (checkInEllipse(x, y,\n        centerX + width / 2 - cornerRadius,\n        centerY - height / 2 + cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      // Check bottom right quarter circle\n      if (checkInEllipse(x, y,\n        centerX + width / 2 - cornerRadius,\n        centerY + height / 2 - cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      // Check bottom left quarter circle\n      if (checkInEllipse(x, y,\n        centerX - width / 2 + cornerRadius,\n        centerY + height / 2 - cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      return false;\n    }\n  };\n  \n  nodeShapes['pentagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(5, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height, nodeShapes['pentagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height, nodeShapes['pentagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['pentagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['pentagon'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['pentagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['hexagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(6, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['hexagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['hexagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.polygonIntersectLine(\n        x, y,\n        nodeShapes['hexagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n        \n      var points = nodeShapes['hexagon'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['hexagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['heptagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(7, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['heptagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['heptagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['heptagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['heptagon'].points;\n      \n      return renderer.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n\n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['heptagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['octagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(8, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['octagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['octagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['octagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['octagon'].points;\n      \n      return renderer.boxIntersectPolygon(\n          x1, y1, x2, y2,\n          points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['octagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  var star5Points = new Array(20);\n  {\n    var outerPoints = $$.math.generateUnitNgonPoints(5, 0);\n    var innerPoints = $$.math.generateUnitNgonPoints(5, Math.PI / 5);\n    \n//    console.log(outerPoints);\n//    console.log(innerPoints);\n    \n    // Outer radius is 1; inner radius of star is smaller\n    var innerRadius = 0.5 * (3 - Math.sqrt(5));\n    innerRadius *= 1.57;\n    \n    for (var i=0;i<innerPoints.length/2;i++) {\n      innerPoints[i*2] *= innerRadius;\n      innerPoints[i*2+1] *= innerRadius;\n    }\n    \n    for (var i=0;i<20/4;i++) {\n      star5Points[i*4] = outerPoints[i*2];\n      star5Points[i*4+1] = outerPoints[i*2+1];\n      \n      star5Points[i*4+2] = innerPoints[i*2];\n      star5Points[i*4+3] = innerPoints[i*2+1];\n    }\n    \n//    console.log(star5Points);\n  }\n\n  star5Points = $$.math.fitPolygonToSquare( star5Points );\n  \n  nodeShapes['star5'] = nodeShapes['star'] = {\n    points: star5Points,\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['star5'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['star5'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['star5'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['star5'].points;\n      \n      return renderer.boxIntersectPolygon(\n          x1, y1, x2, y2,\n          points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['star5'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    animate: true, // whether to show the layout as it's running\n    maxSimulationTime: 4000, // max length in ms to run the layout\n    fit: true, // on every layout reposition of nodes, fit the viewport\n    padding: 30, // padding around the simulation\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n\n    // callbacks on layout events\n    ready: undefined, // callback on layoutready \n    stop: undefined, // callback on layoutstop\n\n    // forces used by arbor (use arbor default on undefined)\n    repulsion: undefined,\n    stiffness: undefined,\n    friction: undefined,\n    gravity: true,\n    fps: undefined,\n    precision: undefined,\n\n    // static numbers or functions that dynamically return what these\n    // values should be for each element\n    // e.g. nodeMass: function(n){ return n.data('weight') }\n    nodeMass: undefined, \n    edgeLength: undefined,\n\n    stepSize: 0.1, // smoothing of arbor bounding box\n\n    // function that returns true if the system is stable to indicate\n    // that the layout can be stopped\n    stableEnergy: function( energy ){\n      var e = energy; \n      return (e.max <= 0.5) || (e.mean <= 0.3);\n    },\n\n    // infinite layout options\n    infinite: false // overrides all other options for a forces-all-the-time mode\n  };\n  \n  function ArborLayout(options){\n    this._private = {};\n\n    this._private.options = $$.util.extend({}, defaults, options);\n  }\n    \n  ArborLayout.prototype.run = function(){\n    var layout = this;\n    var options = this._private.options;\n\n    $$.util.require('arbor', function(arbor){\n\n      var cy = options.cy;\n      var eles = options.eles;\n      var nodes = eles.nodes().not(':parent');\n      var edges = eles.edges();\n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n      var simUpdatingPos = false;\n\n      layout.trigger({ type: 'layoutstart', layout: layout });\n\n      // backward compatibility for old animation option\n      if( options.liveUpdate !== undefined ){\n        options.animate = options.liveUpdate;\n      }\n\n      // arbor doesn't work with just 1 node \n      if( cy.nodes().size() <= 1 ){\n        if( options.fit ){\n          cy.reset();\n        }\n\n        cy.nodes().position({\n          x: Math.round( (bb.x1 + bb.x2)/2 ),\n          y: Math.round( (bb.y1 + bb.y2)/2 )\n        });\n\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n\n        return;\n      }\n\n      var sys = layout._private.system = arbor.ParticleSystem();\n\n      sys.parameters({\n        repulsion: options.repulsion,\n        stiffness: options.stiffness, \n        friction: options.friction, \n        gravity: options.gravity, \n        fps: options.fps, \n        dt: options.dt, \n        precision: options.precision\n      });\n\n      if( options.animate && options.fit ){\n        cy.fit( bb, options.padding );\n      }\n      \n      var doneTime = 250;\n      var doneTimeout;\n      \n      var ready = false;\n      \n      var lastDraw = +new Date();\n      var sysRenderer = {\n        init: function(system){\n        },\n        redraw: function(){\n          var energy = sys.energy();\n\n          // if we're stable (according to the client), we're done\n          if( !options.infinite && options.stableEnergy != null && energy != null && energy.n > 0 && options.stableEnergy(energy) ){\n            layout.stop();\n            return;\n          }\n\n          if( !options.infinite && doneTime != Infinity ){\n            clearTimeout(doneTimeout);\n            doneTimeout = setTimeout(doneHandler, doneTime);\n          }\n          \n          var movedNodes = cy.collection();\n          \n          sys.eachNode(function(n, point){ \n            var data = n.data;\n            var node = data.element;\n            \n            if( node == null ){\n              return;\n            }\n\n            if( !node.locked() && !node.grabbed() ){\n              node.silentPosition({\n                x: bb.x1 + point.x,\n                y: bb.y1 + point.y\n              });\n\n              movedNodes.merge( node );\n            }\n          });\n          \n\n          if( options.animate && movedNodes.length > 0 ){\n            simUpdatingPos = true;\n\n            movedNodes.rtrigger('position');\n\n            if( options.fit ){\n              cy.fit( options.padding );\n            }\n\n            lastDraw = +new Date();\n            simUpdatingPos = false;\n          }\n\n          \n          if( !ready ){\n            ready = true;\n            layout.one('layoutready', options.ready);\n            layout.trigger({ type: 'layoutready', layout: layout });\n          }\n        }\n        \n      };\n      sys.renderer = sysRenderer;\n      sys.screenSize( bb.w, bb.h );\n      sys.screenPadding( options.padding, options.padding, options.padding, options.padding );\n      sys.screenStep( options.stepSize );\n\n      function calculateValueForElement(element, value){\n        if( value == null ){\n          return undefined;\n        } else if( typeof value == typeof function(){} ){\n          return value.apply(element, [element._private.data, {\n            nodes: nodes.length,\n            edges: edges.length,\n            element: element\n          }]); \n        } else {\n          return value;\n        }\n      }\n\n      var grabHandler;\n      nodes.on('grab free position', grabHandler = function(e){\n        if( simUpdatingPos ){ return; }\n\n        var pos = this.position();\n        var apos = sys.fromScreen( pos );\n        if( !apos ){ return; }\n\n        var p = arbor.Point(apos.x, apos.y);\n        var padding = options.padding;\n\n        if(\n          bb.x1 + padding <= pos.x && pos.x <= bb.x2 - padding &&\n          bb.y1 + padding <= pos.y && pos.y <= bb.y2 - padding\n        ){\n          this.scratch().arbor.p = p;\n        }\n        \n        switch( e.type ){\n        case 'grab':\n          this.scratch().arbor.fixed = true;\n          break;\n        case 'free':\n          this.scratch().arbor.fixed = false;\n          //this.scratch().arbor.tempMass = 1000;\n          break;\n        }\n      });\n\n      var lockHandler;\n      nodes.on('lock unlock', lockHandler = function(e){\n        node.scratch().arbor.fixed = node.locked();\n      });\n            \n      var removeHandler;\n      eles.on('remove', removeHandler = function(e){ return; // TODO enable when layout add/remove api added\n        // var ele = this;\n        // var arborEle = ele.scratch().arbor;\n\n        // if( !arborEle ){ return; }\n\n        // if( ele.isNode() ){\n        //   sys.pruneNode( arborEle );\n        // } else {\n        //   sys.pruneEdge( arborEle );\n        // }\n      });\n\n      var addHandler;\n      cy.on('add', '*', addHandler = function(){ return; // TODO enable when layout add/remove api added\n        // var ele = this;\n\n        // if( ele.isNode() ){\n        //   addNode( ele );\n        // } else {\n        //   addEdge( ele );\n        // }\n      });\n\n      var resizeHandler;\n      cy.on('resize', resizeHandler = function(){\n        if( options.boundingBox == null && layout._private.system != null ){\n          var w = cy.width();\n          var h = cy.height();\n\n          sys.screenSize( w, h );\n        }\n      });\n\n      function addNode( node ){\n        if( node.isFullAutoParent() ){ return; } // they don't exist in the sim\n\n        var id = node._private.data.id;\n        var mass = calculateValueForElement(node, options.nodeMass);\n        var locked = node._private.locked;\n        var nPos = node.position();\n        \n        var pos = sys.fromScreen({\n          x: nPos.x,\n          y: nPos.y\n        });\n\n        node.scratch().arbor = sys.addNode(id, {\n          element: node,\n          mass: mass,\n          fixed: locked,\n          x: locked ? pos.x : undefined,\n          y: locked ? pos.y : undefined\n        });\n      }\n\n      function addEdge( edge ){\n        var src = edge.source().id();\n        var tgt = edge.target().id();\n        var length = calculateValueForElement(edge, options.edgeLength);\n        \n        edge.scratch().arbor = sys.addEdge(src, tgt, {\n          length: length\n        }); \n      }\n\n      nodes.each(function(i, node){\n        addNode( node );\n      });\n      \n      edges.each(function(i, edge){\n        addEdge( edge );\n      });\n      \n      var grabbableNodes = nodes.filter(\":grabbable\");\n      // disable grabbing if so set\n      if( options.ungrabifyWhileSimulating ){\n        grabbableNodes.ungrabify();\n      }\n      \n      var doneHandler = layout._private.doneHandler = function(){\n        layout._private.doneHandler = null;\n\n        if( !options.animate ){\n          if( options.fit ){\n            cy.reset();\n          }\n\n          nodes.rtrigger('position');\n        }\n\n        // unbind handlers\n        nodes.off('grab free position', grabHandler);\n        nodes.off('lock unlock', lockHandler);\n        eles.off('remove', removeHandler);\n        cy.off('add', '*', addHandler);\n        cy.off('resize', resizeHandler);\n        \n        // enable back grabbing if so set\n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.grabify();\n        }\n\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n      };\n      \n      sys.start();\n      if( !options.infinite && options.maxSimulationTime != null && options.maxSimulationTime > 0 && options.maxSimulationTime !== Infinity ){\n        setTimeout(function(){\n          layout.stop();\n        }, options.maxSimulationTime);\n      }\n    \n    }); // require\n\n    return this; // chaining\n  };\n\n\n  ArborLayout.prototype.stop = function(){\n    if( this._private.system != null ){\n      this._private.system.stop();\n    }\n\n    if( this._private.doneHandler ){\n      this._private.doneHandler();\n    }\n\n    return this; // chaining\n  };\n  \n  $$('layout', 'arbor', ArborLayout);\n  \n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)\n    padding: 30, // padding on fit\n    circle: false, // put depths in concentric circles if true, put depths top down if false\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n    roots: undefined, // the roots of the trees\n    maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function BreadthFirstLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  BreadthFirstLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    var graph = eles;\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var roots;\n    if( $$.is.elementOrCollection(options.roots) ){\n      roots = options.roots;\n    } else if( $$.is.array(options.roots) ){\n      var rootsArray = [];\n\n      for( var i = 0; i < options.roots.length; i++ ){\n        var id = options.roots[i];\n        var ele = cy.getElementById( id );\n        rootsArray.push( ele );\n      }\n\n      roots = new $$.Collection( cy, rootsArray );\n    } else if( $$.is.string(options.roots) ){\n      roots = cy.$( options.roots );\n\n    } else {\n      if( options.directed ){\n        roots = nodes.roots();\n      } else {\n        var components = [];\n        var unhandledNodes = nodes;\n\n        while( unhandledNodes.length > 0 ){\n          var currComp = cy.collection();\n\n          eles.bfs({\n            roots: unhandledNodes[0],\n            visit: function(i, depth, node, edge, pNode){\n              currComp = currComp.add( node );\n            },\n            directed: false\n          });\n\n          unhandledNodes = unhandledNodes.not( currComp );\n          components.push( currComp );\n        }\n\n        roots = cy.collection();\n        for( var i = 0; i < components.length; i++ ){\n          var comp = components[i];\n          var maxDegree = comp.maxDegree( false );\n          var compRoots = comp.filter(function(){\n            return this.degree(false) === maxDegree;\n          });\n\n          roots = roots.add( compRoots );\n        }\n        \n      }\n    }\n\n\n    var depths = [];\n    var foundByBfs = {};\n    var id2depth = {};\n    var prevNode = {};\n    var prevEdge = {};\n    var successors = {};\n\n    // find the depths of the nodes\n    graph.bfs({\n      roots: roots,\n      directed: options.directed,\n      visit: function(i, depth, node, edge, pNode){\n        var ele = this[0];\n        var id = ele.id();\n\n        if( !depths[depth] ){\n          depths[depth] = [];\n        }\n\n        depths[depth].push( ele );\n        foundByBfs[ id ] = true;\n        id2depth[ id ] = depth;\n        prevNode[ id ] = pNode;\n        prevEdge[ id ] = edge;\n\n        if( pNode ){\n          var prevId = pNode.id();\n          var succ = successors[ prevId ] = successors[ prevId ] || [];\n          \n          succ.push( node );\n        }\n      }\n    });\n\n    // check for nodes not found by bfs\n    var orphanNodes = [];\n    for( var i = 0; i < nodes.length; i++ ){\n      var ele = nodes[i];\n\n      if( foundByBfs[ ele.id() ] ){\n        continue;\n      } else {\n        orphanNodes.push( ele );\n      }\n    }\n\n    // assign orphan nodes a depth from their neighborhood\n    var maxChecks = orphanNodes.length * 3;\n    var checks = 0;\n    while( orphanNodes.length !== 0 && checks < maxChecks ){\n      var node = orphanNodes.shift();\n      var neighbors = node.neighborhood().nodes();\n      var assignedDepth = false;\n\n      for( var i = 0; i < neighbors.length; i++ ){\n        var depth = id2depth[ neighbors[i].id() ];\n\n        if( depth !== undefined ){\n          depths[depth].push( node );\n          assignedDepth = true;\n          break;\n        }\n      }\n\n      if( !assignedDepth ){\n        orphanNodes.push( node );\n      }\n\n      checks++;\n    }\n\n    // assign orphan nodes that are still left to the depth of their subgraph\n    while( orphanNodes.length !== 0 ){\n      var node = orphanNodes.shift();\n      //var subgraph = graph.bfs( node ).path;\n      var assignedDepth = false;\n\n      // for( var i = 0; i < subgraph.length; i++ ){\n      //   var depth = id2depth[ subgraph[i].id() ];\n\n      //   if( depth !== undefined ){\n      //     depths[depth].push( node );\n      //     assignedDepth = true;\n      //     break;\n      //   }\n      // }\n\n      if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0\n        if( depths.length === 0 ){\n          depths.push([]);\n        }\n        \n        depths[0].push( node );\n      }\n    }\n\n    // assign the nodes a depth and index\n    var assignDepthsToEles = function(){\n      for( var i = 0; i < depths.length; i++ ){\n        var eles = depths[i];\n\n        for( var j = 0; j < eles.length; j++ ){\n          var ele = eles[j];\n\n          ele._private.scratch.breadthfirst = {\n            depth: i,\n            index: j\n          };\n        }\n      }\n    };\n    assignDepthsToEles();\n\n\n    var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth\n      var edges = node.connectedEdges(function(){\n        return this.data('target') === node.id();\n      });\n      var thisInfo = node._private.scratch.breadthfirst;\n      var highestDepthOfOther = 0;\n      var highestOther;\n      for( var i = 0; i < edges.length; i++ ){\n        var edge = edges[i];\n        var otherNode = edge.source()[0];\n        var otherInfo = otherNode._private.scratch.breadthfirst;\n\n        if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){\n          highestDepthOfOther = otherInfo.depth;\n          highestOther = otherNode;\n        }\n      }\n\n      return highestOther;\n    };\n\n     // make maximal if so set by adjusting depths\n    for( var adj = 0; adj < options.maximalAdjustments; adj++ ){\n\n      var nDepths = depths.length;\n      var elesToMove = [];\n      for( var i = 0; i < nDepths; i++ ){\n        var depth = depths[i];\n\n        var nDepth = depth.length;\n        for( var j = 0; j < nDepth; j++ ){\n          var ele = depth[j];\n          var info = ele._private.scratch.breadthfirst;\n          var intEle = intersectsDepth(ele);\n\n          if( intEle ){\n            info.intEle = intEle;\n            elesToMove.push( ele );\n          }\n        }\n      }\n\n      for( var i = 0; i < elesToMove.length; i++ ){ \n        var ele = elesToMove[i];\n        var info = ele._private.scratch.breadthfirst;\n        var intEle = info.intEle;\n        var intInfo = intEle._private.scratch.breadthfirst;\n\n        depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index\n\n        // add to end of new depth\n        var newDepth = intInfo.depth + 1;\n        while( newDepth > depths.length - 1 ){\n          depths.push([]);\n        }\n        depths[ newDepth ].push( ele );\n\n        info.depth = newDepth;\n        info.index = depths[newDepth].length - 1;\n      }\n\n      assignDepthsToEles();\n    }\n\n    // find min distance we need to leave between nodes\n    var minDistance = 0;\n    if( options.avoidOverlap ){\n      for( var i = 0; i < nodes.length; i++ ){\n        var w = nodes[i].outerWidth();\n        var h = nodes[i].outerHeight();\n        \n        minDistance = Math.max(minDistance, w, h);\n      }\n      minDistance *= 1.75; // just to have some nice spacing\n    }\n\n    // get the weighted percent for an element based on its connectivity to other levels\n    var cachedWeightedPercent = {};\n    var getWeightedPercent = function( ele ){\n      if( cachedWeightedPercent[ ele.id() ] ){\n        return cachedWeightedPercent[ ele.id() ];\n      }\n\n      var eleDepth = ele._private.scratch.breadthfirst.depth;\n      var neighbors = ele.neighborhood().nodes();\n      var percent = 0;\n      var samples = 0;\n\n      for( var i = 0; i < neighbors.length; i++ ){\n        var neighbor = neighbors[i];\n        var index = neighbor._private.scratch.breadthfirst.index;\n        var depth = neighbor._private.scratch.breadthfirst.depth;\n        var nDepth = depths[depth].length;\n\n        if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above\n          percent += index / nDepth;\n          samples++;\n        }\n      }\n\n      samples = Math.max(1, samples);\n      percent = percent / samples;\n\n      if( samples === 0 ){ // so lone nodes have a \"don't care\" state in sorting\n        percent = undefined;\n      }\n\n      cachedWeightedPercent[ ele.id() ] = percent;\n      return percent;\n    };\n\n\n    // rearrange the indices in each depth level based on connectivity\n\n    var sortFn = function(a, b){\n      var apct = getWeightedPercent( a );\n      var bpct = getWeightedPercent( b );\n\n      return apct - bpct;\n    };\n\n    for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result\n\n      for( var i = 0; i < depths.length; i++ ){\n        depths[i] = depths[i].sort( sortFn );\n      }\n      assignDepthsToEles(); // and update\n\n    }\n\n    var biggestDepthSize = 0;\n    for( var i = 0; i < depths.length; i++ ){\n      biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );\n    }\n\n    var center = {\n      x: bb.x1 + bb.w/2,\n      y: bb.x1 + bb.h/2\n    };\n   \n    var getPosition = function( ele, isBottomDepth ){\n      var info = ele._private.scratch.breadthfirst;\n      var depth = info.depth;\n      var index = info.index;\n      var depthSize = depths[depth].length;\n\n      if( options.strictHierarchy ){\n        depthSize = biggestDepthSize;\n      }\n\n      var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );\n      var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );\n      var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );\n      radiusStepSize = Math.max( radiusStepSize, minDistance );\n\n      if( options.strictHierarchy && !options.circle ){\n        \n        var epos = {\n          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,\n          y: (depth + 1) * distanceY\n        };\n\n        if( isBottomDepth ){\n          return epos;\n        }\n\n        var succs = successors[ ele.id() ];\n        if( succs ){\n          epos.x = 0;\n\n          for( var i = 0 ; i < succs.length; i++ ){\n            var spos = pos[ succs[i].id() ];\n            \n            epos.x += spos.x;\n          }\n\n          epos.x /= succs.length;\n        } else {\n          //debugger;\n        }\n\n        return epos;\n\n      } else {\n        if( options.circle ){\n          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);\n          var theta = 2 * Math.PI / depths[depth].length * index;\n\n          if( depth === 0 && depths[0].length === 1 ){\n            radius = 1;\n          }\n\n          return {\n            x: center.x + radius * Math.cos(theta),\n            y: center.y + radius * Math.sin(theta)\n          };\n\n        } else {\n          return {\n            x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,\n            y: (depth + 1) * distanceY\n          };\n        }\n      }\n      \n    };\n\n    // get positions in reverse depth order\n    var pos = {};\n    for( var i = depths.length - 1; i >=0; i-- ){\n      var depth = depths[i];\n\n      for( var j = 0; j < depth.length; j++ ){\n        var node = depth[j];\n\n        pos[ node.id() ] = getPosition( node, i === depths.length - 1 );\n      }\n    }\n\n    nodes.layoutPositions(this, options, function(){\n      return pos[ this.id() ];\n    });\n    \n    return this; // chaining\n  };\n  \n  $$('layout', 'breadthfirst', BreadthFirstLayout);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // the padding on fit\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space\n    radius: undefined, // the radius of the circle\n    startAngle: 3/2 * Math.PI, // the position of the first node\n    counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function CircleLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  CircleLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    var eles = options.eles;\n      \n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var center = {\n      x: bb.x1 + bb.w/2,\n      y: bb.y1 + bb.h/2\n    };\n    \n    var theta = options.startAngle;\n    var dTheta = 2 * Math.PI / nodes.length;\n    var r;\n\n    var minDistance = 0;\n    for( var i = 0; i < nodes.length; i++ ){\n      var w = nodes[i].outerWidth();\n      var h = nodes[i].outerHeight();\n      \n      minDistance = Math.max(minDistance, w, h);\n    }\n\n    if( $$.is.number(options.radius) ){\n      r = options.radius;\n    } else if( nodes.length <= 1 ){\n      r = 0;\n    } else {\n      r = Math.min( bb.h, bb.w )/2 - minDistance;\n    }\n\n    // calculate the radius\n    if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n      minDistance *= 1.75; // just to have some nice spacing\n\n      var dTheta = 2 * Math.PI / nodes.length;\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping\n      r = Math.max( rMin, r );\n    }\n\n    var getPos = function( i, ele ){\n      var rx = r * Math.cos( theta );\n      var ry = r * Math.sin( theta );\n      var pos = {\n        x: center.x + rx,\n        y: center.y + ry\n      };\n\n      theta = options.counterclockwise ? theta - dTheta : theta + dTheta;\n      return pos;\n    };\n    \n    nodes.layoutPositions( this, options, getPos );\n\n    return this; // chaining\n  };\n  \n  $$('layout', 'circle', CircleLayout);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // default layout options\n  var defaults = {\n    animate: true, // whether to show the layout as it's running\n    refresh: 1, // number of ticks per frame; higher is faster but more jerky\n    maxSimulationTime: 4000, // max length in ms to run the layout\n    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n    fit: true, // on every layout reposition of nodes, fit the viewport\n    padding: 30, // padding around the simulation\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\n    // layout event callbacks\n    ready: function(){}, // on layoutready\n    stop: function(){}, // on layoutstop\n\n    // positioning options\n    randomize: false, // use random node positions at beginning of layout\n    avoidOverlap: true, // if true, prevents overlap of node bounding boxes\n    handleDisconnected: true, // if true, avoids disconnected components from overlapping\n    nodeSpacing: function( node ){ return 10; }, // extra spacing around nodes\n    flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }\n    alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }\n\n    // different methods of specifying edge length\n    // each can be a constant numerical value or a function like `function( edge ){ return 2; }`\n    edgeLength: undefined, // sets edge length directly in simulation\n    edgeSymDiffLength: undefined, // symmetric diff edge length in simulation\n    edgeJaccardLength: undefined, // jaccard edge length in simulation\n\n    // iterations of cola algorithm; uses default values on undefined\n    unconstrIter: undefined, // unconstrained initial layout iterations\n    userConstIter: undefined, // initial layout iterations with user-specified constraints\n    allConstIter: undefined, // initial layout iterations with all constraints including non-overlap\n\n    // infinite layout options\n    infinite: false // overrides all other options for a forces-all-the-time mode\n  };\n\n  // constructor\n  // options : object containing layout options\n  function ColaLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options); \n  }\n\n  // runs the layout\n  ColaLayout.prototype.run = function(){\n    var layout = this;\n    var options = this.options;\n\n    $$.util.require('cola', function(cola){\n\n      var cy = options.cy; // cy is automatically populated for us in the constructor\n      var eles = options.eles;\n      var nodes = eles.nodes();\n      var edges = eles.edges();\n      var ready = false;\n      \n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n\n      var getOptVal = function( val, ele ){\n        if( $$.is.fn(val) ){\n          var fn = val;\n          return fn.apply( ele, [ ele ] );\n        } else {\n          return val;\n        }\n      };\n\n      var updateNodePositions = function(){\n        var x = { min: Infinity, max: -Infinity };\n        var y = { min: Infinity, max: -Infinity };\n\n        for( var i = 0; i < nodes.length; i++ ){\n          var node = nodes[i];\n          var scratch = node._private.scratch.cola;\n\n          x.min = Math.min( x.min, scratch.x );\n          x.max = Math.max( x.max, scratch.x );\n\n          y.min = Math.min( y.min, scratch.y );\n          y.max = Math.max( y.max, scratch.y );\n        }\n\n        nodes.positions(function(i, node){\n          var pos = node._private.position;\n          var scratch = node._private.scratch.cola;\n\n          if( !node.grabbed() ){\n            pos.x = bb.x1 + scratch.x - x.min;\n            pos.y = bb.y1 + scratch.y - y.min;\n          }\n        });\n\n        if( !ready ){\n          onReady();\n          ready = true;\n        }\n\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n      };\n\n      var onDone = function(){\n        layout.manuallyStopped = false;\n\n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.grabify();\n        }\n\n        nodes.off('grab free position', grabHandler);\n        nodes.off('lock unlock', lockHandler);\n\n        // trigger layoutstop when the layout stops (e.g. finishes)\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n      };\n\n      var onReady = function(){\n        // trigger layoutready when each node has had its position set at least once\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n      };\n\n      var ticksPerFrame = options.refresh;\n      var tickSkip = 1; // frames until a tick; used to slow down sim for debugging\n\n      if( options.refresh < 0 ){\n        tickSkip = Math.abs( options.refresh );\n        ticksPerFrame = 1;\n      } else {\n        ticksPerFrame = Math.max( 1, ticksPerFrame ); // at least 1\n      }\n\n      var adaptor = cola.adaptor({\n        trigger: function( e ){ // on sim event\n          switch( e.type ){\n            case 'tick':\n              if( options.animate ){\n                updateNodePositions();\n              }\n              break;\n\n            case 'end': \n              updateNodePositions();\n              if( !options.infinite || layout.manuallyStopped ){ onDone(); }           \n              break;\n          }\n        },\n\n        kick: function( tick ){ // kick off the simulation\n          var skip = 0;\n\n          var inftick = function(){\n            var ret = tick();\n\n            if( ret && options.infinite ){ // resume layout if done\n              adaptor.resume(); // resume => new kick\n            }\n            \n            return ret; // allow regular finish b/c of new kick\n          };\n\n          var multitick = function(){ // multiple ticks in a row\n            var ret;\n\n            // skip ticks to slow down layout for debugging\n            var thisSkip = skip;\n            skip = (skip + 1) % tickSkip;\n            if( thisSkip !== 0 ){\n              return false;\n            }\n\n            for( var i = 0; i < ticksPerFrame && !ret; i++ ){\n              ret = ret || inftick(); // pick up true ret vals => sim done\n            }\n\n            return ret;\n          };\n\n          if( options.animate ){\n            var frame = function(){\n              if( multitick() ){ return; }\n\n              $$.util.requestAnimationFrame( frame );\n            };\n\n            $$.util.requestAnimationFrame( frame );\n          } else {\n            while( !inftick() ){}\n          }\n        },\n\n        on: function( type, listener ){}, // dummy; not needed\n\n        drag: function(){} // TODO\n      });\n      layout.adaptor = adaptor;\n\n      // if set no grabbing during layout\n      var grabbableNodes = nodes.filter(':grabbable');\n      if( options.ungrabifyWhileSimulating ){\n        grabbableNodes.ungrabify();\n      }\n\n      // handle node dragging\n      var grabHandler;\n      nodes.on('grab free position', grabHandler = function(e){\n        var node = this;\n        var scrCola = node._private.scratch.cola;\n        var pos = node._private.position;\n\n        if( node.grabbed() ){\n          scrCola.x = pos.x - bb.x1;\n          scrCola.y = pos.y - bb.y1;\n\n          adaptor.dragstart( scrCola );\n        } else if( $$.is.number(scrCola.x) && $$.is.number(scrCola.y) ){\n          pos.x = scrCola.x + bb.x1;\n          pos.y = scrCola.y + bb.y1;\n        }\n\n        switch( e.type ){\n          case 'grab':\n            adaptor.dragstart( scrCola );\n            adaptor.resume();\n            break;\n          case 'free':\n            adaptor.dragend( scrCola );\n            break;\n        }\n        \n      });\n\n      var lockHandler;\n      nodes.on('lock unlock', lockHandler = function(e){\n        var node = this;\n        var scrCola = node._private.scratch.cola;\n      \n        if( node.locked() ){\n          adaptor.dragstart( scrCola );\n        } else {\n          adaptor.dragend( scrCola );\n        }\n      });\n\n      var nonparentNodes = nodes.stdFilter(function( node ){\n        return !node.isParent();\n      });\n\n      // add nodes to cola\n      adaptor.nodes( nonparentNodes.map(function( node, i ){\n        var padding = getOptVal( options.nodeSpacing, node );\n        var pos = node.position();\n\n        var struct = node._private.scratch.cola = {\n          x: options.randomize ? Math.round( Math.random() * bb.w ) : pos.x,\n          y: options.randomize ? Math.round( Math.random() * bb.h ) : pos.y,\n          width: node.outerWidth() + 2*padding,\n          height: node.outerHeight() + 2*padding,\n          index: i\n        };\n\n        return struct;\n      }) );\n\n      if( options.alignment ){ // then set alignment constraints\n\n        var offsetsX = [];\n        var offsetsY = [];\n\n        nonparentNodes.forEach(function( node ){\n          var align = getOptVal( options.alignment, node );\n          var scrCola = node._private.scratch.cola;\n          var index = scrCola.index;\n\n          if( !align ){ return; }\n\n          if( align.x != null ){\n            offsetsX.push({\n              node: index,\n              offset: align.x\n            });\n          }\n\n          if( align.y != null ){\n            offsetsY.push({\n              node: index,\n              offset: align.y\n            });\n          }\n        });\n\n        // add alignment constraints on nodes\n        var constraints = [];\n\n        if( offsetsX.length > 0 ){\n          constraints.push({\n            type: 'alignment',\n            axis: 'x',\n            offsets: offsetsX\n          });\n        }\n\n        if( offsetsY.length > 0 ){\n          constraints.push({\n            type: 'alignment',\n            axis: 'y',\n            offsets: offsetsY\n          });\n        }\n        \n        adaptor.constraints( constraints );\n\n      }\n\n      // add compound nodes to cola\n      adaptor.groups( nodes.stdFilter(function( node ){\n        return node.isParent();\n      }).map(function( node, i ){ // add basic group incl leaf nodes\n        node._private.scratch.cola = {\n          index: i,\n\n          leaves: node.children().stdFilter(function( child ){\n            return !child.isParent();\n          }).map(function( child ){\n            return child[0]._private.scratch.cola.index;\n          })\n        };\n\n        return node;\n      }).map(function( node ){ // add subgroups\n        node._private.scratch.cola.groups = node.children().stdFilter(function( child ){\n          return child.isParent();\n        }).map(function( child ){\n          return child._private.scratch.cola.index;\n        });\n\n        return node._private.scratch.cola;\n      }) );\n\n      // get the edge length setting mechanism\n      var length;\n      var lengthFnName;\n      if( options.edgeLength != null ){\n        length = options.edgeLength;\n        lengthFnName = 'linkDistance';\n      } else if( options.edgeSymDiffLength != null ){\n        length = options.edgeSymDiffLength;\n        lengthFnName = 'symmetricDiffLinkLengths';\n      } else if( options.edgeJaccardLength != null ){\n        length = options.edgeJaccardLength;\n        lengthFnName = 'jaccardLinkLengths';\n      } else {\n        length = 100;\n        lengthFnName = 'linkDistance';\n      }\n\n      var lengthGetter = function( link ){\n        return link.calcLength;\n      };\n\n      // add the edges to cola\n      adaptor.links( edges.stdFilter(function( edge ){\n        return !edge.source().isParent() && !edge.target().isParent();\n      }).map(function( edge, i ){\n        var c = edge._private.scratch.cola = {\n          source: edge.source()[0]._private.scratch.cola.index,\n          target: edge.target()[0]._private.scratch.cola.index\n        };\n\n        if( length != null ){\n          c.calcLength = getOptVal( length, edge );\n        }\n\n        return c;\n      }) );\n\n      adaptor.size([ bb.w, bb.h ]);\n\n      if( length != null ){\n        adaptor[ lengthFnName ]( lengthGetter );\n      }\n\n      // set the flow of cola\n      if( options.flow ){\n        var flow;\n        var defAxis = 'y';\n        var defMinSep = 50;\n\n        if( $$.is.string(options.flow) ){\n          flow = {\n            axis: options.flow,\n            minSeparation: defMinSep\n          };\n        } else if( $$.is.number(options.flow) ){\n          flow = {\n            axis: defAxis,\n            minSeparation: options.flow\n          };\n        } else if( $$.is.plainObject(options.flow) ){\n          flow = options.flow;\n\n          flow.axis = flow.axis || defAxis;\n          flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;\n        } else { // e.g. options.flow: true\n          flow = {\n            axis: defAxis,\n            minSeparation: defMinSep\n          };\n        }\n\n        adaptor.flowLayout( flow.axis , flow.minSeparation );\n      }\n\n      adaptor\n        .avoidOverlaps( options.avoidOverlap )\n        .handleDisconnected( options.handleDisconnected )\n        .start( options.unconstrIter, options.userConstIter, options.allConstIter)\n      ;\n\n      layout.trigger({ type: 'layoutstart', layout: layout });\n\n      if( !options.infinite ){\n        setTimeout(function(){\n          adaptor.stop();\n        }, options.maxSimulationTime);\n      }\n\n    }); // require\n\n    return this; // chaining\n  };\n\n  // called on continuous layouts to stop them before they finish\n  ColaLayout.prototype.stop = function(){\n    if( this.adaptor ){\n      this.manuallyStopped = true;\n      this.adaptor.stop();\n    }\n\n    return this; // chaining\n  };\n\n  // register the layout\n  $$('layout', 'cola', ColaLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // the padding on fit\n    startAngle: 3/2 * Math.PI, // the position of the first node\n    counterclockwise: false, // whether the layout should go counterclockwise/anticlockwise (true) or clockwise (false)\n    minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n    height: undefined, // height of layout area (overrides container height)\n    width: undefined, // width of layout area (overrides container width)\n    concentric: function(){ // returns numeric value for each node, placing higher nodes in levels towards the centre\n      return this.degree();\n    },\n    levelWidth: function(nodes){ // the variation of concentric values in each level\n      return nodes.maxDegree() / 4;\n    },\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function ConcentricLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  ConcentricLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    \n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var center = {\n      x: bb.x1 + bb.w/2,\n      y: bb.y1 + bb.h/2\n    };\n    \n    var nodeValues = []; // { node, value }\n    var theta = options.startAngle;\n    var maxNodeSize = 0;\n\n    for( var i = 0; i < nodes.length; i++ ){\n      var node = nodes[i];\n      var value;\n      \n      // calculate the node value\n      value = options.concentric.call(node);\n      nodeValues.push({\n        value: value,\n        node: node\n      });\n\n      // for style mapping\n      node._private.layoutData.concentric = value;\n    }\n\n    // in case we used the `concentric` in style\n    nodes.updateStyle();\n\n    // calculate max size now based on potentially updated mappers\n    for( var i = 0; i < nodes.length; i++ ){\n      var node = nodes[i];\n\n      maxNodeSize = Math.max( maxNodeSize, node.outerWidth(), node.outerHeight() );\n    }\n\n    // sort node values in descreasing order\n    nodeValues.sort(function(a, b){\n      return b.value - a.value;\n    });\n\n    var levelWidth = options.levelWidth( nodes );\n\n    // put the values into levels\n    var levels = [ [] ];\n    var currentLevel = levels[0];\n    for( var i = 0; i < nodeValues.length; i++ ){\n      var val = nodeValues[i];\n\n      if( currentLevel.length > 0 ){\n        var diff = Math.abs( currentLevel[0].value - val.value );\n\n        if( diff >= levelWidth ){\n          currentLevel = [];\n          levels.push( currentLevel );\n        }\n      }\n\n      currentLevel.push( val );\n    }\n\n    // create positions from levels\n\n    var pos = {}; // id => position\n    var r = 0;\n    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n    if( !options.avoidOverlap ){ // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );\n      var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );\n\n      minDist = Math.min( minDist, rStep );\n    }\n\n    for( var i = 0; i < levels.length; i++ ){\n      var level = levels[i];\n      var dTheta = 2 * Math.PI / level.length;\n\n      // calculate the radius\n      if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping\n        r = Math.max( rMin, r );\n      }\n\n      for( var j = 0; j < level.length; j++ ){\n        var val = level[j];\n        var theta = options.startAngle + (options.counterclockwise ? 1 : -1) * dTheta * j;\n\n        var p = {\n          x: center.x + r * Math.cos(theta),\n          y: center.y + r * Math.sin(theta)\n        };\n\n        pos[ val.node.id() ] = p;\n      }\n\n      r += minDist;\n      \n    } \n\n    // position the nodes\n    nodes.layoutPositions(this, options, function(){\n      var id = this.id();\n\n      return pos[id];\n    });\n  \n    return this; // chaining\n  };\n  \n  $$('layout', 'concentric', ConcentricLayout);\n  \n})( cytoscape );\n\n/*\n  The CoSE layout was written by Gerardo Huck.\n\n  Modifications tracked on Github.\n*/\n\n;(function($$) { 'use strict';\n\n  var DEBUG;\n\n  /**\n   * @brief :  default layout options\n   */\n  var defaults = {\n    // Called on `layoutready`\n    ready               : function() {},\n\n    // Called on `layoutstop`\n    stop                : function() {},\n\n    // Whether to animate while running the layout\n    animate             : true,\n\n    // Number of iterations between consecutive screen positions update (0 -> only updated on the end)\n    refresh             : 4,\n    \n    // Whether to fit the network view after when done\n    fit                 : true, \n\n    // Padding on fit\n    padding             : 30, \n\n    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    boundingBox         : undefined,\n\n    // Whether to randomize node positions on the beginning\n    randomize           : true,\n    \n    // Whether to use the JS console to print debug messages\n    debug               : false,\n\n    // Node repulsion (non overlapping) multiplier\n    nodeRepulsion       : 400000,\n    \n    // Node repulsion (overlapping) multiplier\n    nodeOverlap         : 10,\n    \n    // Ideal edge (non nested) length\n    idealEdgeLength     : 10,\n    \n    // Divisor to compute edge forces\n    edgeElasticity      : 100,\n    \n    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n    nestingFactor       : 5, \n    \n    // Gravity force (constant)\n    gravity             : 250, \n    \n    // Maximum number of iterations to perform\n    numIter             : 100,\n    \n    // Initial temperature (maximum node displacement)\n    initialTemp         : 200,\n    \n    // Cooling factor (how the temperature is reduced between consecutive iterations\n    coolingFactor       : 0.95, \n    \n    // Lower temperature threshold (below this point the layout will end)\n    minTemp             : 1.0\n  };\n\n\n  /**\n   * @brief       : constructor\n   * @arg options : object containing layout options\n   */\n  function CoseLayout(options) {\n    this.options = $$.util.extend({}, defaults, options); \n  }\n\n\n  /**\n   * @brief : runs the layout\n   */\n  CoseLayout.prototype.run = function() {\n    var options = this.options;\n    var cy      = options.cy;\n    var layout  = this;\n\n    layout.stopped = false;\n\n    layout.trigger({ type: 'layoutstart', layout: layout });\n\n    // Set DEBUG - Global variable\n    if (true === options.debug) {\n      DEBUG = true;\n    } else {\n      DEBUG = false;\n    }\n\n    // Get start time\n    var startTime = new Date();\n\n    // Initialize layout info\n    var layoutInfo = createLayoutInfo(cy, layout, options);\n    \n    // Show LayoutInfo contents if debugging\n    if (DEBUG) {\n      printLayoutInfo(layoutInfo);\n    }\n\n    // If required, randomize node positions\n    if (true === options.randomize) {\n      randomizePositions(layoutInfo, cy);\n    }\n\n    updatePositions(layoutInfo, cy, options);\n\n    var mainLoop = function(i){\n      if( layout.stopped ){\n        logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n        return false;\n      }\n\n      // Do one step in the phisical simulation\n      step(layoutInfo, cy, options, i);\n      \n      // Update temperature\n      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n      logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n      if (layoutInfo.temperature < options.minTemp) {\n        logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n        return false;\n      }\n\n      return true;\n    };\n\n    var done = function(){\n      refreshPositions(layoutInfo, cy, options);\n\n      // Fit the graph if necessary\n      if (true === options.fit) {\n        cy.fit( options.padding );\n      }\n      \n      // Get end time\n      var endTime = new Date();\n\n      console.info('Layout took ' + (endTime - startTime) + ' ms');\n\n      // Layout has finished\n      layout.one('layoutstop', options.stop);\n      layout.trigger({ type: 'layoutstop', layout: layout });\n    };\n\n    if( options.animate ){\n      var i = 0;\n      var frame = function(){\n\n        var f = 0;\n        var loopRet;\n        while( f < options.refresh && i < options.numIter ){\n          var loopRet = mainLoop(i);\n          if( loopRet === false ){ break; }\n\n          f++;\n          i++;\n        }\n\n        refreshPositions(layoutInfo, cy, options);\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n\n        if ( loopRet !== false && i + 1 < options.numIter ) {\n          $$.util.requestAnimationFrame( frame );\n        } else {\n          done();\n        }\n      };\n\n      $$.util.requestAnimationFrame( frame );\n    } else {\n      for (var i = 0; i < options.numIter; i++) {\n        if( mainLoop(i) === false ){ break; }\n      }\n\n      done();\n    }\n   \n    return this; // chaining\n  };\n\n\n  /**\n   * @brief : called on continuous layouts to stop them before they finish\n   */\n  CoseLayout.prototype.stop = function(){\n    this.stopped = true;\n\n    return this; // chaining\n  };\n\n\n  /**\n   * @brief     : Creates an object which is contains all the data\n   *              used in the layout process\n   * @arg cy    : cytoscape.js object\n   * @return    : layoutInfo object initialized\n   */\n  var createLayoutInfo = function(cy, layout, options) {\n    // Shortcut\n    var edges = options.eles.edges();\n    var nodes = options.eles.nodes();\n\n    var layoutInfo   = {\n      layout       : layout,\n      layoutNodes  : [], \n      idToIndex    : {},\n      nodeSize     : nodes.size(),\n      graphSet     : [],\n      indexToGraph : [], \n      layoutEdges  : [],\n      edgeSize     : edges.size(),\n      temperature  : options.initialTemp,\n      clientWidth  : cy.width(),\n      clientHeight : cy.width(),\n      boundingBox  : $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n                       x1: 0, y1: 0, w: cy.width(), h: cy.height()\n                     } )\n    }; \n    \n    // Iterate over all nodes, creating layout nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var tempNode        = {};\n      tempNode.id         = nodes[i].data('id');\n      tempNode.parentId   = nodes[i].data('parent');      \n      tempNode.children   = [];\n      tempNode.positionX  = nodes[i].position('x');\n      tempNode.positionY  = nodes[i].position('y');\n      tempNode.offsetX    = 0;      \n      tempNode.offsetY    = 0;\n      tempNode.height     = nodes[i].height();\n      tempNode.width      = nodes[i].width();\n      tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;\n      tempNode.minX       = tempNode.positionX - tempNode.width  / 2;\n      tempNode.maxY       = tempNode.positionY + tempNode.height / 2;\n      tempNode.minY       = tempNode.positionY - tempNode.height / 2;\n      tempNode.padLeft    = nodes[i]._private.style['padding-left'].pxValue;\n      tempNode.padRight   = nodes[i]._private.style['padding-right'].pxValue;\n      tempNode.padTop     = nodes[i]._private.style['padding-top'].pxValue;\n      tempNode.padBottom  = nodes[i]._private.style['padding-bottom'].pxValue;\n      \n      // Add new node\n      layoutInfo.layoutNodes.push(tempNode);\n      // Add entry to id-index map\n      layoutInfo.idToIndex[tempNode.id] = i;\n    }\n\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0;   // Points to the start the queue\n    var end   = -1;  // Points to the end of the queue\n\n    var tempGraph = [];\n\n    // Second pass to add child information and \n    // initialize queue for hierarchical traversal\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      var p_id = n.parentId;\n      // Check if node n has a parent node\n      if (null != p_id) {\n      // Add node Id to parent's list of children\n      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n      } else {\n      // If a node doesn't have a parent, then it's in the root graph\n      queue[++end] = n.id;\n      tempGraph.push(n.id);    \n      }\n    }\n    \n    // Add root graph to graphSet\n    layoutInfo.graphSet.push(tempGraph);\n\n    // Traverse the graph, level by level, \n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var node_id  = queue[start++];\n      var node_ix  = layoutInfo.idToIndex[node_id];\n      var node     = layoutInfo.layoutNodes[node_ix];\n      var children = node.children;\n      if (children.length > 0) {\n      // Add children nodes as a new graph to graph set\n      layoutInfo.graphSet.push(children);\n      // Add children to que queue to be visited\n      for (var i = 0; i < children.length; i++) {\n        queue[++end] = children[i];\n      }\n      }\n    }\n\n    // Create indexToGraph map\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {      \n      var graph = layoutInfo.graphSet[i];\n      for (var j = 0; j < graph.length; j++) {\n      var index = layoutInfo.idToIndex[graph[j]];\n      layoutInfo.indexToGraph[index] = i;\n      }\n    }\n    \n    // Iterate over all edges, creating Layout Edges\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      var e = edges[i];\n      var tempEdge = {};      \n      tempEdge.id       = e.data('id');\n      tempEdge.sourceId = e.data('source');\n      tempEdge.targetId = e.data('target');\n\n      // Compute ideal length\n      var idealLength = options.idealEdgeLength;\n\n      // Check if it's an inter graph edge\n      var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];\n      var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];\n      var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n      var targetGraph = layoutInfo.indexToGraph[targetIx];\n\n      if (sourceGraph != targetGraph) {\n      // Find lowest common graph ancestor\n      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n\n      // Compute sum of node depths, relative to lca graph\n      var lcaGraph = layoutInfo.graphSet[lca];\n      var depth    = 0;\n\n      // Source depth\n      var tempNode = layoutInfo.layoutNodes[sourceIx];\n      while (-1 === $.inArray(tempNode.id, lcaGraph)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      // Target depth\n      tempNode = layoutInfo.layoutNodes[targetIx];\n      while (-1 === $.inArray(tempNode.id, lcaGraph)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +  \n         \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() + \n         \". Depth: \" + depth);\n\n      // Update idealLength\n      idealLength *= depth * options.nestingFactor;\n      }\n\n      tempEdge.idealLength = idealLength;\n\n      layoutInfo.layoutEdges.push(tempEdge);\n    }\n\n    // Finally, return layoutInfo object\n    return layoutInfo;\n  };\n\n  \n  /**\n   * @brief : This function finds the index of the lowest common \n   *          graph ancestor between 2 nodes in the subtree \n   *          (from the graph hierarchy induced tree) whose\n   *          root is graphIx\n   *\n   * @arg node1: node1's ID\n   * @arg node2: node2's ID\n   * @arg layoutInfo: layoutInfo object\n   *\n   */\n  var findLCA = function(node1, node2, layoutInfo) {\n    // Find their common ancester, starting from the root graph\n    var res = findLCA_aux(node1, node2, 0, layoutInfo);\n    if (2 > res.count) {\n      // If aux function couldn't find the common ancester, \n      // then it is the root graph\n      return 0;\n    } else {\n      return res.graph;\n    }\n  };\n\n\n  /**\n   * @brief          : Auxiliary function used for LCA computation\n   * \n   * @arg node1      : node1's ID\n   * @arg node2      : node2's ID\n   * @arg graphIx    : subgraph index\n   * @arg layoutInfo : layoutInfo object\n   *\n   * @return         : object of the form {count: X, graph: Y}, where:\n   *                   X is the number of ancesters (max: 2) found in \n   *                   graphIx (and it's subgraphs),\n   *                   Y is the graph index of the lowest graph containing \n   *                   all X nodes\n   */\n  var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {\n    var graph = layoutInfo.graphSet[graphIx];\n    // If both nodes belongs to graphIx\n    if (-1 < $.inArray(node1, graph) && -1 < $.inArray(node2, graph)) {\n      return {count:2, graph:graphIx};\n    }\n\n    // Make recursive calls for all subgraphs\n    var c = 0;\n    for (var i = 0; i < graph.length; i++) {\n      var nodeId   = graph[i];\n      var nodeIx   = layoutInfo.idToIndex[nodeId];\n      var children = layoutInfo.layoutNodes[nodeIx].children;\n\n      // If the node has no child, skip it\n      if (0 === children.length) {\n      continue;\n      }\n\n      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n      if (0 === result.count) {\n      // Neither node1 nor node2 are present in this subgraph\n      continue;\n      } else if (1 === result.count) {\n      // One of (node1, node2) is present in this subgraph\n      c++;\n      if (2 === c) {\n        // We've already found both nodes, no need to keep searching\n        break;\n      }\n      } else {\n      // Both nodes are present in this subgraph\n      return result;\n      }      \n    }\n    \n    return {count:c, graph:graphIx};\n  };\n\n\n  /**\n   * @brief: printsLayoutInfo into js console\n   *         Only used for debbuging \n   */\n  var printLayoutInfo = function(layoutInfo) {\n    if (!DEBUG) {\n      return;\n    }\n    console.debug(\"layoutNodes:\");\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      var s = \n      \"\\nindex: \"     + i + \n      \"\\nId: \"        + n.id + \n      \"\\nChildren: \"  + n.children.toString() +  \n      \"\\nparentId: \"  + n.parentId  + \n      \"\\npositionX: \" + n.positionX + \n      \"\\npositionY: \" + n.positionY +\n      \"\\nOffsetX: \" + n.offsetX + \n      \"\\nOffsetY: \" + n.offsetY + \n      \"\\npadLeft: \" + n.padLeft + \n      \"\\npadRight: \" + n.padRight + \n      \"\\npadTop: \" + n.padTop + \n      \"\\npadBottom: \" + n.padBottom;\n\n      console.debug(s);    \n    }  \n    \n    console.debug('idToIndex');\n    for (var i in layoutInfo.idToIndex) {\n      console.debug(\"Id: \" + i + \"\\nIndex: \" + layoutInfo.idToIndex[i]);\n    }\n\n    console.debug('Graph Set');\n    var set = layoutInfo.graphSet;\n    for (var i = 0; i < set.length; i ++) {\n      console.debug(\"Set : \" + i + \": \" + set[i].toString());\n    } \n\n    var s = 'IndexToGraph';\n    for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {\n      s += \"\\nIndex : \" + i + \" Graph: \"+ layoutInfo.indexToGraph[i];\n    }\n    console.debug(s);\n\n    s = 'Layout Edges';\n    for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {\n      var e = layoutInfo.layoutEdges[i];\n      s += \"\\nEdge Index: \" + i + \" ID: \" + e.id + \n      \" SouceID: \" + e.sourceId + \" TargetId: \" + e.targetId + \n      \" Ideal Length: \" + e.idealLength;\n    }\n    console.debug(s);\n\n    s =  \"nodeSize: \" + layoutInfo.nodeSize;\n    s += \"\\nedgeSize: \" + layoutInfo.edgeSize;\n    s += \"\\ntemperature: \" + layoutInfo.temperature;\n    console.debug(s);\n\n    return;\n  };\n\n\n  /**\n   * @brief : Randomizes the position of all nodes\n   */\n  var randomizePositions = function(layoutInfo, cy) {\n    var width     = layoutInfo.clientWidth;\n    var height    = layoutInfo.clientHeight;\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      // No need to randomize compound nodes\n      if (true) {\n        n.positionX = Math.random() * width;\n        n.positionY = Math.random() * height;\n      }\n    }\n  };\n\n  \n  /**\n   * @brief          : Updates the positions of nodes in the network\n   * @arg layoutInfo : LayoutInfo object\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n  var refreshPositions = function(layoutInfo, cy, options) {  \n    var s = 'Refreshing positions';\n    logDebug(s);\n\n    var layout = layoutInfo.layout;\n    var nodes = options.eles.nodes();\n    var bb = layoutInfo.boundingBox;\n    var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n    \n    if( options.boundingBox ){\n      nodes.forEach(function( node ){\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n\n        coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );\n        coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );\n\n        coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );\n        coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );\n      });\n\n      coseBB.w = coseBB.x2 - coseBB.x1;\n      coseBB.h = coseBB.y2 - coseBB.y1;\n    }\n\n    nodes.positions(function(i, ele) {\n      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n      s = \"Node: \" + lnode.id + \". Refreshed position: (\" + \n      lnode.positionX + \", \" + lnode.positionY + \").\";\n      logDebug(s);\n\n      if( options.boundingBox ){ // then add extra bounding box constraint\n        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n\n        return {\n          x: bb.x1 + pctX * bb.w,\n          y: bb.y1 + pctY * bb.h\n        };\n      } else {\n        return {\n          x: lnode.positionX,\n          y: lnode.positionY\n        };\n      }\n    });\n\n    // Trigger layoutReady only on first call\n    if (true !== layoutInfo.ready) {\n      s = 'Triggering layoutready';\n      logDebug(s);\n      layoutInfo.ready = true;\n      layout.one('layoutready', options.ready);\n      layout.trigger({ type: 'layoutready', layout: this });\n    }\n  };\n\n\n  /**\n   * @brief          : Performs one iteration of the physical simulation\n   * @arg layoutInfo : LayoutInfo object already initialized\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n  var step = function(layoutInfo, cy, options, step) {  \n    var s = \"\\n\\n###############################\";\n    s += \"\\nSTEP: \" + step;\n    s += \"\\n###############################\\n\";\n    logDebug(s);\n\n    // Calculate node repulsions\n    calculateNodeForces(layoutInfo, cy, options);\n    // Calculate edge forces\n    calculateEdgeForces(layoutInfo, cy, options);\n    // Calculate gravity forces\n    calculateGravityForces(layoutInfo, cy, options);\n    // Propagate forces from parent to child\n    propagateForces(layoutInfo, cy, options);\n    // Update positions based on calculated forces\n    updatePositions(layoutInfo, cy, options);\n  };\n\n  \n  /**\n   * @brief : Computes the node repulsion forces\n   */\n  var calculateNodeForces = function(layoutInfo, cy, options) {\n    // Go through each of the graphs in graphSet\n    // Nodes only repel each other if they belong to the same graph\n    var s = 'calculateNodeForces';\n    logDebug(s);\n    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {\n      var graph    = layoutInfo.graphSet[i];\n      var numNodes = graph.length;\n\n      s = \"Set: \" + graph.toString();\n      logDebug(s);\n\n      // Now get all the pairs of nodes \n      // Only get each pair once, (A, B) = (B, A)\n      for (var j = 0; j < numNodes; j++) {\n      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n      for (var k = j + 1; k < numNodes; k++) {\n        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n        nodeRepulsion(node1, node2, layoutInfo, cy, options);\n      } \n      }\n    } \n  };\n\n\n  /**\n   * @brief : Compute the node repulsion forces between a pair of nodes\n   */\n  var nodeRepulsion = function(node1, node2, layoutInfo, cy, options) {\n    var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n\n    // Get direction of line connecting both node centers\n    var directionX = node2.positionX - node1.positionX;\n    var directionY = node2.positionY - node1.positionY;\n    s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n\n    // If both centers are the same, apply a random force\n    if (0 === directionX && 0 === directionY) {\n      s += \"\\nNodes have the same position.\";\n      return; // TODO\n    }\n\n    var overlap = nodesOverlap(node1, node2, directionX, directionY);\n    \n    if (overlap > 0) {\n      s += \"\\nNodes DO overlap.\";\n      s += \"\\nOverlap: \" + overlap;\n      // If nodes overlap, repulsion force is proportional \n      // to the overlap\n      var force    = options.nodeOverlap * overlap;\n\n      // Compute the module and components of the force vector\n      var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n      s += \"\\nDistance: \" + distance;\n      var forceX   = force * directionX / distance;\n      var forceY   = force * directionY / distance;\n\n    } else {\n      s += \"\\nNodes do NOT overlap.\";\n      // If there's no overlap, force is inversely proportional \n      // to squared distance\n\n      // Get clipping points for both nodes\n      var point1 = findClippingPoint(node1, directionX, directionY);\n      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n\n      // Use clipping points to compute distance\n      var distanceX   = point2.x - point1.x;\n      var distanceY   = point2.y - point1.y;\n      var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n      var distance    = Math.sqrt(distanceSqr);\n      s += \"\\nDistance: \" + distance;\n\n      // Compute the module and components of the force vector\n      var force  = options.nodeRepulsion / distanceSqr;\n      var forceX = force * distanceX / distance;\n      var forceY = force * distanceY / distance;\n    }\n\n    // Apply force\n    node1.offsetX -= forceX;\n    node1.offsetY -= forceY;\n    node2.offsetX += forceX;\n    node2.offsetY += forceY;\n\n    s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n    logDebug(s);\n\n    return;\n  };\n\n\n  /**\n   * @brief : Finds the point in which an edge (direction dX, dY) intersects \n   *          the rectangular bounding box of it's source/target node \n   */\n  var findClippingPoint = function(node, dX, dY) {\n\n    // Shorcuts\n    var X = node.positionX;\n    var Y = node.positionY;\n    var H = node.height;\n    var W = node.width;\n    var dirSlope     = dY / dX;\n    var nodeSlope    = H / W;\n\n    var s = 'Computing clipping point of node ' + node.id + \n      \" . Height:  \" + H + \", Width: \" + W + \n      \"\\nDirection \" + dX + \", \" + dY; \n    \n    // Compute intersection\n    var res = {};\n    do {\n      // Case: Vertical direction (up)\n      if (0 === dX && 0 < dY) {\n        res.x = X;\n        s += \"\\nUp direction\";\n        res.y = Y + H / 2;\n        break;\n      }\n\n      // Case: Vertical direction (down)\n      if (0 === dX && 0 > dY) {\n        res.x = X;\n        res.y = Y + H / 2;\n        s += \"\\nDown direction\";\n        break;\n      }      \n\n      // Case: Intersects the right border\n      if (0 < dX && \n      -1 * nodeSlope <= dirSlope && \n      dirSlope <= nodeSlope) {\n        res.x = X + W / 2;\n        res.y = Y + (W * dY / 2 / dX);\n        s += \"\\nRightborder\";\n        break;\n      }\n\n      // Case: Intersects the left border\n      if (0 > dX && \n      -1 * nodeSlope <= dirSlope && \n      dirSlope <= nodeSlope) {\n        res.x = X - W / 2;\n        res.y = Y - (W * dY / 2 / dX);\n        s += \"\\nLeftborder\";\n        break;\n      }\n\n      // Case: Intersects the top border\n      if (0 < dY && \n      ( dirSlope <= -1 * nodeSlope ||\n        dirSlope >= nodeSlope )) {\n        res.x = X + (H * dX / 2 / dY);\n        res.y = Y + H / 2;\n        s += \"\\nTop border\";\n        break;\n      }\n\n      // Case: Intersects the bottom border\n      if (0 > dY && \n      ( dirSlope <= -1 * nodeSlope ||\n        dirSlope >= nodeSlope )) {\n        res.x = X - (H * dX / 2 / dY);\n        res.y = Y - H / 2;\n        s += \"\\nBottom border\";\n        break;\n      }\n\n    } while (false);\n\n    s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n    logDebug(s);\n    return res;\n  };\n\n\n  /**\n   * @brief  : Determines whether two nodes overlap or not\n   * @return : Amount of overlapping (0 => no overlap)\n   */\n  var nodesOverlap = function(node1, node2, dX, dY) {\n\n    if (dX > 0) {\n      var overlapX = node1.maxX - node2.minX;\n    } else {\n      var overlapX = node2.maxX - node1.minX;\n    }\n\n    if (dY > 0) {\n      var overlapY = node1.maxY - node2.minY;\n    } else {\n      var overlapY = node2.maxY - node1.minY;\n    }\n\n    if (overlapX >= 0 && overlapY >= 0) {\n      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n    } else {\n      return 0;\n    }\n  };\n    \n  \n  /**\n   * @brief : Calculates all edge forces\n   */\n  var calculateEdgeForces = function(layoutInfo, cy, options) {\n    // Iterate over all edges\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      // Get edge, source & target nodes\n      var edge     = layoutInfo.layoutEdges[i];\n      var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n      var source   = layoutInfo.layoutNodes[sourceIx];\n      var targetIx = layoutInfo.idToIndex[edge.targetId];\n      var target   = layoutInfo.layoutNodes[targetIx];\n\n      // Get direction of line connecting both node centers\n      var directionX = target.positionX - source.positionX;\n      var directionY = target.positionY - source.positionY;\n      \n      // If both centers are the same, do nothing.\n      // A random force has already been applied as node repulsion\n      if (0 === directionX && 0 === directionY) {\n      return;\n      }\n\n      // Get clipping points for both nodes\n      var point1 = findClippingPoint(source, directionX, directionY);\n      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n\n\n      var lx = point2.x - point1.x;\n      var ly = point2.y - point1.y;\n      var l  = Math.sqrt(lx * lx + ly * ly);\n\n      var force  = Math.pow(edge.idealLength - l, 2) / options.edgeElasticity; \n\n      if (0 !== l) {\n        var forceX = force * lx / l;\n        var forceY = force * ly / l;\n      } else {\n        var forceX = 0;\n        var forceY = 0;\n      }\n\n      // Add this force to target and source nodes\n      source.offsetX += forceX;\n      source.offsetY += forceY;\n      target.offsetX -= forceX;\n      target.offsetY -= forceY;\n\n      var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n      s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n      logDebug(s);\n    }\n  };\n\n\n  /**\n   * @brief : Computes gravity forces for all nodes\n   */\n  var calculateGravityForces = function(layoutInfo, cy, options) {\n    var s = 'calculateGravityForces';\n    logDebug(s);\n    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {\n      var graph    = layoutInfo.graphSet[i];\n      var numNodes = graph.length;\n\n      s = \"Set: \" + graph.toString();\n      logDebug(s);\n          \n      // Compute graph center\n      if (0 === i) {\n        var centerX   = layoutInfo.clientHeight / 2;\n        var centerY   = layoutInfo.clientWidth  / 2;    \n      } else {\n        // Get Parent node for this graph, and use its position as center\n        var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n        var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n        var centerX = parent.positionX;\n        var centerY = parent.positionY;\n      }\n      s = \"Center found at: \" + centerX + \", \" + centerY;\n      logDebug(s);\n\n      // Apply force to all nodes in graph\n      for (var j = 0; j < numNodes; j++) {\n        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n        s = \"Node: \" + node.id;\n        var dx = centerX - node.positionX;\n        var dy = centerY - node.positionY;\n        var d  = Math.sqrt(dx * dx + dy * dy);\n        if (d > 1.0) { // TODO: Use global variable for distance threshold\n          var fx = options.gravity * dx / d;\n          var fy = options.gravity * dy / d;\n          node.offsetX += fx;\n          node.offsetY += fy;\n          s += \": Applied force: \" + fx + \", \" + fy;\n        } else {\n          s += \": skypped since it's too close to center\";\n        }\n        logDebug(s);\n      }\n    }\n  };\n\n\n  /**\n   * @brief          : This function propagates the existing offsets from \n   *                   parent nodes to its descendents.\n   * @arg layoutInfo : layoutInfo Object\n   * @arg cy         : cytoscape Object\n   * @arg options    : Layout options\n   */\n  var propagateForces = function(layoutInfo, cy, options) {  \n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0;   // Points to the start the queue\n    var end   = -1;  // Points to the end of the queue\n\n    logDebug('propagateForces');\n\n    // Start by visiting the nodes in the root graph\n    queue.push.apply(queue, layoutInfo.graphSet[0]);\n    end += layoutInfo.graphSet[0].length;\n\n    // Traverse the graph, level by level, \n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var nodeId    = queue[start++];\n      var nodeIndex = layoutInfo.idToIndex[nodeId];\n      var node      = layoutInfo.layoutNodes[nodeIndex];\n      var children  = node.children;\n\n      // We only need to process the node if it's compound\n      if (0 < children.length) {    \n      var offX = node.offsetX;\n      var offY = node.offsetY;\n\n      var s = \"Propagating offset from parent node : \" + node.id + \n        \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n      s += \"\\n Children: \" + children.toString();\n      logDebug(s);\n      \n      for (var i = 0; i < children.length; i++) {\n        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n        // Propagate offset\n        childNode.offsetX += offX;\n        childNode.offsetY += offY;\n        // Add children to queue to be visited\n        queue[++end] = children[i];\n      }\n      \n      // Reset parent offsets\n      node.offsetX = 0;\n      node.offsetY = 0;\n      }\n      \n    }\n  };\n\n\n  /**\n   * @brief : Updates the layout model positions, based on \n   *          the accumulated forces\n   */\n  var updatePositions = function(layoutInfo, cy, options) {\n    var s = 'Updating positions';\n    logDebug(s);\n\n    // Reset boundaries for compound nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      if (0 < n.children.length) {\n        logDebug(\"Resetting boundaries of compound node: \" + n.id);\n        n.maxX = undefined;\n        n.minX = undefined;\n        n.maxY = undefined;\n        n.minY = undefined;\n      }\n    }\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      if (0 < n.children.length) {\n        // No need to set compound node position\n        logDebug(\"Skipping position update of node: \" + n.id);\n        continue;\n      }\n      s = \"Node: \" + n.id + \" Previous position: (\" + \n      n.positionX + \", \" + n.positionY + \").\"; \n\n      // Limit displacement in order to improve stability\n      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n      n.positionX += tempForce.x; \n      n.positionY += tempForce.y;\n      n.offsetX = 0;\n      n.offsetY = 0;\n      n.minX    = n.positionX - n.width; \n      n.maxX    = n.positionX + n.width; \n      n.minY    = n.positionY - n.height; \n      n.maxY    = n.positionY + n.height; \n      s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n      logDebug(s);\n\n      // Update ancestry boudaries\n      updateAncestryBoundaries(n, layoutInfo);\n    }\n\n    // Update size, position of compund nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      if (0 < n.children.length) {\n        n.positionX = (n.maxX + n.minX) / 2;\n        n.positionY = (n.maxY + n.minY) / 2;\n        n.width     = n.maxX - n.minX;\n        n.height    = n.maxY - n.minY;\n        s = \"Updating position, size of compound node \" + n.id;\n        s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n        s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n        logDebug(s);\n      }\n    }  \n  };\n\n\n  /**\n   * @brief : Limits a force (forceX, forceY) to be not \n   *          greater (in modulo) than max. \n   8          Preserves force direction. \n   */\n  var limitForce = function(forceX, forceY, max) {\n    var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n    var force = Math.sqrt(forceX * forceX + forceY * forceY);\n\n    if (force > max) {\n      var res = {\n      x : max * forceX / force,\n      y : max * forceY / force\n      };      \n\n    } else {\n      var res = {\n      x : forceX,\n      y : forceY\n      };\n    }\n\n    s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n    logDebug(s);\n\n    return res;\n  };\n\n\n  /**\n   * @brief : Function used for keeping track of compound node \n   *          sizes, since they should bound all their subnodes.\n   */\n  var updateAncestryBoundaries = function(node, layoutInfo) {\n    var s = \"Propagating new position/size of node \" + node.id;\n    var parentId = node.parentId;\n    if (null == parentId) {\n      // If there's no parent, we are done\n      s += \". No parent node.\";\n      logDebug(s);\n      return;\n    }\n\n    // Get Parent Node\n    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n    var flag = false;\n\n    // MaxX\n    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n      p.maxX = node.maxX + p.padRight;\n      flag = true;\n      s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n    }\n\n    // MinX\n    if (null == p.minX || node.minX - p.padLeft < p.minX) {\n      p.minX = node.minX - p.padLeft;\n      flag = true;\n      s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n    }\n\n    // MaxY\n    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n      p.maxY = node.maxY + p.padBottom;\n      flag = true;\n      s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n    }\n\n    // MinY\n    if (null == p.minY || node.minY - p.padTop < p.minY) {\n      p.minY = node.minY - p.padTop;\n      flag = true;\n      s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n    }\n\n    // If updated boundaries, propagate changes upward\n    if (flag) {\n      logDebug(s);\n      return updateAncestryBoundaries(p, layoutInfo);\n    } \n\n    s += \". No changes in boundaries/position of parent node \" + p.id;  \n    logDebug(s);\n    return;\n  };\n\n\n  /**\n   * @brief : Logs a debug message in JS console, if DEBUG is ON\n   */\n  var logDebug = function(text) {\n    if (DEBUG) {\n      console.debug(text);\n    }\n  };\n\n\n  // register the layout\n  $$('layout', 'cose', CoseLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n\n  // default layout options\n  var defaults = {\n    // dagre algo options, uses default value on undefined\n    nodeSep: undefined, // the separation between adjacent nodes in the same rank\n    edgeSep: undefined, // the separation between adjacent edges in the same rank\n    rankSep: undefined, // the separation between adjacent nodes in the same rank\n    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right\n    minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge\n    \n    // general layout options\n    fit: true, // whether to fit to viewport\n    padding: 30, // fit padding\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    ready: function(){}, // on layoutready\n    stop: function(){} // on layoutstop\n  };\n\n  // constructor\n  // options : object containing layout options\n  function DagreLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options); \n  }\n\n  // runs the layout\n  DagreLayout.prototype.run = function(){\n    var options = this.options;\n    var layout = this;\n\n    $$.util.require('dagre', function(dagre){\n\n      var cy = options.cy; // cy is automatically populated for us in the constructor\n      var eles = options.eles;\n\n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n\n      var g = new dagre.Digraph();\n\n      // add nodes to dagre\n      var nodes = eles.nodes().not(':parent');\n      for( var i = 0; i < nodes.length; i++ ){\n        var node = nodes[i];\n\n        g.addNode( node.id(), {\n          width: node.width(),\n          height: node.height()\n        } );\n      }\n\n      // add edges to dagre\n      var edges = eles.edges();\n      for( var i = 0; i < edges.length; i++ ){\n        var edge = edges[i];\n\n        g.addEdge( edge.id(), edge.source().id(), edge.target().id(), {\n          minLen: $$.is.fn(options.minLen) ? options.minLen.apply( edge, [ edge ] ) : options.minLen\n        } );\n      }\n\n      var d = dagre.layout();\n\n      if( options.nodeSep ){\n        d.nodeSep( options.nodeSep );\n      }\n\n      if( options.edgeSep ){\n        d.edgeSep( options.edgeSep );\n      }\n      \n      if( options.rankSep ){\n        d.rankSep( options.rankSep );\n      }\n\n      if( options.rankDir ){\n        d.rankDir( options.rankDir );\n      }\n        \n      d = d.run(g);\n\n      d.eachNode(function(id, n) {\n        cy.getElementById(id).scratch().dagre = n;\n      });\n\n      var dagreBB;\n\n      if( options.boundingBox ){\n        dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n        nodes.forEach(function( node ){\n          var dModel = node.scratch().dagre;\n\n          dagreBB.x1 = Math.min( dagreBB.x1, dModel.x );\n          dagreBB.x2 = Math.max( dagreBB.x2, dModel.x );\n\n          dagreBB.y1 = Math.min( dagreBB.y1, dModel.y );\n          dagreBB.y2 = Math.max( dagreBB.y2, dModel.y );\n        });\n\n        dagreBB.w = dagreBB.x2 - dagreBB.x1;\n        dagreBB.h = dagreBB.y2 - dagreBB.y1;\n      } else {\n        dagreBB = bb;\n      }\n\n      var constrainPos = function( p ){\n        if( options.boundingBox ){\n          var xPct = (p.x - dagreBB.x1) / dagreBB.w;\n          var yPct = (p.y - dagreBB.y1) / dagreBB.h;\n\n          return {\n            x: bb.x1 + xPct * bb.w,\n            y: bb.y1 + yPct * bb.h\n          };\n        } else {\n          return p;\n        }\n      };\n\n      nodes.layoutPositions(layout, options, function(){\n        var dModel = this.scratch().dagre;\n\n        return constrainPos({\n          x: dModel.x,\n          y: dModel.y\n        });\n      });\n\n    }); // require\n\n    return this; // chaining\n  };\n\n  // register the layout\n  $$('layout', 'dagre', DagreLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // padding used on fit\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n    rows: undefined, // force num of rows in the grid\n    columns: undefined, // force num of cols in the grid\n    position: function( node ){}, // returns { row, col } for element\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function GridLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  GridLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    if( bb.h === 0 || bb.w === 0){\n      nodes.layoutPositions(this, options, function(){\n        return { x: bb.x1, y: bb.y1 };\n      });\n      \n    } else {\n      \n      // width/height * splits^2 = cells where splits is number of times to split width\n      var cells = nodes.size();\n      var splits = Math.sqrt( cells * bb.h/bb.w );\n      var rows = Math.round( splits );\n      var cols = Math.round( bb.w/bb.h * splits );\n\n      var small = function(val){\n        if( val == null ){\n          return Math.min(rows, cols);\n        } else {\n          var min = Math.min(rows, cols);\n          if( min == rows ){\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n      \n      var large = function(val){\n        if( val == null ){\n          return Math.max(rows, cols);\n        } else {\n          var max = Math.max(rows, cols);\n          if( max == rows ){\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n      \n      // if rows or columns were set in options, use those values\n      if( options.rows != null && options.columns != null ){\n        rows = options.rows;\n        cols = options.columns;\n      } else if( options.rows != null && options.columns == null ){\n        rows = options.rows;\n        cols = Math.ceil( cells / rows );\n      } else if( options.rows == null && options.columns != null ){\n        cols = options.columns;\n        rows = Math.ceil( cells / cols );\n      }\n      \n      // otherwise use the automatic values and adjust accordingly\n      \n      // if rounding was up, see if we can reduce rows or columns\n      else if( cols * rows > cells ){\n        var sm = small();\n        var lg = large();\n        \n        // reducing the small side takes away the most cells, so try it first\n        if( (sm - 1) * lg >= cells ){\n          small(sm - 1);\n        } else if( (lg - 1) * sm >= cells ){\n          large(lg - 1);\n        } \n      } else {\n        \n        // if rounding was too low, add rows or columns\n        while( cols * rows < cells ){\n          var sm = small();\n          var lg = large();\n          \n          // try to add to larger side first (adds less in multiplication)\n          if( (lg + 1) * sm >= cells ){\n            large(lg + 1);\n          } else {\n            small(sm + 1);\n          }\n        }\n      }\n      \n      var cellWidth = bb.w / cols;\n      var cellHeight = bb.h / rows;\n\n      if( options.avoidOverlap ){\n        for( var i = 0; i < nodes.length; i++ ){\n          var node = nodes[i];\n          var w = node.outerWidth();\n          var h = node.outerHeight();\n\n          cellWidth = Math.max( cellWidth, w );\n          cellHeight = Math.max( cellHeight, h );\n        }\n      }\n      \n      var cellUsed = {}; // e.g. 'c-0-2' => true\n      \n      var used = function(row, col){\n        return cellUsed['c-' + row + '-' + col] ? true : false;\n      };\n      \n      var use = function(row, col){\n        cellUsed['c-' + row + '-' + col] = true;\n      };\n\n      // to keep track of current cell position\n      var row = 0;\n      var col = 0;\n      var moveToNextCell = function(){\n        col++;\n        if( col >= cols ){\n          col = 0;\n          row++;\n        }\n      };\n\n      // get a cache of all the manual positions\n      var id2manPos = {};\n      for( var i = 0; i < nodes.length; i++ ){\n        var node = nodes[i];\n        var rcPos = options.position( node );\n\n        if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd\n          var pos = {\n            row: rcPos.row,\n            col: rcPos.col\n          };\n\n          if( pos.col === undefined ){ // find unused col\n            pos.col = 0;\n\n            while( used(pos.row, pos.col) ){\n              pos.col++;\n            }\n          } else if( pos.row === undefined ){ // find unused row\n            pos.row = 0;\n\n            while( used(pos.row, pos.col) ){\n              pos.row++;\n            }\n          }\n\n          id2manPos[ node.id() ] = pos;\n          use( pos.row, pos.col );\n        }\n      }\n\n      var getPos = function(i, element){\n        var x, y;\n\n        if( element.locked() || element.isFullAutoParent() ){\n          return false;\n        }\n\n        // see if we have a manual position set\n        var rcPos = id2manPos[ element.id() ];\n        if( rcPos ){\n          x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;\n          y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;\n        \n        } else { // otherwise set automatically\n        \n          while( used(row, col) ){\n            moveToNextCell();\n          }\n\n          x = col * cellWidth + cellWidth/2 + bb.x1;\n          y = row * cellHeight + cellHeight/2 + bb.y1;\n          use( row, col );\n          \n          moveToNextCell();\n        }\n        \n        return { x: x, y: y };\n        \n      };\n\n      nodes.layoutPositions( this, options, getPos );\n    }\n\n    return this; // chaining\n    \n  };\n  \n  $$('layout', 'grid', GridLayout);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // default layout options\n  var defaults = {\n    ready: function(){}, // on layoutready\n    stop: function(){} // on layoutstop\n  };\n\n  // constructor\n  // options : object containing layout options\n  function NullLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options); \n  }\n\n  // runs the layout\n  NullLayout.prototype.run = function(){\n    var options = this.options;\n    var eles = options.eles; // elements to consider in the layout\n    var layout = this;\n\n    // cy is automatically populated for us in the constructor\n    var cy = options.cy; // jshint ignore:line\n\n    layout.trigger('layoutstart');\n\n    // puts all nodes at (0, 0)\n    eles.nodes().positions(function(){\n      return {\n        x: 0,\n        y: 0\n      };\n    });\n\n    // trigger layoutready when each node has had its position set at least once\n    layout.one('layoutready', options.ready);\n    layout.trigger('layoutready');\n\n    // trigger layoutstop when the layout stops (e.g. finishes)\n    layout.one('layoutstop', options.stop);\n    layout.trigger('layoutstop');\n\n    return this; // chaining\n  };\n\n  // called on continuous layouts to stop them before they finish\n  NullLayout.prototype.stop = function(){\n    return this; // chaining\n  };\n\n  // register the layout\n  $$('layout', 'null', NullLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }\n    zoom: undefined, // the zoom level to set (prob want fit = false if set)\n    pan: undefined, // the pan level to set (prob want fit = false if set)\n    fit: true, // whether to fit to viewport\n    padding: 30, // padding on fit\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function PresetLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options);\n  }\n  \n  PresetLayout.prototype.run = function(){\n    var options = this.options;\n    var eles = options.eles;\n\n    var nodes = eles.nodes();\n    var posIsFn = $$.is.fn( options.positions );\n\n    function getPosition(node){\n      if( options.positions == null ){\n        return null;\n      }\n\n      if( posIsFn ){\n        return options.positions.apply( node, [ node ] );\n      }\n      \n      var pos = options.positions[node._private.data.id];\n\n      if( pos == null ){\n        return null;\n      }\n      \n      return pos;\n    }\n    \n    nodes.layoutPositions(this, options, function(i, node){\n      var position = getPosition(node);\n      \n      if( node.locked() || position == null ){\n        return false;\n      }\n      \n      return position;\n    });\n        \n    return this; // chaining\n  };\n  \n  $$('layout', 'preset', PresetLayout);\n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit to viewport\n    padding: 30, // fit padding\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function RandomLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options);\n  }\n  \n  RandomLayout.prototype.run = function(){\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var getPos = function( i, node ){\n      return {\n        x: bb.x1 + Math.round( Math.random() * bb.w ),\n        y: bb.y1 + Math.round( Math.random() * bb.h )\n      };\n    };\n\n    nodes.layoutPositions( this, options, getPos );\n\n    return this; // chaining\n  };\n  \n  // register the layout\n  $$(\n    'layout', // we're registering a layout\n    'random', // the layout name\n    RandomLayout // the layout prototype\n  );\n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    animate: true, // whether to show the layout as it's running\n    maxSimulationTime: 4000, // max length in ms to run the layout\n    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // padding on fit\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    random: false, // whether to use random initial positions\n    infinite: false, // overrides all other options for a forces-all-the-time mode\n    ready: undefined, // callback on layoutready\n    stop: undefined, // callback on layoutstop\n\n    // springy forces\n    stiffness: 400,\n    repulsion: 400,\n    damping: 0.5\n  };\n\n  function SpringyLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options);\n  }\n  \n  SpringyLayout.prototype.run = function(){\n    var layout = this;\n    var self = this;\n    var options = this.options;\n\n    $$.util.require('Springy', function(Springy){\n\n      var simUpdatingPos = false;\n\n      var cy = options.cy;\n      layout.trigger({ type: 'layoutstart', layout: layout });\n      \n      var eles = options.eles;\n      var nodes = eles.nodes().not(':parent');\n      var edges = eles.edges();\n   \n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n      \n      // make a new graph\n      var graph = new Springy.Graph();\n\n      // make some nodes\n      nodes.each(function(i, node){\n        node.scratch('springy', {\n          model: graph.newNode({\n            element: node\n          })\n        });\n      });\n\n      // connect them with edges\n      edges.each(function(i, edge){\n        var fdSrc = edge.source().scratch('springy').model;\n        var fdTgt = edge.target().scratch('springy').model;\n        \n        edge.scratch('springy', {\n          model: graph.newEdge(fdSrc, fdTgt, {\n            element: edge\n          })\n        });\n      });\n      \n      var sim = window.sim = new Springy.Layout.ForceDirected(graph, options.stiffness, options.repulsion, options.damping);\n\n      if( options.infinite ){\n        sim.minEnergyThreshold = -Infinity;\n      }\n\n      var currentBB = sim.getBoundingBox();\n      // var targetBB = {bottomleft: new Springy.Vector(-2, -2), topright: new Springy.Vector(2, 2)};\n      \n      // convert to/from screen coordinates\n      var toScreen = function(p) {\n        currentBB = sim.getBoundingBox();\n\n        var size = currentBB.topright.subtract(currentBB.bottomleft);\n        var sx = p.subtract(currentBB.bottomleft).divide(size.x).x * bb.w + bb.x1;\n        var sy = p.subtract(currentBB.bottomleft).divide(size.y).y * bb.h + bb.x1;\n\n        return new Springy.Vector(sx, sy);\n      };\n\n      var fromScreen = function(s) {\n        currentBB = sim.getBoundingBox();\n\n        var size = currentBB.topright.subtract(currentBB.bottomleft);\n        var px = ((s.x - bb.x1) / bb.w) * size.x + currentBB.bottomleft.x;\n        var py = ((s.y - bb.y1) / bb.h) * size.y + currentBB.bottomleft.y;\n\n        return new Springy.Vector(px, py);\n      };\n      \n      var movedNodes = cy.collection();\n      \n      var numNodes = cy.nodes().size();\n      var drawnNodes = 1;\n      var fdRenderer = new Springy.Renderer(sim,\n        function clear() {\n          if( movedNodes.length > 0 && options.animate ){\n            simUpdatingPos = true;\n\n            movedNodes.rtrigger('position');\n\n            if( options.fit ){\n              cy.fit( options.padding );\n            }\n\n            movedNodes = cy.collection();\n\n            simUpdatingPos = false;\n          }\n        },\n\n        function drawEdge(edge, p1, p2) {\n          // draw an edge\n        },\n\n        function drawNode(node, p) {\n          var v = toScreen(p);\n          var element = node.data.element;\n          \n          if( !element.locked() && !element.grabbed() ){\n              element._private.position = {\n                x: v.x,\n                y: v.y\n              };\n              movedNodes.merge(element);\n          } else {\n            //setLayoutPositionForElement(element);\n          }\n          \n          if( drawnNodes == numNodes ){\n            layout.one('layoutready', options.ready);\n            layout.trigger({ type: 'layoutready', layout: layout });\n          } \n          \n          drawnNodes++;\n        \n        }\n      );\n      \n      // set initial node points\n      nodes.each(function(i, ele){\n        if( !options.random ){\n          setLayoutPositionForElement(ele);\n        }\n      });\n      \n      // update node positions when dragging\n      var dragHandler;\n      nodes.on('position', dragHandler = function(){\n        if( simUpdatingPos ){ return; }\n\n        setLayoutPositionForElement(this);\n      });\n      \n      function setLayoutPositionForElement(element){\n        var fdId = element.scratch('springy').model.id;\n        var fdP = fdRenderer.layout.nodePoints[fdId].p;\n        var pos = element.position();\n        var positionInFd = (pos.x != null && pos.y != null) ? fromScreen(element.position()) : {\n          x: Math.random() * 4 - 2,\n          y: Math.random() * 4 - 2\n        };\n        \n        fdP.x = positionInFd.x;\n        fdP.y = positionInFd.y;\n      }\n      \n      var grabbableNodes = nodes.filter(\":grabbable\");\n      \n      function start(){\n        // disable grabbing if so set\n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.ungrabify();\n        }\n        \n        fdRenderer.start();\n      }\n      \n      self.stopSystem = function(){\n        graph.filterNodes(function(){\n          return false; // remove all nodes\n        });\n        \n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.grabify();\n        }\n\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n        \n        nodes.off('drag position', dragHandler);\n\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n\n        self.stopSystem = null;\n      };\n      \n      start();\n      if( !options.infinite ){\n        setTimeout(function(){\n          self.stop();\n        }, options.maxSimulationTime);\n      }\n\n    }); // require\n\n    return this; // chaining\n  };\n\n  SpringyLayout.prototype.stop = function(){\n    if( this.stopSystem != null ){\n      this.stopSystem();\n    }\n\n    return this; // chaining\n  };\n  \n  $$('layout', 'springy', SpringyLayout);\n\n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n    \n  function NullRenderer(options){\n    this.options = options;\n  }\n  \n  NullRenderer.prototype.recalculateRenderedStyle = function(){\n  };\n\n  NullRenderer.prototype.notify = function(){\n    // the null renderer does nothing\n  };\n  \n  $$('renderer', 'null', NullRenderer);\n  \n})( cytoscape );\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/cytoscape/dist/cytoscape.js\n ** module id = 4\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///../~/cytoscape/dist/cytoscape.js?")
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 5\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * This file is part of Cytoscape.js 2.3.8.\n * \n * Cytoscape.js is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n * \n * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n * \n * You should have received a copy of the GNU Lesser General Public License along with\n * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.\n */\nvar cytoscape;!function(e){"use strict";var t=cytoscape=function(){return cytoscape.init.apply(cytoscape,arguments)};t.version="2.3.8",t.init=function(e){return void 0===e&&(e={}),t.is.plainObject(e)?new t.Core(e):t.is.string(e)?t.extension.apply(t.extension,arguments):void 0},t.fn={},"undefined"!=typeof module&&module.exports&&(module.exports=cytoscape),"undefined"!="function"&&__webpack_require__(5)&&!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return cytoscape}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)),e&&(e.cytoscape=cytoscape)}("undefined"==typeof window?null:window),function(e,t){"use strict";e.is={defined:function(e){return null!=e},string:function(e){return null!=e&&"string"==typeof e},fn:function(e){return null!=e&&"function"==typeof e},array:function(e){return Array.isArray?Array.isArray(e):null!=e&&e instanceof Array},plainObject:function(t){return null!=t&&typeof t==typeof{}&&!e.is.array(t)&&t.constructor===Object},number:function(e){return null!=e&&"number"==typeof e&&!isNaN(e)},integer:function(t){return e.is.number(t)&&Math.floor(t)===t},color:function(e){return null!=e&&"string"==typeof e&&""!==$.Color(e).toString()},bool:function(e){return null!=e&&typeof e==typeof!0},elementOrCollection:function(t){return e.is.element(t)||e.is.collection(t)},element:function(t){return t instanceof e.Element&&t._private.single},collection:function(t){return t instanceof e.Collection&&!t._private.single},core:function(t){return t instanceof e.Core},style:function(t){return t instanceof e.Style},stylesheet:function(t){return t instanceof e.Stylesheet},event:function(t){return t instanceof e.Event},emptyString:function(t){return t?e.is.string(t)&&(""===t||t.match(/^\\s+$/))?!0:!1:!0},nonemptyString:function(t){return t&&e.is.string(t)&&""!==t&&!t.match(/^\\s+$/)?!0:!1},domElement:function(e){return"undefined"==typeof HTMLElement?!1:e instanceof HTMLElement},boundingBox:function(t){return e.is.plainObject(t)&&e.is.number(t.x1)&&e.is.number(t.x2)&&e.is.number(t.y1)&&e.is.number(t.y2)},touch:function(){return t&&("ontouchstart"in t||t.DocumentTouch&&document instanceof DocumentTouch)},gecko:function(){return"undefined"!=typeof InstallTrigger||"MozAppearance"in document.documentElement.style},webkit:function(){return"undefined"!=typeof webkitURL||"WebkitAppearance"in document.documentElement.style},chromium:function(){return"undefined"!=typeof chrome},khtml:function(){return navigator.vendor.match(/kde/i)},khtmlEtc:function(){return e.is.khtml()||e.is.webkit()||e.is.blink()},trident:function(){/*@cc_on!@*/\nreturn"undefined"!=typeof ActiveXObject||!1},windows:function(){return"undefined"!=typeof navigator&&navigator.appVersion.match(/Win/i)},mac:function(){return"undefined"!=typeof navigator&&navigator.appVersion.match(/Mac/i)},linux:function(){return"undefined"!=typeof navigator&&navigator.appVersion.match(/Linux/i)},unix:function(){return"undefined"!=typeof navigator&&navigator.appVersion.match(/X11/i)}}}(cytoscape,"undefined"==typeof window?null:window),function(e,t){"use strict";e.util={extend:function(){var t,i,r,n,a,o,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||e.is.fn(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(t=arguments[l]))for(i in t)r=s[i],n=t[i],s!==n&&(c&&n&&(e.is.plainObject(n)||(a=e.is.array(n)))?(a?(a=!1,o=r&&e.is.array(r)?r:[]):o=r&&e.is.plainObject(r)?r:{},s[i]=e.util.extend(c,o,n)):void 0!==n&&(s[i]=n));return s},require:function(i,r,n){var a;n=e.util.extend({msgIfNotFound:!0},n);var o=!1,s=function(e){o=!0,r(e)},l=function(e){t&&(a=t[i]),void 0!==a&&s(a),e&&e()},u=function(){o||c(d)},c=function(e){"undefined"!=typeof module&&module.exports&&__webpack_require__(2)&&(a=__webpack_require__(2)(i)),void 0!==a&&s(a),e&&e()},d=function(){o||p(h)},p=function(e){"undefined"!="function"&&__webpack_require__(5)&&__webpack_require__(2)&&!/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(2)(i)]; (function(t){a=t,void 0!==a&&s(a),e&&e()}.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}())},h=function(){!o&&n.msgIfNotFound&&e.util.error("Cytoscape.js tried to pull in dependency `"+i+"` but no module (i.e. CommonJS, AMD, or window) was found")};l(u)},requires:function(t,i){for(var r=[],n=[],a=function(){for(var e=0;e<t.length;e++)if(!n[e])return;i.apply(i,r)},o=0;o<t.length;o++)!function(){var i=t[o],s=o;e.util.require(i,function(e){r[s]=e,n[s]=!0,a()})}()},throttle:function(t,i,r){var n=!0,a=!0;return r===!1?n=!1:e.is.plainObject(r)&&(n="leading"in r?r.leading:n,a="trailing"in r?r.trailing:a),r=r||{},r.leading=n,r.maxWait=i,r.trailing=a,e.util.debounce(t,i,r)},now:function(){return+new Date},debounce:function(t,i,r){var n,a,o,s,l,u,c,d=0,p=!1,h=!0;if(e.is.fn(t)){if(i=Math.max(0,i)||0,r===!0){var v=!0;h=!1}else e.is.plainObject(r)&&(v=r.leading,p="maxWait"in r&&(Math.max(i,r.maxWait)||0),h="trailing"in r?r.trailing:h);var g=function(){var r=i-(e.util.now()-s);if(0>=r){a&&clearTimeout(a);var p=c;a=u=c=void 0,p&&(d=e.util.now(),o=t.apply(l,n),u||a||(n=l=null))}else u=setTimeout(g,r)},f=function(){u&&clearTimeout(u),a=u=c=void 0,(h||p!==i)&&(d=e.util.now(),o=t.apply(l,n),u||a||(n=l=null))};return function(){if(n=arguments,s=e.util.now(),l=this,c=h&&(u||!v),p===!1)var r=v&&!u;else{a||v||(d=s);var y=p-(s-d),m=0>=y;m?(a&&(a=clearTimeout(a)),d=s,o=t.apply(l,n)):a||(a=setTimeout(f,y))}return m&&u?u=clearTimeout(u):u||i===p||(u=setTimeout(g,i)),r&&(m=!0,o=t.apply(l,n)),!m||u||a||(n=l=null),o}}},error:function(e){if(!console)throw e;if(console.error)console.error.apply(console,arguments);else{if(!console.log)throw e;console.log.apply(console,arguments)}},clone:function(e){var t={};for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t},copy:function(t){return null==t?t:e.is.array(t)?t.slice():e.is.plainObject(t)?e.util.clone(t):t},makeBoundingBox:function(e){if(null!=e.x1&&null!=e.y1){if(null!=e.x2&&null!=e.y2&&e.x2>=e.x1&&e.y2>=e.y1)return{x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2,w:e.x2-e.x1,h:e.y2-e.y1};if(null!=e.w&&null!=e.h&&e.w>=0&&e.h>=0)return{x1:e.x1,y1:e.y1,x2:e.x1+e.w,y2:e.y1+e.h,w:e.w,h:e.h}}},mapEmpty:function(e){var t=!0;if(null!=e)for(var i in e){t=!1;break}return t},pushMap:function(t){var i=e.util.getMap(t);null==i?e.util.setMap($.extend({},t,{value:[t.value]})):i.push(t.value)},setMap:function(t){for(var i,r=t.map,n=t.keys,a=n.length,o=0;a>o;o++){var i=n[o];e.is.plainObject(i)&&e.util.error("Tried to set map with object key"),o<n.length-1?(null==r[i]&&(r[i]={}),r=r[i]):r[i]=t.value}},getMap:function(t){for(var i=t.map,r=t.keys,n=r.length,a=0;n>a;a++){var o=r[a];if(e.is.plainObject(o)&&e.util.error("Tried to get map with object key"),i=i[o],null==i)return i}return i},deleteMap:function(t){for(var i=t.map,r=t.keys,n=r.length,a=t.keepChildren,o=0;n>o;o++){var s=r[o];e.is.plainObject(s)&&e.util.error("Tried to delete map with object key");var l=o===t.keys.length-1;if(l)if(a)for(var u in i)a[u]||(i[u]=void 0);else i[s]=void 0;else i=i[s]}},capitalize:function(t){return e.is.emptyString(t)?t:t.charAt(0).toUpperCase()+t.substring(1)},camel2dash:function(e){for(var t=[],i=0;i<e.length;i++){var r=e[i],n=r.toLowerCase(),a=r!==n;a?(t.push("-"),t.push(n)):t.push(r)}var o=t.length===e.length;return o?e:t.join("")},dash2camel:function(e){for(var t=[],i=!1,r=0;r<e.length;r++){var n=e[r],a="-"===n;a?i=!0:(t.push(i?n.toUpperCase():n),i=!1)}return t.join("")},trim:function(e){var t,i;for(t=0;t<e.length&&" "===e[t];t++);for(i=e.length-1;i>t&&" "===e[i];i--);return e.substring(t,i+1)},hex2tuple:function(e){if((4===e.length||7===e.length)&&"#"===e[0]){var t,i,r,n=4===e.length,a=16;return n?(t=parseInt(e[1]+e[1],a),i=parseInt(e[2]+e[2],a),r=parseInt(e[3]+e[3],a)):(t=parseInt(e[1]+e[2],a),i=parseInt(e[3]+e[4],a),r=parseInt(e[5]+e[6],a)),[t,i,r]}},hsl2tuple:function(t){function i(e,t,i){return 0>i&&(i+=1),i>1&&(i-=1),1/6>i?e+6*(t-e)*i:.5>i?t:2/3>i?e+(t-e)*(2/3-i)*6:e}var r,n,a,o,s,l,u,c,d=new RegExp("^"+e.util.regex.hsla+"$").exec(t);if(d){if(n=parseInt(d[1]),0>n?n=(360- -1*n%360)%360:n>360&&(n%=360),n/=360,a=parseFloat(d[2]),0>a||a>100)return;if(a/=100,o=parseFloat(d[3]),0>o||o>100)return;if(o/=100,s=d[4],void 0!==s&&(s=parseFloat(s),0>s||s>1))return;if(0===a)l=u=c=Math.round(255*o);else{var p=.5>o?o*(1+a):o+a-o*a,h=2*o-p;l=Math.round(255*i(h,p,n+1/3)),u=Math.round(255*i(h,p,n)),c=Math.round(255*i(h,p,n-1/3))}r=[l,u,c,s]}return r},rgb2tuple:function(t){var i,r=new RegExp("^"+e.util.regex.rgba+"$").exec(t);if(r){i=[];for(var n=[],a=1;3>=a;a++){var o=r[a];if("%"===o[o.length-1]&&(n[a]=!0),o=parseFloat(o),n[a]&&(o=o/100*255),0>o||o>255)return;i.push(Math.floor(o))}var s=n[1]||n[2]||n[3],l=n[1]&&n[2]&&n[3];if(s&&!l)return;var u=r[4];if(void 0!==u){if(u=parseFloat(u),0>u||u>1)return;i.push(u)}}return i},colorname2tuple:function(t){return e.util.colors[t.toLowerCase()]},color2tuple:function(t){return(e.is.array(t)?t:null)||e.util.colorname2tuple(t)||e.util.hex2tuple(t)||e.util.rgb2tuple(t)||e.util.hsl2tuple(t)},tuple2hex:function(e){function t(e){var t=e.toString(16);return 1===t.length&&(t="0"+t),t}var i=e[0],r=e[1],n=e[2];return"#"+t(i)+t(r)+t(n)},colors:{transparent:[0,0,0,0],aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],grey:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}},e.util.regex={},e.util.regex.number="(?:[-]?\\\\d*\\\\.\\\\d+|[-]?\\\\d+|[-]?\\\\d*\\\\.\\\\d+[eE]\\\\d+)",e.util.regex.rgba="rgb[a]?\\\\(("+e.util.regex.number+"[%]?)\\\\s*,\\\\s*("+e.util.regex.number+"[%]?)\\\\s*,\\\\s*("+e.util.regex.number+"[%]?)(?:\\\\s*,\\\\s*("+e.util.regex.number+"))?\\\\)",e.util.regex.rgbaNoBackRefs="rgb[a]?\\\\((?:"+e.util.regex.number+"[%]?)\\\\s*,\\\\s*(?:"+e.util.regex.number+"[%]?)\\\\s*,\\\\s*(?:"+e.util.regex.number+"[%]?)(?:\\\\s*,\\\\s*(?:"+e.util.regex.number+"))?\\\\)",e.util.regex.hsla="hsl[a]?\\\\(("+e.util.regex.number+")\\\\s*,\\\\s*("+e.util.regex.number+"[%])\\\\s*,\\\\s*("+e.util.regex.number+"[%])(?:\\\\s*,\\\\s*("+e.util.regex.number+"))?\\\\)",e.util.regex.hslaNoBackRefs="hsl[a]?\\\\((?:"+e.util.regex.number+")\\\\s*,\\\\s*(?:"+e.util.regex.number+"[%])\\\\s*,\\\\s*(?:"+e.util.regex.number+"[%])(?:\\\\s*,\\\\s*(?:"+e.util.regex.number+"))?\\\\)",e.util.regex.hex3="\\\\#[0-9a-fA-F]{3}",e.util.regex.hex6="\\\\#[0-9a-fA-F]{6}";var i=t?t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame:null;i=i||function(e){e&&setTimeout(e,1e3/60)},e.util.requestAnimationFrame=function(e){i(e)}}(cytoscape,"undefined"==typeof window?null:window),function(e){"use strict";e.math={},e.math.signum=function(e){return e>0?1:0>e?-1:0},e.math.distance=function(e,t){var i=t.x-e.x,r=t.y-e.y;return Math.sqrt(i*i+r*r)},e.math.qbezierAt=function(e,t,i,r){return(1-r)*(1-r)*e+2*(1-r)*r*t+r*r*i},e.math.qbezierPtAt=function(t,i,r,n){return{x:e.math.qbezierAt(t.x,i.x,r.x,n),y:e.math.qbezierAt(t.y,i.y,r.y,n)}},e.math.boundingBoxesIntersect=function(e,t){return e.x1>t.x2?!1:t.x1>e.x2?!1:e.x2<t.x1?!1:t.x2<e.x1?!1:e.y2<t.y1?!1:t.y2<e.y1?!1:e.y1>t.y2?!1:t.y1>e.y2?!1:!0},e.math.inBoundingBox=function(e,t,i){return e.x1<=t&&t<=e.x2&&e.y1<=i&&i<=e.y2},e.math.pointInBoundingBox=function(e,t){return this.inBoundingBox(e,t.x,t.y)},e.math.roundRectangleIntersectLine=function(e,t,i,r,n,a,o){var s,l=this.getRoundRectangleRadius(n,a),u=n/2,c=a/2,d=i-u+l-o,p=r-c-o,h=i+u-l+o,v=p;if(s=this.finiteLinesIntersect(e,t,i,r,d,p,h,v,!1),s.length>0)return s;var g=i+u+o,f=r-c+l-o,y=g,m=r+c-l+o;if(s=this.finiteLinesIntersect(e,t,i,r,g,f,y,m,!1),s.length>0)return s;var x=i-u+l-o,b=r+c+o,w=i+u-l+o,_=b;if(s=this.finiteLinesIntersect(e,t,i,r,x,b,w,_,!1),s.length>0)return s;var E=i-u-o,S=r-c+l-o,P=E,D=r+c-l+o;if(s=this.finiteLinesIntersect(e,t,i,r,E,S,P,D,!1),s.length>0)return s;var k,C=i-u+l,T=r-c+l;if(k=this.intersectLineCircle(e,t,i,r,C,T,l+o),k.length>0&&k[0]<=C&&k[1]<=T)return[k[0],k[1]];var N=i+u-l,M=r-c+l;if(k=this.intersectLineCircle(e,t,i,r,N,M,l+o),k.length>0&&k[0]>=N&&k[1]<=M)return[k[0],k[1]];var B=i+u-l,I=r+c-l;if(k=this.intersectLineCircle(e,t,i,r,B,I,l+o),k.length>0&&k[0]>=B&&k[1]>=I)return[k[0],k[1]];var z=i-u+l,L=r+c-l;return k=this.intersectLineCircle(e,t,i,r,z,L,l+o),k.length>0&&k[0]<=z&&k[1]>=L?[k[0],k[1]]:[]},e.math.roundRectangleIntersectBox=function(e,t,i,r,n,a,o,s,l){var u=this.getRoundRectangleRadius(n,a),c=o-n/2-l,d=s-a/2+u-l,p=o+n/2+l,h=s+a/2-u+l,v=o-n/2+u-l,g=s-a/2-l,f=o+n/2-u+l,y=s+a/2+l,m=Math.min(e,i),x=Math.max(e,i),b=Math.min(t,r),w=Math.max(t,r);return c>x?!1:m>p?!1:g>w?!1:b>y?!1:c>=m&&x>=c&&d>=b&&w>=d?!0:p>=m&&x>=p&&d>=b&&w>=d?!0:p>=m&&x>=p&&h>=b&&w>=h?!0:c>=m&&x>=c&&h>=b&&w>=h?!0:m>=c&&p>=m&&b>=d&&h>=b?!0:x>=c&&p>=x&&b>=d&&h>=b?!0:x>=c&&p>=x&&w>=d&&h>=w?!0:m>=c&&p>=m&&w>=d&&h>=w?!0:v>=m&&x>=v&&g>=b&&w>=g?!0:f>=m&&x>=f&&g>=b&&w>=g?!0:f>=m&&x>=f&&y>=b&&w>=y?!0:v>=m&&x>=v&&y>=b&&w>=y?!0:m>=v&&f>=m&&b>=g&&y>=b?!0:x>=v&&f>=x&&b>=g&&y>=b?!0:x>=v&&f>=x&&w>=g&&y>=w?!0:m>=v&&f>=m&&w>=g&&y>=w?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,v+l,d+l)?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,f-l,d+l)?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,f-l,h-l)?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,v+l,h-l)?!0:!1},e.math.checkInBoundingCircle=function(e,t,i,r,n,a,o,s){return e=(e-o)/(n+r),t=(t-s)/(a+r),i>=e*e+t*t},e.math.boxInBezierVicinity=function(e,t,i,r,n,a,o,s,l,u,c){var d=.25*n+.5*o+.25*l,p=.25*a+.5*s+.25*u,h=Math.min(e,i)-c,v=Math.min(t,r)-c,g=Math.max(e,i)+c,f=Math.max(t,r)+c;if(n>=h&&g>=n&&a>=v&&f>=a)return 1;if(l>=h&&g>=l&&u>=v&&f>=u)return 1;if(d>=h&&g>=d&&p>=v&&f>=p)return 1;if(o>=h&&g>=o&&s>=v&&f>=s)return 1;var y=Math.min(n,d,l),m=Math.min(a,p,u),x=Math.max(n,d,l),b=Math.max(a,p,u);return y>g||h>x||m>f||v>b?0:1},e.math.checkBezierInBox=function(t,i,r,n,a,o,s,l,u,c){function d(d){var p=e.math.qbezierAt(a,s,u,d),h=e.math.qbezierAt(o,l,c,d);return p>=t&&r>=p&&h>=i&&n>=h}for(var p=0;1>=p;p+=.25)if(!d(p))return!1;return!0},e.math.checkStraightEdgeInBox=function(e,t,i,r,n,a,o,s){return n>=e&&i>=n&&o>=e&&i>=o&&a>=t&&r>=a&&s>=t&&r>=s},e.math.checkStraightEdgeCrossesBox=function(e,t,i,r,n,a,o,s,l){var u,c,d=Math.min(e,i)-l,p=Math.min(t,r)-l,h=Math.max(e,i)+l,v=Math.max(t,r)+l,g=o-n,f=n,y=s-a,m=a;if(Math.abs(g)<1e-4)return n>=d&&h>=n&&Math.min(a,s)<=p&&Math.max(a,s)>=v;var x=(d-f)/g;if(x>0&&1>=x&&(u=y*x+m,u>=p&&v>=u))return!0;var b=(h-f)/g;if(b>0&&1>=b&&(u=y*b+m,u>=p&&v>=u))return!0;var w=(p-m)/y;if(w>0&&1>=w&&(c=g*w+f,c>=d&&h>=c))return!0;var _=(v-m)/y;return _>0&&1>=_&&(c=g*_+f,c>=d&&h>=c)?!0:!1},e.math.checkBezierCrossesBox=function(e,t,i,r,n,a,o,s,l,u,c){var d=Math.min(e,i)-c,p=Math.min(t,r)-c,h=Math.max(e,i)+c,v=Math.max(t,r)+c;if(n>=d&&h>=n&&a>=p&&v>=a)return!0;if(l>=d&&h>=l&&u>=p&&v>=u)return!0;var g=n-2*o+l,f=-2*n+2*o,y=n,m=[];if(Math.abs(g)<1e-4){var x=(d-n)/f,b=(h-n)/f;m.push(x,b)}else{var w,_,E=f*f-4*g*(y-d);if(E>0){var S=Math.sqrt(E);w=(-f+S)/(2*g),_=(-f-S)/(2*g),m.push(w,_)}var P,D,k=f*f-4*g*(y-h);if(k>0){var S=Math.sqrt(k);P=(-f+S)/(2*g),D=(-f-S)/(2*g),m.push(P,D)}}m.sort(function(e,t){return e-t});var C=a-2*s+u,T=-2*a+2*s,N=a,M=[];if(Math.abs(C)<1e-4){var B=(p-a)/T,I=(v-a)/T;M.push(B,I)}else{var z,L,O=T*T-4*C*(N-p);if(O>0){var S=Math.sqrt(O);z=(-T+S)/(2*C),L=(-T-S)/(2*C),M.push(z,L)}var R,X,V=T*T-4*C*(N-v);if(V>0){var S=Math.sqrt(V);R=(-T+S)/(2*C),X=(-T-S)/(2*C),M.push(R,X)}}M.sort(function(e,t){return e-t});for(var Y=0;Y<m.length;Y+=2)for(var A=1;A<M.length;A+=2)if(m[Y]<M[A]&&M[A]>=0&&m[Y]<=1&&m[Y+1]>M[A-1]&&M[A-1]<=1&&m[Y+1]>=0)return!0;return!1},e.math.inLineVicinity=function(e,t,i,r,n,a,o){var s=o,l=Math.min(i,n),u=Math.max(i,n),c=Math.min(r,a),d=Math.max(r,a);return e>=l-s&&u+s>=e&&t>=c-s&&d+s>=t},e.math.inBezierVicinity=function(e,t,i,r,n,a,o,s){var l={x1:Math.min(i,o,n),x2:Math.max(i,o,n),y1:Math.min(r,s,a),y2:Math.max(r,s,a)};return e<l.x1||e>l.x2||t<l.y1||t>l.y2?!1:!0},e.math.solveCubic=function(e,t,i,r,n){t/=e,i/=e,r/=e;var a,o,s,l,u,c,d,p;return o=(3*i-t*t)/9,s=-(27*r)+t*(9*i-2*t*t),s/=54,a=o*o*o+s*s,n[1]=0,d=t/3,a>0?(u=s+Math.sqrt(a),u=0>u?-Math.pow(-u,1/3):Math.pow(u,1/3),c=s-Math.sqrt(a),c=0>c?-Math.pow(-c,1/3):Math.pow(c,1/3),n[0]=-d+u+c,d+=(u+c)/2,n[4]=n[2]=-d,d=Math.sqrt(3)*(-c+u)/2,n[3]=d,void(n[5]=-d)):(n[5]=n[3]=0,0===a?(p=0>s?-Math.pow(-s,1/3):Math.pow(s,1/3),n[0]=-d+2*p,void(n[4]=n[2]=-(p+d))):(o=-o,l=o*o*o,l=Math.acos(s/Math.sqrt(l)),p=2*Math.sqrt(o),n[0]=-d+p*Math.cos(l/3),n[2]=-d+p*Math.cos((l+2*Math.PI)/3),void(n[4]=-d+p*Math.cos((l+4*Math.PI)/3))))},e.math.sqDistanceToQuadraticBezier=function(e,t,i,r,n,a,o,s){var l=1*i*i-4*i*n+2*i*o+4*n*n-4*n*o+o*o+r*r-4*r*a+2*r*s+4*a*a-4*a*s+s*s,u=9*i*n-3*i*i-3*i*o-6*n*n+3*n*o+9*r*a-3*r*r-3*r*s-6*a*a+3*a*s,c=3*i*i-6*i*n+i*o-i*e+2*n*n+2*n*e-o*e+3*r*r-6*r*a+r*s-r*t+2*a*a+2*a*t-s*t,d=1*i*n-i*i+i*e-n*e+r*a-r*r+r*t-a*t,p=[];this.solveCubic(l,u,c,d,p);for(var h=1e-7,v=[],g=0;6>g;g+=2)Math.abs(p[g+1])<h&&p[g]>=0&&p[g]<=1&&v.push(p[g]);v.push(1),v.push(0);for(var f,y,m,x,b=-1,w=0;w<v.length;w++)y=Math.pow(1-v[w],2)*i+2*(1-v[w])*v[w]*n+v[w]*v[w]*o,m=Math.pow(1-v[w],2)*r+2*(1-v[w])*v[w]*a+v[w]*v[w]*s,x=Math.pow(y-e,2)+Math.pow(m-t,2),b>=0?b>x&&(b=x,f=v[w]):(b=x,f=v[w]);return b},e.math.sqDistanceToFiniteLine=function(e,t,i,r,n,a){var o=[e-i,t-r],s=[n-i,a-r],l=s[0]*s[0]+s[1]*s[1],u=o[0]*o[0]+o[1]*o[1],c=o[0]*s[0]+o[1]*s[1],d=c*c/l;return 0>c?u:d>l?(e-n)*(e-n)+(t-a)*(t-a):u-d},e.math.pointInsidePolygon=function(e,t,i,r,n,a,o,s,l){var u=new Array(i.length),c=Math.asin(s[1]/Math.sqrt(s[0]*s[0]+s[1]*s[1]));s[0]<0?c+=Math.PI/2:c=-c-Math.PI/2;for(var d=Math.cos(-c),p=Math.sin(-c),h=0;h<u.length/2;h++)u[2*h]=a/2*(i[2*h]*d-i[2*h+1]*p),u[2*h+1]=o/2*(i[2*h+1]*d+i[2*h]*p),u[2*h]+=r,u[2*h+1]+=n;var v;if(l>0){var g=this.expandPolygon(u,-l);v=this.joinLines(g)}else v=u;for(var f,y,m,x,b,w=0,_=0,h=0;h<v.length/2;h++)if(f=v[2*h],y=v[2*h+1],h+1<v.length/2?(m=v[2*(h+1)],x=v[2*(h+1)+1]):(m=v[2*(h+1-v.length/2)],x=v[2*(h+1-v.length/2)+1]),f==e&&m==e);else{if(!(f>=e&&e>=m||e>=f&&m>=e))continue;b=(e-f)/(m-f)*(x-y)+y,b>t&&w++,t>b&&_++}return w%2===0?!1:!0},e.math.joinLines=function(e){for(var t,i,r,n,a,o,s,l,u=new Array(e.length/2),c=0;c<e.length/4;c++){t=e[4*c],i=e[4*c+1],r=e[4*c+2],n=e[4*c+3],c<e.length/4-1?(a=e[4*(c+1)],o=e[4*(c+1)+1],s=e[4*(c+1)+2],l=e[4*(c+1)+3]):(a=e[0],o=e[1],s=e[2],l=e[3]);var d=this.finiteLinesIntersect(t,i,r,n,a,o,s,l,!0);u[2*c]=d[0],u[2*c+1]=d[1]}return u},e.math.expandPolygon=function(e,t){for(var i,r,n,a,o=new Array(2*e.length),s=0;s<e.length/2;s++){i=e[2*s],r=e[2*s+1],s<e.length/2-1?(n=e[2*(s+1)],a=e[2*(s+1)+1]):(n=e[0],a=e[1]);var l=a-r,u=-(n-i),c=Math.sqrt(l*l+u*u),d=l/c,p=u/c;o[4*s]=i+d*t,o[4*s+1]=r+p*t,o[4*s+2]=n+d*t,o[4*s+3]=a+p*t}return o},e.math.intersectLineEllipse=function(e,t,i,r,n,a){var o=i-e,s=r-t;o/=n,s/=a;var l=Math.sqrt(o*o+s*s),u=l-1;if(0>u)return[];var c=u/l;return[(i-e)*c+e,(r-t)*c+t]},e.math.dotProduct=function(e,t){if(2!=e.length||2!=t.length)throw"dot product: arguments are not vectors";return e[0]*t[0]+e[1]*t[1]},e.math.intersectLineCircle=function(e,t,i,r,n,a,o){var s=[i-e,r-t],l=[n,a],u=[e-n,t-a],c=s[0]*s[0]+s[1]*s[1],d=2*(u[0]*s[0]+u[1]*s[1]),l=u[0]*u[0]+u[1]*u[1]-o*o,p=d*d-4*c*l;if(0>p)return[];var h=(-d+Math.sqrt(p))/(2*c),v=(-d-Math.sqrt(p))/(2*c),g=Math.min(h,v),f=Math.max(h,v),y=[];if(g>=0&&1>=g&&y.push(g),f>=0&&1>=f&&y.push(f),0===y.length)return[];var m=y[0]*s[0]+e,x=y[0]*s[1]+t;if(y.length>1){if(y[0]==y[1])return[m,x];var b=y[1]*s[0]+e,w=y[1]*s[1]+t;return[m,x,b,w]}return[m,x]},e.math.findCircleNearPoint=function(e,t,i,r,n){var a=r-e,o=n-t,s=Math.sqrt(a*a+o*o),l=a/s,u=o/s;return[e+l*i,t+u*i]},e.math.findMaxSqDistanceToOrigin=function(e){for(var t,i=1e-6,r=0;r<e.length/2;r++)t=e[2*r]*e[2*r]+e[2*r+1]*e[2*r+1],t>i&&(i=t);return i},e.math.finiteLinesIntersect=function(e,t,i,r,n,a,o,s,l){var u=(o-n)*(t-a)-(s-a)*(e-n),c=(i-e)*(t-a)-(r-t)*(e-n),d=(s-a)*(i-e)-(o-n)*(r-t);if(0!==d){var p=u/d,h=c/d;return p>=0&&1>=p&&h>=0&&1>=h?[e+p*(i-e),t+p*(r-t)]:l?[e+p*(i-e),t+p*(r-t)]:[]}return 0===u||0===c?[e,i,o].sort()[1]===o?[o,s]:[e,i,n].sort()[1]===n?[n,a]:[n,o,i].sort()[1]===i?[i,r]:[]:[]},e.math.boxIntersectEllipse=function(e,t,i,r,n,a,o,s,l){if(e>i){var u=e;e=i,i=u}if(t>r){var c=t;t=r,r=c}var d=[s-a/2-n,l],p=[s+a/2+n,l],h=[s,l-o/2-n],v=[s,l+o/2+n];return i<d[0]?!1:e>p[0]?!1:t>v[1]?!1:r<h[1]?!1:e<=p[0]&&p[0]<=i&&t<=p[1]&&p[1]<=r?!0:e<=d[0]&&d[0]<=i&&t<=d[1]&&d[1]<=r?!0:e<=h[0]&&h[0]<=i&&t<=h[1]&&h[1]<=r?!0:e<=v[0]&&v[0]<=i&&t<=v[1]&&v[1]<=r?!0:(e=(e-s)/(a/2+n),i=(i-s)/(a/2+n),t=(t-l)/(o/2+n),r=(r-l)/(o/2+n),1>=e*e+t*t?!0:1>=i*i+t*t?!0:1>=i*i+r*r?!0:1>=e*e+r*r?!0:!1)},e.math.boxIntersectPolygon=function(t,i,r,n,a,o,s,l,u,c,d){if(t>r){var p=t;t=r,r=p}if(i>n){var h=i;i=n,n=h}var v=new Array(a.length),g=Math.asin(c[1]/Math.sqrt(c[0]*c[0]+c[1]*c[1]));c[0]<0?g+=Math.PI/2:g=-g-Math.PI/2;for(var f=Math.cos(-g),y=Math.sin(-g),m=0;m<v.length/2;m++)v[2*m]=o/2*(a[2*m]*f-a[2*m+1]*y),v[2*m+1]=s/2*(a[2*m+1]*f+a[2*m]*y),v[2*m]+=l,v[2*m+1]+=u;for(var x=v[0],b=v[0],w=v[1],_=v[1],m=1;m<v.length/2;m++)v[2*m]>b&&(b=v[2*m]),v[2*m]<x&&(x=v[2*m]),v[2*m+1]>_&&(_=v[2*m+1]),v[2*m+1]<w&&(w=v[2*m+1]);if(x-d>r)return!1;if(t>b+d)return!1;if(w-d>n)return!1;if(i>_+d)return!1;var E;if(d>0){var S=e.math.expandPolygon(v,-d);E=e.math.joinLines(S)}else E=v;for(var m=0;m<v.length/2;m++)if(t<=v[2*m]&&v[2*m]<=r&&i<=v[2*m+1]&&v[2*m+1]<=n)return!0;for(var m=0;m<E.length/2;m++){var P,D,k=E[2*m],C=E[2*m+1];if(m<E.length/2-1?(P=E[2*(m+1)],D=E[2*(m+1)+1]):(P=E[0],D=E[1]),e.math.finiteLinesIntersect(k,C,P,D,t,i,r,i,!1).length>0)return!0;if(e.math.finiteLinesIntersect(k,C,P,D,t,n,r,n,!1).length>0)return!0;if(e.math.finiteLinesIntersect(k,C,P,D,t,i,t,n,!1).length>0)return!0;if(e.math.finiteLinesIntersect(k,C,P,D,r,i,r,n,!1).length>0)return!0}return!1},e.math.polygonIntersectLine=function(t,i,r,n,a,o,s,l){for(var u,c=[],d=new Array(r.length),p=0;p<d.length/2;p++)d[2*p]=r[2*p]*o+n,d[2*p+1]=r[2*p+1]*s+a;var h;if(l>0){var v=e.math.expandPolygon(d,-l);h=e.math.joinLines(v)}else h=d;for(var g,f,y,m,p=0;p<h.length/2;p++)g=h[2*p],f=h[2*p+1],p<h.length/2-1?(y=h[2*(p+1)],m=h[2*(p+1)+1]):(y=h[0],m=h[1]),u=this.finiteLinesIntersect(t,i,n,a,g,f,y,m),0!==u.length&&c.push(u[0],u[1]);return c},e.math.shortenIntersection=function(e,t,i){var r=[e[0]-t[0],e[1]-t[1]],n=Math.sqrt(r[0]*r[0]+r[1]*r[1]),a=(n-i)/n;return 0>a&&(a=1e-5),[t[0]+a*r[0],t[1]+a*r[1]]},e.math.generateUnitNgonPointsFitToSquare=function(t,i){var r=e.math.generateUnitNgonPoints(t,i);return r=e.math.fitPolygonToSquare(r)},e.math.fitPolygonToSquare=function(e){for(var t,i,r=e.length/2,n=1/0,a=1/0,o=-1/0,s=-1/0,l=0;r>l;l++)t=e[2*l],i=e[2*l+1],n=Math.min(n,t),o=Math.max(o,t),a=Math.min(a,i),s=Math.max(s,i);for(var u=2/(o-n),c=2/(s-a),l=0;r>l;l++)t=e[2*l]=e[2*l]*u,i=e[2*l+1]=e[2*l+1]*c,n=Math.min(n,t),o=Math.max(o,t),a=Math.min(a,i),s=Math.max(s,i);if(-1>a)for(var l=0;r>l;l++)i=e[2*l+1]=e[2*l+1]+(-1-a);return e},e.math.generateUnitNgonPoints=function(e,t){var i=1/e*2*Math.PI,r=e%2===0?Math.PI/2+i/2:Math.PI/2;r+=t;for(var n,a,o,s=new Array(2*e),l=0;e>l;l++)n=l*i+r,a=s[2*l]=Math.cos(n),o=s[2*l+1]=Math.sin(-n);return s},e.math.getRoundRectangleRadius=function(e,t){return Math.min(e/4,t/4,8)}}(cytoscape),function(e){"use strict";function t(t,i,r){var n={};switch(n[i]=r,t){case"core":case"collection":e.fn[t](n)}if("layout"===t){for(var o=r.prototype,s=["stop"],l=0;l<s.length;l++){var u=s[l];o[u]=o[u]||function(){return this}}o.start&&!o.run?o.run=function(){return this.start(),this}:!o.start&&o.run&&(o.start=function(){return this.run(),this}),o.on=e.define.on({layout:!0}),o.one=e.define.on({layout:!0,unbindSelfOnTrigger:!0}),o.once=e.define.on({layout:!0,unbindAllBindersOnTrigger:!0}),o.off=e.define.off({layout:!0}),o.trigger=e.define.trigger({layout:!0}),o.bind=o.on,o.unbind=o.off}return e.util.setMap({map:a,keys:[t,i],value:r})}function i(t,i){return e.util.getMap({map:a,keys:[t,i]})}function r(t,i,r,n,a){return e.util.setMap({map:o,keys:[t,i,r,n],value:a})}function n(t,i,r,n){return e.util.getMap({map:o,keys:[t,i,r,n]})}var a={};e.extensions=a;var o={};e.modules=o,e.extension=function(){return 2==arguments.length?i.apply(this,arguments):3==arguments.length?t.apply(this,arguments):4==arguments.length?n.apply(this,arguments):5==arguments.length?r.apply(this,arguments):void e.util.error("Invalid extension access syntax")}}(cytoscape),function(e,t){"use strict";if(e){var i=function(e){var t=e[0]._cyreg=e[0]._cyreg||{};return t};e.fn.cytoscape=function(r){var n=e(this);if("get"===r)return i(n).cy;if(t.is.fn(r)){var a=r,o=i(n).cy;if(o&&o.isReady())o.trigger("ready",[],a);else{var s=i(n),l=s.readies=s.readies||[];l.push(a)}}else if(t.is.plainObject(r))return n.each(function(){var t=e.extend({},r,{container:e(this)[0]});cytoscape(t)})},e.cytoscape=cytoscape,null==e.fn.cy&&null==e.cy&&(e.fn.cy=e.fn.cytoscape,e.cy=e.cytoscape)}}("undefined"!=typeof jQuery?jQuery:null,cytoscape),function(e){"use strict";function t(){return!1}function i(){return!0}e.Event=function(r,n){return this instanceof e.Event?(r&&r.type?(this.originalEvent=r,this.type=r.type,this.isDefaultPrevented=r.defaultPrevented?i:t):this.type=r,n&&(this.type=void 0!==n.type?n.type:this.type,this.cy=n.cy,this.cyTarget=n.cyTarget,this.cyPosition=n.cyPosition,this.cyRenderedPosition=n.cyRenderedPosition,this.namespace=n.namespace,this.layout=n.layout,this.data=n.data),void(this.timeStamp=r&&r.timeStamp||+new Date)):new e.Event(r,n)},e.Event.prototype={preventDefault:function(){this.isDefaultPrevented=i;var e=this.originalEvent;e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){this.isPropagationStopped=i;var e=this.originalEvent;e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=i,this.stopPropagation()},isDefaultPrevented:t,isPropagationStopped:t,isImmediatePropagationStopped:t}}(cytoscape),function(e){"use strict";e.define={data:function(t){var i={field:"data",bindingEvent:"data",allowBinding:!1,allowSetting:!1,allowGetting:!1,settingEvent:"data",settingTriggersEvent:!1,triggerFnName:"trigger",immutableKeys:{},updateStyle:!1,onSet:function(){},canSet:function(){return!0}};return t=e.util.extend({},i,t),function(i,r){var n=t,a=this,o=void 0!==a.length,s=o?a:[a],l=o?a[0]:a;if(e.is.string(i)){if(n.allowGetting&&void 0===r){var u;return l&&(u=l._private[n.field][i]),u}if(n.allowSetting&&void 0!==r){var c=!n.immutableKeys[i];if(c){for(var d=0,p=s.length;p>d;d++)n.canSet(s[d])&&(s[d]._private[n.field][i]=r);n.updateStyle&&a.updateStyle(),n.onSet(a),n.settingTriggersEvent&&a[n.triggerFnName](n.settingEvent)}}}else if(n.allowSetting&&e.is.plainObject(i)){var h,v,g=i;for(h in g){v=g[h];var c=!n.immutableKeys[h];if(c)for(var d=0,p=s.length;p>d;d++)n.canSet(s[d])&&(s[d]._private[n.field][h]=v)}n.updateStyle&&a.updateStyle(),n.onSet(a),n.settingTriggersEvent&&a[n.triggerFnName](n.settingEvent)}else if(n.allowBinding&&e.is.fn(i)){var f=i;a.bind(n.bindingEvent,f)}else if(n.allowGetting&&void 0===i){var u;return l&&(u=l._private[n.field]),u}return a}},removeData:function(t){var i={field:"data",event:"data",triggerFnName:"trigger",triggerEvent:!1,immutableKeys:{}};return t=e.util.extend({},i,t),function(i){var r=t,n=this,a=void 0!==n.length,o=a?n:[n];if(e.is.string(i)){for(var s=i.split(/\\s+/),l=s.length,u=0;l>u;u++){var c=s[u];if(!e.is.emptyString(c)){var d=!r.immutableKeys[c];if(d)for(var p=0,h=o.length;h>p;p++)o[p]._private[r.field][c]=void 0}}r.triggerEvent&&n[r.triggerFnName](r.event)}else if(void 0===i){for(var p=0,h=o.length;h>p;p++){var v=o[p]._private[r.field];for(var c in v){var g=!r.immutableKeys[c];g&&(v[c]=void 0)}}r.triggerEvent&&n[r.triggerFnName](r.event)}return n}},event:{regex:/(\\w+)(\\.\\w+)?/,optionalTypeRegex:/(\\w+)?(\\.\\w+)?/,falseCallback:function(){return!1}},on:function(t){var i={unbindSelfOnTrigger:!1,unbindAllBindersOnTrigger:!1};return t=e.util.extend({},i,t),function(i,r,n,a){var o=this,s=void 0!==o.length,l=s?o:[o],u=e.is.string(i),c=t;if(e.is.plainObject(r)?(a=n,n=r,r=void 0):(e.is.fn(r)||r===!1)&&(a=r,n=void 0,r=void 0),(e.is.fn(n)||n===!1)&&(a=n,n=void 0),!e.is.fn(a)&&a!==!1&&u)return o;if(u){var d={};d[i]=a,i=d}for(var p in i)if(a=i[p],a===!1&&(a=e.define.event.falseCallback),e.is.fn(a)){p=p.split(/\\s+/);for(var h=0;h<p.length;h++){var v=p[h];if(!e.is.emptyString(v)){var g=v.match(e.define.event.regex);if(g)for(var f=g[1],y=g[2]?g[2]:void 0,m={callback:a,data:n,delegated:r?!0:!1,selector:r,selObj:new e.Selector(r),type:f,namespace:y,unbindSelfOnTrigger:c.unbindSelfOnTrigger,unbindAllBindersOnTrigger:c.unbindAllBindersOnTrigger,binders:l},x=0;x<l.length;x++)l[x]._private.listeners.push(m)}}}return o}},off:function(t){var i={};return t=e.util.extend({},i,t),function(t,i,r){var n=this,a=void 0!==n.length,o=a?n:[n],s=e.is.string(t);if(0===arguments.length){for(var l=0;l<o.length;l++)o[l]._private.listeners=[];return n}if((e.is.fn(i)||i===!1)&&(r=i,i=void 0),s){var u={};u[t]=r,t=u}for(var c in t){r=t[c],r===!1&&(r=e.define.event.falseCallback),c=c.split(/\\s+/);for(var d=0;d<c.length;d++){var p=c[d];if(!e.is.emptyString(p)){var h=p.match(e.define.event.optionalTypeRegex);if(h)for(var v=h[1]?h[1]:void 0,g=h[2]?h[2]:void 0,l=0;l<o.length;l++)for(var f=o[l]._private.listeners,y=0;y<f.length;y++){var m=f[y],x=!g||g===m.namespace,b=!v||m.type===v,w=!r||r===m.callback,_=x&&b&&w;_&&(f.splice(y,1),y--)}}}}return n}},trigger:function(t){var i={};return t=e.util.extend({},i,t),function(i,r,n){var a=this,o=void 0!==a.length,s=o?a:[a],l=e.is.string(i),u=e.is.plainObject(i),c=e.is.event(i),d=this._private.cy||this,p=d.hasCompoundNodes();if(l){var h=i.split(/\\s+/);i=[];for(var v=0;v<h.length;v++){var g=h[v];if(!e.is.emptyString(g)){var f=g.match(e.define.event.regex),y=f[1],m=f[2]?f[2]:void 0;i.push({type:y,namespace:m})}}}else if(u){var x=i;i=[x]}r?e.is.array(r)||(r=[r]):r=[];for(var v=0;v<i.length;v++)for(var b=i[v],w=0;w<s.length;w++){var g,_=s[w],E=_._private.listeners,S=e.is.element(_),P=S||t.layout;if(c?(g=b,g.cyTarget=g.cyTarget||_,g.cy=g.cy||d):g=new e.Event(b,{cyTarget:_,cy:d,namespace:b.namespace}),b.layout&&(g.layout=b.layout),t.layout&&(g.layout=_),g.cyPosition){var D=g.cyPosition,k=d.zoom(),C=d.pan();g.cyRenderedPosition={x:D.x*k+C.x,y:D.y*k+C.y}}n&&(E=[{namespace:g.namespace,type:g.type,callback:n}]);for(var T=0;T<E.length;T++){var N=E[T],M=!N.namespace||N.namespace===g.namespace,B=N.type===g.type,I=N.delegated?_!==g.cyTarget&&e.is.element(g.cyTarget)&&N.selObj.matches(g.cyTarget):!0,z=M&&B&&I;if(z){var L=[g];if(L=L.concat(r),g.data=N.data?N.data:void 0,(N.unbindSelfOnTrigger||N.unbindAllBindersOnTrigger)&&(E.splice(T,1),T--),N.unbindAllBindersOnTrigger)for(var O=N.binders,R=0;R<O.length;R++){var X=O[R];if(X&&X!==_)for(var V=X._private.listeners,Y=0;Y<V.length;Y++){var A=V[Y];A===N&&(V.splice(Y,1),Y--)}}var q=N.delegated?g.cyTarget:_,F=N.callback.apply(q,L);(F===!1||g.isPropagationStopped())&&(P=!1,F===!1&&(g.stopPropagation(),g.preventDefault()))}}if(P){var j=p?_._private.parent:null,W=null!=j&&0!==j.length;W?(j=j[0],j.trigger(g)):d.trigger(g)}}return a}},animated:function(t){var i={};return t=e.util.extend({},i,t),function(){var e=this,t=void 0!==e.length,i=t?e:[e],r=this._private.cy||this;if(!r.styleEnabled())return!1;var n=i[0];return n?n._private.animation.current.length>0:void 0}},clearQueue:function(t){var i={};return t=e.util.extend({},i,t),function(){var e=this,t=void 0!==e.length,i=t?e:[e],r=this._private.cy||this;if(!r.styleEnabled())return this;for(var n=0;n<i.length;n++){var a=i[n];a._private.animation.queue=[]}return this}},delay:function(t){var i={};return t=e.util.extend({},i,t),function(e,t){var i=this._private.cy||this;return i.styleEnabled()?(this.animate({delay:e},{duration:e,complete:t}),this):this}},animate:function(t){var i={};return t=e.util.extend({},i,t),function(e,t){var i=this,r=void 0!==i.length,n=r?i:[i],a=this._private.cy||this,o=!r,s=!o;\nif(!a.styleEnabled())return this;var l,u=+new Date,c=a.style();switch(void 0===t&&(t={}),void 0===t.duration&&(t.duration=400),t.duration){case"slow":t.duration=600;break;case"fast":t.duration=200}var d=!0;if(e)for(var p in e){d=!1;break}if(d)return this;if(e.css&&s&&(e.css=c.getValueStyle(e.css,{array:!0})),e.renderedPosition&&s){var h=e.renderedPosition,v=a.pan(),g=a.zoom();e.position={x:(h.x-v.x)/g,y:(h.y-v.y)/g}}if(e.panBy&&o){var f=e.panBy,y=a.pan();e.pan={x:y.x+f.x,y:y.y+f.y}}var m=e.center||e.centre;if(m&&o){var x=a.getCenterPan(m.eles,e.zoom);x&&(e.pan=x)}if(e.fit&&o){var b=e.fit,w=a.getFitViewport(b.eles||b.boundingBox,b.padding);w&&(e.pan=w.pan,e.zoom=w.zoom)}for(var p=0;p<n.length;p++){var _=n[p];l=_.animated()&&(void 0===t.queue||t.queue)?_._private.animation.queue:_._private.animation.current,l.push({properties:e,duration:t.duration,params:t,callTime:u})}return s&&a.addToAnimationPool(this),this}},stop:function(t){var i={};return t=e.util.extend({},i,t),function(e,t){var i=this,r=void 0!==i.length,n=r?i:[i],a=this._private.cy||this;if(!a.styleEnabled())return this;for(var o=0;o<n.length;o++){for(var s=n[o],l=s._private.animation.current,u=0;u<l.length;u++){var c=l[u];t&&(c.duration=0)}e&&(s._private.animation.queue=[]),t||(s._private.animation.current=[])}return a.notify({collection:this,type:"draw"}),this}}}}(cytoscape),function(e){"use strict";e.fn.selector=function(t){for(var i in t){var r=t[i];e.Selector.prototype[i]=r}},e.Selector=function(t,i){if(!(this instanceof e.Selector))return new e.Selector(t,i);void 0===i&&void 0!==t&&(i=t,t=void 0);var r=this;if(r._private={selectorText:null,invalid:!0},!i||e.is.string(i)&&i.match(/^\\s*$/))null==t?r.length=0:(r[0]=o(),r[0].group=t,r.length=1);else if(e.is.element(i)){var n=new e.Collection(r.cy(),[i]);r[0]=o(),r[0].collection=n,r.length=1}else if(e.is.collection(i))r[0]=o(),r[0].collection=i,r.length=1;else if(e.is.fn(i))r[0]=o(),r[0].filter=i,r.length=1;else{if(!e.is.string(i))return void e.util.error("A selector must be created from a string; found "+i);var a=null,o=function(){return{classes:[],colonSelectors:[],data:[],group:null,ids:[],meta:[],collection:null,filter:null,parent:null,ancestor:null,subject:null,child:null,descendant:null}},s={metaChar:"[\\\\!\\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]",comparatorOp:"=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=",boolOp:"\\\\?|\\\\!|\\\\^",string:\'"(?:\\\\\\\\"|[^"])+"|\'+"\'(?:\\\\\\\\\'|[^\'])+\'",number:e.util.regex.number,meta:"degree|indegree|outdegree",separator:"\\\\s*,\\\\s*",descendant:"\\\\s+",child:"\\\\s+>\\\\s+",subject:"\\\\$"};s.variable="(?:[\\\\w-]|(?:\\\\\\\\"+s.metaChar+"))+",s.value=s.string+"|"+s.number,s.className=s.variable,s.id=s.variable;for(var l=function(e){return e.replace(new RegExp("\\\\\\\\("+s.metaChar+")","g"),function(e,t){return t})},u=s.comparatorOp.split("|"),c=0;c<u.length;c++){var d=u[c];s.comparatorOp+="|@"+d}for(var u=s.comparatorOp.split("|"),c=0;c<u.length;c++){var d=u[c];d.indexOf("!")>=0||"="!==d&&(s.comparatorOp+="|\\\\!"+d)}var p={group:{query:!0,regex:"(node|edge|\\\\*)",populate:function(e){this.group="*"==e?e:e+"s"}},state:{query:!0,regex:"(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch)",populate:function(e){this.colonSelectors.push(e)}},id:{query:!0,regex:"\\\\#("+s.id+")",populate:function(e){this.ids.push(l(e))}},className:{query:!0,regex:"\\\\.("+s.className+")",populate:function(e){this.classes.push(l(e))}},dataExists:{query:!0,regex:"\\\\[\\\\s*("+s.variable+")\\\\s*\\\\]",populate:function(e){this.data.push({field:l(e)})}},dataCompare:{query:!0,regex:"\\\\[\\\\s*("+s.variable+")\\\\s*("+s.comparatorOp+")\\\\s*("+s.value+")\\\\s*\\\\]",populate:function(e,t,i){var r=null!=new RegExp("^"+s.string+"$").exec(i);i=r?i.substring(1,i.length-1):parseFloat(i),this.data.push({field:l(e),operator:t,value:i})}},dataBool:{query:!0,regex:"\\\\[\\\\s*("+s.boolOp+")\\\\s*("+s.variable+")\\\\s*\\\\]",populate:function(e,t){this.data.push({field:l(t),operator:e})}},metaCompare:{query:!0,regex:"\\\\[\\\\[\\\\s*("+s.meta+")\\\\s*("+s.comparatorOp+")\\\\s*("+s.number+")\\\\s*\\\\]\\\\]",populate:function(e,t,i){this.meta.push({field:l(e),operator:t,value:parseFloat(i)})}},nextQuery:{separator:!0,regex:s.separator,populate:function(){r[++c]=o(),a=null}},child:{separator:!0,regex:s.child,populate:function(){var e=o();e.parent=this,e.subject=a,r[c]=e}},descendant:{separator:!0,regex:s.descendant,populate:function(){var e=o();e.ancestor=this,e.subject=a,r[c]=e}},subject:{modifier:!0,regex:s.subject,populate:function(){return null!=a&&this.subject!=this?(e.util.error("Redefinition of subject in selector `"+i+"`"),!1):(a=this,void(this.subject=this))}}},h=0;for(var v in p)p[h]=p[v],p[h].name=v,h++;p.length=h,r._private.selectorText=i;var g=i,c=0,f=function(t){for(var i,r,n,a=0;a<p.length;a++){var o=p[a],s=o.name;if(!e.is.fn(t)||t(s,o)){var l=g.match(new RegExp("^"+o.regex));if(null!=l){r=l,i=o,n=s;var u=l[0];g=g.substring(u.length);break}}}return{expr:i,match:r,name:n}},y=function(){var e=g.match(/^\\s+/);if(e){var t=e[0];g=g.substring(t.length)}};for(r[0]=o(),y();;){var m=f();if(null==m.expr)return void e.util.error("The selector `"+i+"`is invalid");for(var x=[],h=1;h<m.match.length;h++)x.push(m.match[h]);var b=m.expr.populate.apply(r[c],x);if(b===!1)return;if(g.match(/^\\s*$/))break}for(r.length=c+1,h=0;h<r.length;h++){var w=r[h];if(null!=w.subject){for(;w.subject!=w;)if(null!=w.parent){var _=w.parent,E=w;E.parent=null,_.child=E,w=_}else{if(null==w.ancestor){e.util.error("When adjusting references for the selector `"+w+"`, neither parent nor ancestor was found");break}var S=w.ancestor,P=w;P.ancestor=null,S.descendant=P,w=S}r[h]=w.subject}}if(null!=t)for(var h=0;h<r.length;h++){if(null!=r[h].group&&r[h].group!=t)return void e.util.error("Group `"+r[h].group+"` conflicts with implicit group `"+t+"` in selector `"+i+"`");r[h].group=t}}r._private.invalid=!1},e.selfn=e.Selector.prototype,e.selfn.size=function(){return this.length},e.selfn.eq=function(e){return this[e]},e.selfn.find=function(){};var t=function(i,r){if(null!=i.group&&"*"!=i.group&&i.group!=r._private.group)return!1;for(var n=r.cy(),a=!0,o=0;o<i.colonSelectors.length;o++){var s=i.colonSelectors[o];switch(s){case":selected":a=r.selected();break;case":unselected":a=!r.selected();break;case":selectable":a=r.selectable();break;case":unselectable":a=!r.selectable();break;case":locked":a=r.locked();break;case":unlocked":a=!r.locked();break;case":visible":a=r.visible();break;case":hidden":a=!r.visible();break;case":transparent":a=r.transparent();break;case":grabbed":a=r.grabbed();break;case":free":a=!r.grabbed();break;case":removed":a=r.removed();break;case":inside":a=!r.removed();break;case":grabbable":a=r.grabbable();break;case":ungrabbable":a=!r.grabbable();break;case":animated":a=r.animated();break;case":unanimated":a=!r.animated();break;case":parent":a=r.isNode()&&r.children().nonempty();break;case":child":case":nonorphan":a=r.isNode()&&r.parent().nonempty();break;case":orphan":a=r.isNode()&&r.parent().empty();break;case":loop":a=r.isEdge()&&r.data("source")===r.data("target");break;case":simple":a=r.isEdge()&&r.data("source")!==r.data("target");break;case":active":a=r.active();break;case":inactive":a=!r.active();break;case":touch":a=e.is.touch()}if(!a)break}if(!a)return!1;for(var l=!0,o=0;o<i.ids.length;o++){var u=i.ids[o],c=r._private.data.id;if(l=l&&u==c,!l)break}if(!l)return!1;for(var d=!0,o=0;o<i.classes.length;o++){var p=i.classes[o];if(d=d&&r.hasClass(p),!d)break}if(!d)return!1;var h=function(t){for(var r=!0,n=0;n<i[t.name].length;n++){var a,o=i[t.name][n],s=o.operator,l=o.value,u=o.field;if(null!=s&&null!=l){var c=t.fieldValue(u),d=e.is.string(c)||e.is.number(c)?""+c:"",p=""+l,h=!1;s.indexOf("@")>=0&&(d=d.toLowerCase(),p=p.toLowerCase(),s=s.replace("@",""),h=!0);var v=!1,g=!1;switch(s.indexOf("!")>=0&&(s=s.replace("!",""),v=!0),h&&(l=p.toLowerCase(),c=d.toLowerCase()),s){case"*=":a=d.search(p)>=0;break;case"$=":a=null!=new RegExp(p+"$").exec(d);break;case"^=":a=null!=new RegExp("^"+p).exec(d);break;case"=":a=c===l;break;case"!=":a=c!==l;break;case">":a=v?l>=c:c>l,g=!0;break;case">=":a=v?l>c:c>=l,g=!0;break;case"<":a=v?c>=l:l>c,g=!0;break;case"<=":a=v?c>l:l>=c,g=!0;break;default:a=!1}}else if(null!=s)switch(s){case"?":a=t.fieldTruthy(u);break;case"!":a=!t.fieldTruthy(u);break;case"^":a=t.fieldUndefined(u)}else a=!t.fieldUndefined(u);if(v&&!g&&(a=!a,g=!0),!a){r=!1;break}}return r},v=h({name:"data",fieldValue:function(e){return r._private.data[e]},fieldRef:function(e){return"element._private.data."+e},fieldUndefined:function(e){return void 0===r._private.data[e]},fieldTruthy:function(e){return r._private.data[e]?!0:!1}});if(!v)return!1;var g=h({name:"meta",fieldValue:function(e){return r[e]()},fieldRef:function(e){return"element."+e+"()"},fieldUndefined:function(e){return null==r[e]()},fieldTruthy:function(e){return r[e]()?!0:!1}});if(!g)return!1;if(null!=i.collection){var f=null!=i.collection._private.ids[r.id()];if(!f)return!1}if(null!=i.filter&&0===r.collection().filter(i.filter).size())return!1;var y=function(e,i){if(null!=e){var r=!1;if(!n.hasCompoundNodes())return!1;i=i();for(var a=0;a<i.length;a++)if(t(e,i[a])){r=!0;break}return r}return!0};return y(i.parent,function(){return r.parent()})&&y(i.ancestor,function(){return r.parents()})&&y(i.child,function(){return r.children()})&&y(i.descendant,function(){return r.descendants()})?!0:!1};e.selfn.filter=function(i){var r=this,n=i.cy();if(r._private.invalid)return new e.Collection(n);var a=function(e,i){for(var n=0;n<r.length;n++){var a=r[n];if(t(a,i))return!0}return!1};null==r._private.selectorText&&(a=function(){return!0});var o=i.filter(a);return o},e.selfn.matches=function(e){var i=this;if(i._private.invalid)return!1;for(var r=0;r<i.length;r++){var n=i[r];if(t(n,e))return!0}return!1},e.selfn.toString=e.selfn.selector=function(){for(var t="",i=function(t){return e.is.string(t)?t:""},r=function(e){var t="",a=i(e.group);t+=a.substring(0,a.length-1);for(var o=0;o<e.data.length;o++){var s=e.data[o];t+=s.value?"["+s.field+i(s.operator)+i(s.value)+"]":"["+i(s.operator)+s.field+"]"}for(var o=0;o<e.meta.length;o++){var l=e.meta[o];t+="[["+l.field+i(l.operator)+i(l.value)+"]]"}for(var o=0;o<e.colonSelectors.length;o++){var u=e.colonSelectors[n];t+=u}for(var o=0;o<e.ids.length;o++){var u="#"+e.ids[n];t+=u}for(var o=0;o<e.classes.length;o++){var u="."+e.classes[n];t+=u}return null!=e.parent&&(t=r(e.parent)+" > "+t),null!=e.ancestor&&(t=r(e.ancestor)+" "+t),null!=e.child&&(t+=" > "+r(e.child)),null!=e.descendant&&(t+=" "+r(e.descendant)),t},n=0;n<this.length;n++){var a=this[n];t+=r(a),this.length>1&&n<this.length-1&&(t+=", ")}return t}}(cytoscape),function(e){"use strict";e.Style=function(t){return this instanceof e.Style?e.is.core(t)?(this._private={cy:t,coreStyle:{},newStyle:!0},this.length=0,void this.addDefaultStylesheet()):void e.util.error("A style must have a core reference"):new e.Style(t)},e.style=e.Style,e.styfn=e.Style.prototype,e.fn.style=function(t){for(var i in t){var r=t[i];e.Style.prototype=r}},function(){var t=e.util.regex.number,i=e.util.regex.rgbaNoBackRefs,r=e.util.regex.hslaNoBackRefs,n=e.util.regex.hex3,a=e.util.regex.hex6,o=function(e){return"^"+e+"\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$"},s=function(e){return"^"+e+"\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*("+t+")\\\\s*\\\\,\\\\s*("+t+")\\\\s*,\\\\s*("+t+"|\\\\w+|"+i+"|"+r+"|"+n+"|"+a+")\\\\s*\\\\,\\\\s*("+t+"|\\\\w+|"+i+"|"+r+"|"+n+"|"+a+")\\\\)$"};e.style.types={time:{number:!0,min:0,units:"s|ms",implicitUnits:"ms"},percent:{number:!0,min:0,max:100,units:"%"},zeroOneNumber:{number:!0,min:0,max:1,unitless:!0},nOneOneNumber:{number:!0,min:-1,max:1,unitless:!0},nonNegativeInt:{number:!0,min:0,integer:!0,unitless:!0},position:{enums:["parent","origin"]},autoSize:{number:!0,min:0,enums:["auto"]},number:{number:!0},size:{number:!0,min:0},bgSize:{number:!0,min:0,allowPercent:!0},bgPos:{number:!0,allowPercent:!0},bgRepeat:{enums:["repeat","repeat-x","repeat-y","no-repeat"]},bgFit:{enums:["none","contain","cover"]},bgClip:{enums:["none","node"]},color:{color:!0},lineStyle:{enums:["solid","dotted","dashed"]},borderStyle:{enums:["solid","dotted","dashed","double"]},curveStyle:{enums:["bezier","unbundled-bezier","haystack"]},fontFamily:{regex:"^([\\\\w- ]+(?:\\\\s*,\\\\s*[\\\\w- ]+)*)$"},fontVariant:{enums:["small-caps","normal"]},fontStyle:{enums:["italic","normal","oblique"]},fontWeight:{enums:["normal","bold","bolder","lighter","100","200","300","400","500","600","800","900",100,200,300,400,500,600,700,800,900]},textDecoration:{enums:["none","underline","overline","line-through"]},textTransform:{enums:["none","uppercase","lowercase"]},nodeShape:{enums:["rectangle","roundrectangle","ellipse","triangle","square","pentagon","hexagon","heptagon","octagon","star"]},arrowShape:{enums:["tee","triangle","triangle-tee","triangle-backcurve","half-triangle-overshot","square","circle","diamond","none"]},arrowFill:{enums:["filled","hollow"]},display:{enums:["element","none"]},visibility:{enums:["hidden","visible"]},valign:{enums:["top","center","bottom"]},halign:{enums:["left","center","right"]},text:{string:!0},data:{mapping:!0,regex:o("data")},layoutData:{mapping:!0,regex:o("layoutData")},mapData:{mapping:!0,regex:s("mapData")},mapLayoutData:{mapping:!0,regex:s("mapLayoutData")},url:{regex:"^url\\\\s*\\\\(\\\\s*([^\\\\s]+)\\\\s*\\\\s*\\\\)|none|(.+)$"},propList:{propList:!0},angle:{number:!0,units:"deg|rad"}};var l=e.style.types,u=e.style.properties=[{name:"text-valign",type:l.valign},{name:"text-halign",type:l.halign},{name:"color",type:l.color},{name:"content",type:l.text},{name:"text-outline-color",type:l.color},{name:"text-outline-width",type:l.size},{name:"text-outline-opacity",type:l.zeroOneNumber},{name:"text-opacity",type:l.zeroOneNumber},{name:"text-transform",type:l.textTransform},{name:"font-family",type:l.fontFamily},{name:"font-style",type:l.fontStyle},{name:"font-weight",type:l.fontWeight},{name:"font-size",type:l.size},{name:"min-zoomed-font-size",type:l.size},{name:"display",type:l.display},{name:"visibility",type:l.visibility},{name:"opacity",type:l.zeroOneNumber},{name:"z-index",type:l.nonNegativeInt},{name:"overlay-padding",type:l.size},{name:"overlay-color",type:l.color},{name:"overlay-opacity",type:l.zeroOneNumber},{name:"transition-property",type:l.propList},{name:"transition-duration",type:l.time},{name:"transition-delay",type:l.time},{name:"height",type:l.autoSize},{name:"width",type:l.autoSize},{name:"shape",type:l.nodeShape},{name:"background-color",type:l.color},{name:"background-opacity",type:l.zeroOneNumber},{name:"background-blacken",type:l.nOneOneNumber},{name:"border-color",type:l.color},{name:"border-opacity",type:l.zeroOneNumber},{name:"border-width",type:l.size},{name:"border-style",type:l.borderStyle},{name:"background-image",type:l.url},{name:"background-image-opacity",type:l.zeroOneNumber},{name:"background-position-x",type:l.bgPos},{name:"background-position-y",type:l.bgPos},{name:"background-repeat",type:l.bgRepeat},{name:"background-fit",type:l.bgFit},{name:"background-clip",type:l.bgClip},{name:"padding-left",type:l.size},{name:"padding-right",type:l.size},{name:"padding-top",type:l.size},{name:"padding-bottom",type:l.size},{name:"position",type:l.position},{name:"line-style",type:l.lineStyle},{name:"line-color",type:l.color},{name:"control-point-step-size",type:l.size},{name:"control-point-distance",type:l.number},{name:"control-point-weight",type:l.zeroOneNumber},{name:"curve-style",type:l.curveStyle},{name:"haystack-radius",type:l.zeroOneNumber},{name:"source-arrow-shape",type:l.arrowShape},{name:"target-arrow-shape",type:l.arrowShape},{name:"mid-source-arrow-shape",type:l.arrowShape},{name:"mid-target-arrow-shape",type:l.arrowShape},{name:"source-arrow-color",type:l.color},{name:"target-arrow-color",type:l.color},{name:"mid-source-arrow-color",type:l.color},{name:"mid-target-arrow-color",type:l.color},{name:"source-arrow-fill",type:l.arrowFill},{name:"target-arrow-fill",type:l.arrowFill},{name:"mid-source-arrow-fill",type:l.arrowFill},{name:"mid-target-arrow-fill",type:l.arrowFill},{name:"selection-box-color",type:l.color},{name:"selection-box-opacity",type:l.zeroOneNumber},{name:"selection-box-border-color",type:l.color},{name:"selection-box-border-width",type:l.size},{name:"active-bg-color",type:l.color},{name:"active-bg-opacity",type:l.zeroOneNumber},{name:"active-bg-size",type:l.size},{name:"outside-texture-bg-color",type:l.color},{name:"outside-texture-bg-opacity",type:l.zeroOneNumber}];e.style.pieBackgroundN=16,u.push({name:"pie-size",type:l.bgSize});for(var c=1;c<=e.style.pieBackgroundN;c++)u.push({name:"pie-"+c+"-background-color",type:l.color}),u.push({name:"pie-"+c+"-background-size",type:l.percent}),u.push({name:"pie-"+c+"-background-opacity",type:l.zeroOneNumber});for(var c=0;c<u.length;c++){var d=u[c];u[d.name]=d}}(),e.styfn.addDefaultStylesheet=function(){var t="Helvetica",i="normal",r="normal",n="#000",a="none",o=16;this.selector("node, edge").css({"text-valign":"top","text-halign":"center",color:n,"text-outline-color":"#000","text-outline-width":0,"text-outline-opacity":1,"text-opacity":1,"text-decoration":"none","text-transform":a,"font-family":t,"font-style":i,"font-weight":r,"font-size":o,"min-zoomed-font-size":0,visibility:"visible",display:"element",opacity:1,"z-index":0,content:"","overlay-opacity":0,"overlay-color":"#000","overlay-padding":10,"transition-property":"none","transition-duration":0,"transition-delay":0,"background-blacken":0,"background-color":"#888","background-opacity":1,"background-image":"none","background-image-opacity":1,"background-position-x":"50%","background-position-y":"50%","background-repeat":"no-repeat","background-fit":"none","background-clip":"node","border-color":"#000","border-opacity":1,"border-width":0,"border-style":"solid",height:30,width:30,shape:"ellipse","padding-top":0,"padding-bottom":0,"padding-left":0,"padding-right":0,position:"origin","pie-size":"100%","pie-1-background-color":"black","pie-2-background-color":"black","pie-3-background-color":"black","pie-4-background-color":"black","pie-5-background-color":"black","pie-6-background-color":"black","pie-7-background-color":"black","pie-8-background-color":"black","pie-9-background-color":"black","pie-10-background-color":"black","pie-11-background-color":"black","pie-12-background-color":"black","pie-13-background-color":"black","pie-14-background-color":"black","pie-15-background-color":"black","pie-16-background-color":"black","pie-1-background-size":"0%","pie-2-background-size":"0%","pie-3-background-size":"0%","pie-4-background-size":"0%","pie-5-background-size":"0%","pie-6-background-size":"0%","pie-7-background-size":"0%","pie-8-background-size":"0%","pie-9-background-size":"0%","pie-10-background-size":"0%","pie-11-background-size":"0%","pie-12-background-size":"0%","pie-13-background-size":"0%","pie-14-background-size":"0%","pie-15-background-size":"0%","pie-16-background-size":"0%","pie-1-background-opacity":1,"pie-2-background-opacity":1,"pie-3-background-opacity":1,"pie-4-background-opacity":1,"pie-5-background-opacity":1,"pie-6-background-opacity":1,"pie-7-background-opacity":1,"pie-8-background-opacity":1,"pie-9-background-opacity":1,"pie-10-background-opacity":1,"pie-11-background-opacity":1,"pie-12-background-opacity":1,"pie-13-background-opacity":1,"pie-14-background-opacity":1,"pie-15-background-opacity":1,"pie-16-background-opacity":1,"source-arrow-shape":"none","mid-source-arrow-shape":"none","target-arrow-shape":"none","mid-target-arrow-shape":"none","source-arrow-color":"#ddd","mid-source-arrow-color":"#ddd","target-arrow-color":"#ddd","mid-target-arrow-color":"#ddd","source-arrow-fill":"filled","mid-source-arrow-fill":"filled","target-arrow-fill":"filled","mid-target-arrow-fill":"filled","line-style":"solid","line-color":"#ddd","control-point-step-size":40,"control-point-weight":.5,"curve-style":"bezier","haystack-radius":.8}).selector("$node > node").css({width:"auto",height:"auto",shape:"rectangle","background-opacity":.5,"padding-top":10,"padding-right":10,"padding-left":10,"padding-bottom":10}).selector("edge").css({width:1}).selector(":active").css({"overlay-color":"black","overlay-padding":10,"overlay-opacity":.25}).selector("core").css({"selection-box-color":"#ddd","selection-box-opacity":.65,"selection-box-border-color":"#aaa","selection-box-border-width":1,"active-bg-color":"black","active-bg-opacity":.15,"active-bg-size":e.is.touch()?40:15,"outside-texture-bg-color":"#000","outside-texture-bg-opacity":.125})},e.styfn.clear=function(){for(var e=0;e<this.length;e++)this[e]=void 0;return this.length=0,this._private.newStyle=!0,this},e.styfn.resetToDefault=function(){return this.clear(),this.addDefaultStylesheet(),this},e.styfn.core=function(){return this._private.coreStyle},e.styfn.parse=function(t,i,r,n){t=e.util.camel2dash(t);var a=e.style.properties[t],o=i;if(!a)return null;if(void 0===i||null===i)return null;var s=e.is.string(i);s&&(i=e.util.trim(i));var l=a.type;if(!l)return null;if(r&&(""===i||null===i))return{name:t,value:i,bypass:!0,deleteBypass:!0};var u,c,d,p;if(!s||n);else{if((u=new RegExp(e.style.types.data.regex).exec(i))||(d=new RegExp(e.style.types.layoutData.regex).exec(i))){if(r)return!1;var h=void 0!==d;return u=u||d,{name:t,value:u,strValue:""+i,mapped:h?e.style.types.layoutData:e.style.types.data,field:u[1],bypass:r,hasPie:t.match(/pie-(\\d+)-background-size/)}}if((c=new RegExp(e.style.types.mapData.regex).exec(i))||(p=new RegExp(e.style.types.mapLayoutData.regex).exec(i))){if(r)return!1;var h=void 0!==p;if(c=c||p,!l.color&&!l.number)return!1;var v=this.parse(t,c[4]);if(!v||v.mapped)return!1;var g=this.parse(t,c[5]);if(!g||g.mapped)return!1;if(v.value===g.value)return!1;if(l.color){var f=v.value,y=g.value,m=!(f[0]!==y[0]||f[1]!==y[1]||f[2]!==y[2]||f[3]!==y[3]&&(null!=f[3]&&1!==f[3]||null!=y[3]&&1!==y[3]));if(m)return!1}return{name:t,value:c,strValue:""+i,mapped:h?e.style.types.mapLayoutData:e.style.types.mapData,field:c[1],fieldMin:parseFloat(c[2]),fieldMax:parseFloat(c[3]),valueMin:v.value,valueMax:g.value,bypass:r,hasPie:t.match(/pie-(\\d+)-background-size/)}}}if(l.number){var x,b="px";if(l.units&&(x=l.units),l.implicitUnits&&(b=l.implicitUnits),!l.unitless)if(s){var w="px|em"+(l.allowPercent?"|\\\\%":"");x&&(w=x);var _=i.match("^("+e.util.regex.number+")("+w+")?$");_&&(i=_[1],x=_[2]||b)}else(!x||l.implicitUnits)&&(x=b);if(i=parseFloat(i),isNaN(i)&&void 0===l.enums)return null;if(isNaN(i)&&void 0!==l.enums){i=o;for(var E=0;E<l.enums.length;E++){var S=l.enums[E];if(S===i)return{name:t,value:i,strValue:""+i,bypass:r}}return null}if(l.integer&&!e.is.integer(i))return null;if(void 0!==l.min&&i<l.min||void 0!==l.max&&i>l.max)return null;var P={name:t,value:i,strValue:""+i+(x?x:""),units:x,bypass:r,hasPie:t.match(/pie-(\\d+)-background-size/)&&null!=i&&0!==i&&""!==i};return l.unitless||"px"!==x&&"em"!==x||(P.pxValue="px"!==x&&x?this.getEmSizeInPixels()*i:i),("ms"===x||"s"===x)&&(P.msValue="ms"===x?i:1e3*i),P}if(l.propList){var D=[],k=""+i;if("none"===k);else{for(var C=k.split(","),E=0;E<C.length;E++){var T=e.util.trim(C[E]);e.style.properties[T]&&D.push(T)}if(0===D.length)return null}return{name:t,value:D,strValue:0===D.length?"none":D.join(", "),bypass:r}}if(l.color){var N=e.util.color2tuple(i);return N?{name:t,value:N,strValue:""+i,bypass:r}:null}if(l.enums){for(var E=0;E<l.enums.length;E++){var S=l.enums[E];if(S===i)return{name:t,value:i,strValue:""+i,bypass:r}}return null}if(l.regex){var M=new RegExp(l.regex),B=M.exec(i);return B?{name:t,value:B,strValue:""+i,bypass:r}:null}return l.string?{name:t,value:i,strValue:""+i,bypass:r}:null},e.styfn.selector=function(t){var i="core"===t?null:new e.Selector(t),r=this.length++;return this[r]={selector:i,properties:[],mappedProperties:[],index:r},this},e.styfn.css=function(){var t=arguments;switch(t.length){case 1:for(var i=t[0],r=0;r<e.style.properties.length;r++){var n=e.style.properties[r],a=i[n.name];void 0===a&&(a=i[e.util.dash2camel(n.name)]),void 0!==a&&this.cssRule(n.name,a)}break;case 2:this.cssRule(t[0],t[1])}return this},e.styfn.cssRule=function(e,t){var i=this.parse(e,t);if(i){var r=this.length-1;this[r].properties.push(i),this[r].properties[i.name]=i,i.hasPie&&(this._private.hasPie=!0),i.mapped&&this[r].mappedProperties.push(i);var n=!this[r].selector;n&&(this._private.coreStyle[i.name]=i)}return this}}(cytoscape),function(e){"use strict";e.styfn.apply=function(e){var t=this;t._private.newStyle&&(this._private.contextStyles={},this._private.propDiffs={});for(var i=0;i<e.length;i++){var r=e[i],n=t.getContextMeta(r),a=t.getContextStyle(n),o=t.applyContextStyle(n,a,r);t.updateTransitions(r,o.diffProps),t.updateStyleHints(r)}t._private.newStyle=!1},e.styfn.getPropertiesDiff=function(e,t){var i=this,r=i._private.propDiffs=i._private.propDiffs||{},n=e+"-"+t,a=r[n];if(a)return a;for(var o=[],s={},l=0;l<i.length;l++){var u=i[l],c="t"===e[l],d="t"===t[l],p=c!==d,h=u.mappedProperties.length>0;if(p||h){var v;p&&h?v=u.properties:p?v=u.properties:h&&(v=u.mappedProperties);for(var g=0;g<v.length;g++){for(var f=v[g],y=f.name,m=!1,x=l+1;x<i.length;x++){var b=i[x],w="t"===t[x];if(w&&(m=null!=b.properties[f.name]))break}s[y]||m||(s[y]=!0,o.push(y))}}}return r[n]=o,o},e.styfn.getContextMeta=function(e){var t,i=this,r="",n=e._private.styleCxtKey||"";i._private.newStyle&&(n="");for(var a=0;a<i.length;a++){var o=i[a],s=o.selector&&o.selector.matches(e);r+=s?"t":"f"}return t=i.getPropertiesDiff(n,r),e._private.styleCxtKey=r,{key:r,diffPropNames:t}},e.styfn.getContextStyle=function(e){var t=e.key,i=this,r=this._private.contextStyles=this._private.contextStyles||{};if(r[t])return r[t];for(var n={_private:{key:t}},a=0;a<i.length;a++){var o=i[a],s="t"===t[a];if(s)for(var l=0;l<o.properties.length;l++){var u=o.properties[l],c=n[u.name]=u;c.context=o}}return r[t]=n,n},e.styfn.applyContextStyle=function(e,t,i){for(var r=this,n=e.diffPropNames,a={},o=0;o<n.length;o++){var s=n[o],l=t[s],u=i._private.style[s];if(l&&u!==l){var c=a[s]={prev:u};r.applyParsedProperty(i,l),c.next=i._private.style[s],c.next.bypass&&(c.next=c.next.bypassed)}}return{diffProps:a}},e.styfn.updateStyleHints=function(t){var i=t._private,r=this,n=i.style,a=!1;if("nodes"===i.group&&r._private.hasPie)for(var o=1;o<=e.style.pieBackgroundN;o++){var s=i.style["pie-"+o+"-background-size"].value;if(s>0){a=!0;break}}i.hasPie=a;var l=n["text-transform"].strValue,u=n.content.strValue,c=n["font-style"].strValue,s=n["font-size"].pxValue+"px",d=n["font-family"].strValue,p=n["font-weight"].strValue,h=n["text-valign"].strValue,v=n["text-valign"].strValue,g=n["text-outline-width"].pxValue;i.labelKey=c+"$"+s+"$"+d+"$"+p+"$"+u+"$"+l+"$"+h+"$"+v+"$"+g,i.fontKey=c+"$"+p+"$"+s+"$"+d;var f=n.width.pxValue,y=n.height.pxValue,m=n["border-width"].pxValue;if(i.boundingBoxKey=f+"$"+y+"$"+m,"edges"===t._private.group){var x=n["control-point-step-size"].pxValue,b=n["control-point-distance"]?n["control-point-distance"].pxValue:void 0,w=n["control-point-weight"].value,_=n["curve-style"].strValue;i.boundingBoxKey+="$"+x+"$"+b+"$"+w+"$"+_}i.styleKey=Date.now()},e.styfn.applyParsedProperty=function(t,i){var r,n,a=i,o=t._private.style,s=e.style.properties[a.name].type,l=a.bypass,u=o[a.name],c=u&&u.bypass;if(("height"===i.name||"width"===i.name)&&"auto"===i.value&&t.isNode()&&!t.isParent())return!1;if(l&&a.deleteBypass){var d=o[a.name];return d?d.bypass&&d.bypassed?(o[a.name]=d.bypassed,!0):!1:!0}var p=function(){e.util.error("Do not assign mappings to elements without corresponding data (e.g. ele `"+t.id()+"` for property `"+a.name+"` with data field `"+a.field+"`); try a `["+a.field+"]` selector to limit scope to elements with `"+a.field+"` defined")};switch(a.mapped){case e.style.types.mapData:case e.style.types.mapLayoutData:for(var h=a.mapped===e.style.types.mapLayoutData,v=a.field.split("."),r=h?t._private.layoutData:t._private.data,g=0;g<v.length&&r;g++){var f=v[g];r=r[f]}var y;if(y=e.is.number(r)?(r-a.fieldMin)/(a.fieldMax-a.fieldMin):0,0>y?y=0:y>1&&(y=1),s.color){var m=a.valueMin[0],x=a.valueMax[0],b=a.valueMin[1],w=a.valueMax[1],_=a.valueMin[2],E=a.valueMax[2],S=null==a.valueMin[3]?1:a.valueMin[3],P=null==a.valueMax[3]?1:a.valueMax[3],D=[Math.round(m+(x-m)*y),Math.round(b+(w-b)*y),Math.round(_+(E-_)*y),Math.round(S+(P-S)*y)];n={bypass:a.bypass,name:a.name,value:D,strValue:"rgb("+D[0]+", "+D[1]+", "+D[2]+")"}}else{if(!s.number)return!1;var k=a.valueMin+(a.valueMax-a.valueMin)*y;n=this.parse(a.name,k,a.bypass,!0)}n||(n=this.parse(a.name,u.strValue,a.bypass,!0)),n||p(),n.mapping=a,a=n;break;case e.style.types.data:case e.style.types.layoutData:for(var h=a.mapped===e.style.types.layoutData,v=a.field.split("."),r=h?t._private.layoutData:t._private.data,g=0;g<v.length&&r;g++){var f=v[g];r=r[f]}if(n=this.parse(a.name,r,a.bypass,!0),!n){var C=u?u.strValue:"";n=this.parse(a.name,C,a.bypass,!0)}n||p(),n.mapping=a,a=n;break;case void 0:break;default:return!1}return l?(a.bypassed=c?u.bypassed:u,o[a.name]=a):c?u.bypassed=a:o[a.name]=a,!0},e.styfn.update=function(){var e=this._private.cy,t=e.elements();t.updateStyle()},e.styfn.updateMappers=function(t){for(var i=0;i<t.length;i++){for(var r=t[i],n=r._private.style,a=0;a<e.style.properties.length;a++){var o=e.style.properties[a],s=n[o.name];if(s&&s.mapping){var l=s.mapping;this.applyParsedProperty(r,l)}}this.updateStyleHints(r)}},e.styfn.updateTransitions=function(t,i,r){var n=this,a=t._private.style,o=a["transition-property"].value,s=a["transition-duration"].msValue,l=a["transition-delay"].msValue,u={};if(o.length>0&&s>0){for(var c=!1,d=0;d<o.length;d++){var p=o[d],h=a[p],v=i[p];if(v){var g=v.prev,f=g,y=null!=v.next?v.next:h,m=!1;f&&(e.is.number(f.pxValue)&&e.is.number(y.pxValue)?m=f.pxValue!==y.pxValue:e.is.number(f.value)&&e.is.number(y.value)?m=f.value!==y.value:e.is.array(f.value)&&e.is.array(y.value)&&(m=f.value[0]!==y.value[0]||f.value[1]!==y.value[1]||f.value[2]!==y.value[2]),m&&(u[p]=y.strValue,this.applyBypass(t,p,f.strValue),c=!0))}}if(!c)return;t._private.transitioning=!0,t.stop(),l>0&&t.delay(l),t.animate({css:u},{duration:s,queue:!1,complete:function(){r||n.removeBypasses(t,o),t._private.transitioning=!1}})}else t._private.transitioning&&(t.stop(),this.removeBypasses(t,o),t._private.transitioning=!1)}}(cytoscape),function(e){"use strict";e.styfn.applyBypass=function(t,i,r,n){var a=[],o=!0;if("*"===i||"**"===i){if(void 0!==r)for(var s=0;s<e.style.properties.length;s++){var l=e.style.properties[s],i=l.name,u=this.parse(i,r,!0);u&&a.push(u)}}else if(e.is.string(i)){var u=this.parse(i,r,!0);u&&a.push(u)}else{if(!e.is.plainObject(i))return!1;var c=i;n=r;for(var s=0;s<e.style.properties.length;s++){var l=e.style.properties[s],i=l.name,r=c[i];if(void 0===r&&(r=c[e.util.dash2camel(i)]),void 0!==r){var u=this.parse(i,r,!0);u&&a.push(u)}}}if(0===a.length)return!1;for(var d=!1,s=0;s<t.length;s++){for(var p,h=t[s],v=h._private.style,g={},f=0;f<a.length;f++){var l=a[f];if(n){var y=v[l.name];p=g[l.name]={prev:y}}d=this.applyParsedProperty(h,l)||d,n&&(p.next=v[l.name])}n&&this.updateTransitions(h,g,o)}return d},e.styfn.overrideBypass=function(t,i,r){for(var n=0;n<t.length;n++){var a=t[n],o=a._private.style[e.util.camel2dash(i)];o.bypass?(o.value=r,o.pxValue=r):this.applyBypass(a,i,r)}},e.styfn.removeAllBypasses=function(t,i){for(var r=!0,n=0;n<t.length;n++){for(var a=t[n],o={},s=a._private.style,l=0;l<e.style.properties.length;l++){var u=e.style.properties[l],c=u.name,d="",p=this.parse(c,d,!0),h=s[u.name],v=o[u.name]={prev:h};this.applyParsedProperty(a,p),v.next=s[u.name]}i&&this.updateTransitions(a,o,r)}},e.styfn.removeBypasses=function(t,i,r){for(var n=!0,a=0;a<t.length;a++){for(var o=t[a],s={},l=o._private.style,u=0;u<i.length;u++){var c=i[u],d=e.style.properties[c],p="",h=this.parse(c,p,!0),v=l[d.name],g=s[d.name]={prev:v};this.applyParsedProperty(o,h),g.next=l[d.name]}r&&this.updateTransitions(o,s,n)}}}(cytoscape),function(e,t){"use strict";\ne.styfn.getEmSizeInPixels=function(){var e=this._private.cy,i=e.container();if(t&&i&&t.getComputedStyle){var r=t.getComputedStyle(i).getPropertyValue("font-size"),n=parseFloat(r);return n}return 1},e.styfn.containerCss=function(e){var i=this._private.cy,r=i.container();return t&&r&&t.getComputedStyle?t.getComputedStyle(r).getPropertyValue(e):void 0},e.styfn.containerProperty=function(e){var t=this.containerCss(e),i=this.parse(e,t);return i},e.styfn.containerPropertyAsString=function(e){var t=this.containerProperty(e);return t?t.strValue:void 0}}(cytoscape,"undefined"==typeof window?null:window),function(e){"use strict";e.styfn.getRenderedStyle=function(t){var t=t[0];if(t){for(var i={},r=t._private.style,n=this._private.cy,a=n.zoom(),o=0;o<e.style.properties.length;o++){var s=e.style.properties[o],l=r[s.name];if(l){var u=l.unitless?l.strValue:l.pxValue*a+"px";i[s.name]=u,i[e.util.dash2camel(s.name)]=u}}return i}},e.styfn.getRawStyle=function(t){var t=t[0];if(t){for(var i={},r=t._private.style,n=0;n<e.style.properties.length;n++){var a=e.style.properties[n],o=r[a.name];o&&(i[a.name]=o.strValue,i[e.util.dash2camel(a.name)]=o.strValue)}return i}},e.styfn.getValueStyle=function(t,i){i=i||{};var r,n=i.array?[]:{};if(r=e.is.element(t)?t._private.style:t)for(var a=0;a<e.style.properties.length;a++){var o=e.style.properties[a],s=r[o.name]||r[e.util.dash2camel(o.name)];void 0===s||e.is.plainObject(s)||(s=this.parse(o.name,s)),s&&(i.array?n.push(s):(n[o.name]=s,n[e.util.dash2camel(o.name)]=s))}return n}}(cytoscape),function(e){"use strict";e.style.applyFromJson=function(e,t){for(var i=0;i<t.length;i++){var r=t[i],n=r.selector,a=r.css;e.selector(n);for(var o in a){var s=a[o];e.css(o,s)}}return e},e.style.fromJson=function(t,i){var r=new e.Style(t);return e.style.applyFromJson(r,i),r},e.styfn.fromJson=function(t){var i=this;return i.resetToDefault(),e.style.applyFromJson(i,t),i},e.styfn.json=function(){for(var e=[],t=0;t<this.length;t++){for(var i=this[t],r=i.selector,n=i.properties,a={},o=0;o<n.length;o++){var s=n[o];a[s.name]=s.strValue}e.push({selector:r?r.toString():"core",css:a})}return e}}(cytoscape),function(e){"use strict";e.style.applyFromString=function(t,i){function r(){l=l.length>a.length?l.substr(a.length):""}function n(){o=o.length>s.length?o.substr(s.length):""}var a,o,s,l=""+i;for(l=l.replace(/[/][*](\\s|.)+?[*][/]/g,"");;){var u=l.match(/^\\s*$/);if(u)break;var c=l.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);if(!c){e.util.error("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: "+l);break}a=c[0];var d=c[1],p=new e.Selector(d);if(p._private.invalid&&"core"!==d)e.util.error("Skipping parsing of block: Invalid selector found in string stylesheet: "+d),r();else{var h=c[2],v=!1;o=h;for(var g=[];;){var u=o.match(/^\\s*$/);if(u)break;var f=o.match(/^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/);if(!f){e.util.error("Skipping parsing of block: Invalid formatting of style property and value definitions found in:"+h),v=!0;break}s=f[0];var y=f[1],m=f[2],x=e.style.properties[y];if(x){var b=t.parse(y,m);b?(g.push({name:y,val:m}),n()):(e.util.error("Skipping property: Invalid property definition in: "+s),n())}else e.util.error("Skipping property: Invalid property name in: "+s),n()}if(v){r();break}t.selector(d);for(var w=0;w<g.length;w++){var x=g[w];t.css(x.name,x.val)}r()}}return t},e.style.fromString=function(t,i){var r=new e.Style(t);return e.style.applyFromString(r,i),r},e.styfn.fromString=function(t){var i=this;return i.resetToDefault(),e.style.applyFromString(i,t),i}}(cytoscape),function(e){"use strict";e.stylesheet=e.Stylesheet=function(){return this instanceof e.Stylesheet?void(this.length=0):new e.Stylesheet},e.Stylesheet.prototype.selector=function(e){var t=this.length++;return this[t]={selector:e,properties:[]},this},e.Stylesheet.prototype.css=function(t,i){var r=this.length-1;if(e.is.string(t))this[r].properties.push({name:t,value:i});else if(e.is.plainObject(t))for(var n=t,a=0;a<e.style.properties.length;a++){var o=e.style.properties[a],s=n[o.name];if(void 0===s&&(s=n[e.util.dash2camel(o.name)]),void 0!==s){var t=o.name,i=s;this[r].properties.push({name:t,value:i})}}return this},e.Stylesheet.prototype.generateStyle=function(t){for(var i=new e.Style(t),r=0;r<this.length;r++){var n=this[r],a=n.selector,o=n.properties;i.selector(a);for(var s=0;s<o.length;s++){var l=o[s];i.css(l.name,l.value)}}return i}}(cytoscape),function(e,t){"use strict";var i=e.is.touch(),r={},n=e.util.copy(r);e.defaults=function(t){r=e.util.extend({},n,t)},e.fn.core=function(t){for(var i in t){var r=t[i];e.Core.prototype[i]=r}},e.Core=function(n){if(!(this instanceof e.Core))return new e.Core(n);var a=this;n=e.util.extend({},r,n);var o=n.container,s=o?o._cyreg:null;if(s=s||{},s&&s.cy){if(o)for(;o.firstChild;)o.removeChild(o.firstChild);s.cy.notify({type:"destroy"}),s={}}var l=s.readies=s.readies||[];o&&(o._cyreg=s),s.cy=a;var u=void 0!==t&&void 0!==o&&!n.headless,c=n;c.layout=e.util.extend({name:u?"grid":"null"},c.layout),c.renderer=e.util.extend({name:u?"canvas":"null"},c.renderer);var d=function(e,t,i){return void 0!==t?t:void 0!==i?i:e},p=this._private={container:c.container,ready:!1,initrender:!1,options:c,elements:[],id2index:{},listeners:[],aniEles:e.Collection(this),scratch:{},layout:null,renderer:null,notificationsEnabled:!0,minZoom:1e-50,maxZoom:1e50,zoomingEnabled:d(!0,c.zoomingEnabled),userZoomingEnabled:d(!0,c.userZoomingEnabled),panningEnabled:d(!0,c.panningEnabled),userPanningEnabled:d(!0,c.userPanningEnabled),boxSelectionEnabled:d(!1,c.boxSelectionEnabled),autolock:d(!1,c.autolock,c.autolockNodes),autoungrabify:d(!1,c.autoungrabify,c.autoungrabifyNodes),autounselectify:d(!1,c.autounselectify),styleEnabled:void 0===c.styleEnabled?u:c.styleEnabled,zoom:e.is.number(c.zoom)?c.zoom:1,pan:{x:e.is.plainObject(c.pan)&&e.is.number(c.pan.x)?c.pan.x:0,y:e.is.plainObject(c.pan)&&e.is.number(c.pan.y)?c.pan.y:0},animation:{current:[],queue:[]},hasCompoundNodes:!1,deferredExecQueue:[]},h=c.selectionType;p.selectionType=void 0===h||"additive"!==h&&"single"!==h?i?"additive":"single":h,e.is.number(c.minZoom)&&e.is.number(c.maxZoom)&&c.minZoom<c.maxZoom?(p.minZoom=c.minZoom,p.maxZoom=c.maxZoom):e.is.number(c.minZoom)&&void 0===c.maxZoom?p.minZoom=c.minZoom:e.is.number(c.maxZoom)&&void 0===c.minZoom&&(p.maxZoom=c.maxZoom),p.styleEnabled&&this.setStyle(c.style),a.initRenderer(e.util.extend({hideEdgesOnViewport:c.hideEdgesOnViewport,hideLabelsOnViewport:c.hideLabelsOnViewport,textureOnViewport:c.textureOnViewport,wheelSensitivity:e.is.number(c.wheelSensitivity)&&c.wheelSensitivity>0?c.wheelSensitivity:1,motionBlur:c.motionBlur,pixelRatio:e.is.number(c.pixelRatio)&&c.pixelRatio>0?c.pixelRatio:"auto"===c.pixelRatio?void 0:1,tapThreshold:d(e.is.touch()?8:4,e.is.touch()?c.touchTapThreshold:c.desktopTapThreshold)},c.renderer)),c.initrender&&(a.on("initrender",c.initrender),a.on("initrender",function(){a._private.initrender=!0})),a.load(c.elements,function(){a.startAnimationLoop(),a._private.ready=!0,e.is.fn(c.ready)&&a.on("ready",c.ready);for(var t=0;t<l.length;t++){var i=l[t];a.on("ready",i)}s&&(s.readies=[]),a.trigger("ready")},c.done)},e.corefn=e.Core.prototype,e.fn.core({isReady:function(){return this._private.ready},ready:function(e){this.isReady()?this.trigger("ready",[],e):this.on("ready",e)},initrender:function(){return this._private.initrender},destroy:function(){this.notify({type:"destroy"});var e=this.container(),t=e.parentNode;return t&&t.removeChild(e),this},getElementById:function(t){var i=this._private.id2index[t];return void 0!==i?this._private.elements[i]:new e.Collection(this)},selectionType:function(){return this._private.selectionType},hasCompoundNodes:function(){return this._private.hasCompoundNodes},styleEnabled:function(){return this._private.styleEnabled},addToPool:function(e){for(var t=this._private.elements,i=this._private.id2index,r=0;r<e.length;r++){var n=e[r],a=n._private.data.id,o=i[a],s=void 0!==o;s||(o=t.length,t.push(n),i[a]=o,n._private.index=o)}return this},removeFromPool:function(e){for(var t=this._private.elements,i=this._private.id2index,r=0;r<e.length;r++){var n=e[r],a=n._private.data.id,o=i[a],s=void 0!==o;if(s){this._private.id2index[a]=void 0,t.splice(o,1);for(var l=o;l<t.length;l++){var u=t[l]._private.data.id;i[u]--}}}},container:function(){return this._private.container},options:function(){return e.util.copy(this._private.options)},json:function(){var e={},t=this;return e.elements={},t.elements().each(function(t,i){var r=i.group();e.elements[r]||(e.elements[r]=[]),e.elements[r].push(i.json())}),this._private.styleEnabled&&(e.style=t.style().json()),e.zoomingEnabled=t._private.zoomingEnabled,e.userZoomingEnabled=t._private.userZoomingEnabled,e.zoom=t._private.zoom,e.minZoom=t._private.minZoom,e.maxZoom=t._private.maxZoom,e.panningEnabled=t._private.panningEnabled,e.userPanningEnabled=t._private.userPanningEnabled,e.pan=t._private.pan,e.boxSelectionEnabled=t._private.boxSelectionEnabled,e.layout=t._private.options.layout,e.renderer=t._private.options.renderer,e.hideEdgesOnViewport=t._private.options.hideEdgesOnViewport,e.hideLabelsOnViewport=t._private.options.hideLabelsOnViewport,e.textureOnViewport=t._private.options.textureOnViewport,e.wheelSensitivity=t._private.options.wheelSensitivity,e.motionBlur=t._private.options.motionBlur,e},defer:function(e){var t=this,i=t._private,r=i.deferredExecQueue;r.push(e),i.deferredTimeout||(i.deferredTimeout=setTimeout(function(){for(;r.length>0;)r.shift()();i.deferredTimeout=null},0))}})}(cytoscape,"undefined"==typeof window?null:window),function(e,t){"use strict";function i(e){var t=!document||"interactive"!==document.readyState&&"complete"!==document.readyState?i:e;setTimeout(t,9,e)}e.fn.core({add:function(t){var i,r=this;if(e.is.elementOrCollection(t)){var n=t;if(n._private.cy===r)i=n.restore();else{for(var a=[],o=0;o<n.length;o++){var s=n[o];a.push(s.json())}i=new e.Collection(r,a)}}else if(e.is.array(t)){var a=t;i=new e.Collection(r,a)}else if(e.is.plainObject(t)&&(e.is.array(t.nodes)||e.is.array(t.edges))){for(var l=t,a=[],u=["nodes","edges"],o=0,c=u.length;c>o;o++){var d=u[o],p=l[d];if(e.is.array(p))for(var h=0,v=p.length;v>h;h++){var g=p[h];g.group=d,a.push(g)}}i=new e.Collection(r,a)}else{var g=t;i=new e.Element(r,g).collection()}return i},remove:function(t){if(e.is.elementOrCollection(t))t=t;else if(e.is.string(t)){var i=t;t=this.$(i)}return t.remove()},load:function(r,n,a){function o(){s.one("layoutready",function(e){s.notifications(!0),s.trigger(e),s.notify({type:"load",collection:s.elements()}),s.one("load",n),s.trigger("load")}).one("layoutstop",function(){s.one("done",a),s.trigger("done")});var t=e.util.extend({},s._private.options.layout);t.eles=s.$(),s.layout(t)}var s=this,l=s.elements();return l.length>0&&l.remove(),s.notifications(!1),null!=r&&(e.is.plainObject(r)||e.is.array(r))&&s.add(r),t?i(o):o(),this}})}(cytoscape,"undefined"==typeof window?null:window),function(e,t){"use strict";e.fn.core({animated:e.define.animated(),clearQueue:e.define.clearQueue(),delay:e.define.delay(),animate:e.define.animate(),stop:e.define.stop(),addToAnimationPool:function(e){var t=this;t.styleEnabled()&&t._private.aniEles.merge(e)},startAnimationLoop:function(){function i(){e.util.requestAnimationFrame(function(e){r(e),i()})}function r(t){function i(i,r){var s=i._private.animation.current,l=i._private.animation.queue,u=!1;if(0===s.length){var c=l.length>0?l.shift():null;c&&(c.callTime=t,s.push(c))}for(var d=[],p=s.length-1;p>=0;p--){var h=s[p];h.started||n(i,h),a(i,h,t,r),h.done&&(d.push(h),s.splice(p,1)),u=!0}for(var p=0;p<d.length;p++){var h=d[p],v=h.params.complete;e.is.fn(v)&&v.apply(i,[t])}return r||0!==s.length||0!==l.length||o.push(i),u}t=+new Date;for(var r=l._private.aniEles,o=[],s=0;s<r.length;s++){var u=r[s];i(u)}var c=i(l,!0);if(r.length>0||c){var d;if(r.length>0){var p=r.updateCompoundBounds();d=p.length>0?r.add(p):r}l.notify({type:"draw",collection:d})}r.unmerge(o)}function n(t,i){var r=e.is.core(t),n=!r,a=t,o=l._private.style;if(n)var s=a._private.position,u={x:s.x,y:s.y},c=o.getValueStyle(a);if(r)var d=l._private.pan,p={x:d.x,y:d.y},h=l._private.zoom;i.started=!0,i.startTime=Date.now(),i.startPosition=u,i.startStyle=c,i.startPan=p,i.startZoom=h}function a(t,i,r,n){var a,u=l._private.style,c=i.properties,d=i.params,p=i.startTime,h=!n;if(a=0===i.duration?1:Math.min(1,(r-p)/i.duration),0>a?a=0:a>1&&(a=1),null==c.delay){var v=i.startPosition,g=c.position,f=t._private.position;g&&h&&(o(v.x,g.x)&&(f.x=s(v.x,g.x,a)),o(v.y,g.y)&&(f.y=s(v.y,g.y,a)));var y=i.startPan,m=c.pan,x=t._private.pan,b=null!=m&&n;b&&(o(y.x,m.x)&&(x.x=s(y.x,m.x,a)),o(y.y,m.y)&&(x.y=s(y.y,m.y,a)),t.trigger("pan"));var w=i.startZoom,_=c.zoom,E=null!=_&&n;if(E&&(o(w,_)&&(t._private.zoom=s(w,_,a)),t.trigger("zoom")),(b||E)&&t.trigger("viewport"),c.css&&h)for(var S=c.css,P=0;P<S.length;P++){var D=S[P].name,k=S[P],C=k,T=i.startStyle[D],N=s(T,C,a);u.overrideBypass(t,D,N)}}return e.is.fn(d.step)&&d.step.apply(t,[r]),a>=1&&(i.done=!0),a}function o(t,i){return null==t||null==i?!1:e.is.number(t)&&e.is.number(i)?!0:t&&i?!0:!1}function s(t,i,r){0>r?r=0:r>1&&(r=1);var n,a;if(n=null!=t.pxValue||null!=t.value?null!=t.pxValue?t.pxValue:t.value:t,a=null!=i.pxValue||null!=i.value?null!=i.pxValue?i.pxValue:i.value:i,e.is.number(n)&&e.is.number(a))return n+(a-n)*r;if(e.is.number(n[0])&&e.is.number(a[0])){var o=n,s=a,l=function(e,t){var i=t-e,n=e;return Math.round(r*i+n)},u=l(o[0],s[0]),c=l(o[1],s[1]),d=l(o[2],s[2]);return[u,c,d]}return void 0}var l=this;l.styleEnabled()&&t&&i()}})}(cytoscape,"undefined"==typeof window?null:window),function(e){"use strict";e.fn.core({data:e.define.data({field:"data",bindingEvent:"data",allowBinding:!0,allowSetting:!0,settingEvent:"data",settingTriggersEvent:!0,triggerFnName:"trigger",allowGetting:!0}),removeData:e.define.removeData({field:"data",event:"data",triggerFnName:"trigger",triggerEvent:!0}),scratch:e.define.data({field:"scratch",allowBinding:!1,allowSetting:!0,settingTriggersEvent:!1,allowGetting:!0}),removeScratch:e.define.removeData({field:"scratch",triggerEvent:!1})})}(cytoscape),function(e){"use strict";e.fn.core({on:e.define.on(),one:e.define.on({unbindSelfOnTrigger:!0}),once:e.define.on({unbindAllBindersOnTrigger:!0}),off:e.define.off(),trigger:e.define.trigger()}),e.corefn.bind=e.corefn.on,e.corefn.unbind=e.corefn.off}(cytoscape),function(e){"use strict";e.fn.core({png:function(e){var t=this._private.renderer;return e=e||{},t.png(e)}})}(cytoscape),function(e){"use strict";e.fn.core({layout:function(e){var t=this._private.prevLayout=null==e?this._private.prevLayout:this.initLayout(e);return t.run(),this},makeLayout:function(e){return this.initLayout(e)},initLayout:function(t){if(null==t)return void e.util.error("Layout options must be specified to make a layout");if(null==t.name)return void e.util.error("A `name` must be specified to make a layout");var i=t.name,r=e.extension("layout",i);if(null==r)return void e.util.error("Can not apply layout: No such layout `"+i+"` found; did you include its JS file?");t.eles=null!=t.eles?t.eles:this.$(),e.is.string(t.eles)&&(t.eles=this.$(t.eles));var n=new r(e.util.extend({},t,{cy:this}));return e.is.plainObject(n._private)||(n._private={}),n._private.cy=this,n._private.listeners=[],n}})}(cytoscape),function(e){"use strict";e.fn.core({notify:function(e){if(this._private.batchingNotify){var t=this._private.batchNotifyEles,i=this._private.batchNotifyTypes;if(e.collection)for(var r=0;r<e.collection.length;r++){var n=e.collection[r];t.ids[n._private.id]||t.push(n)}return void(i.ids[e.type]||i.push(e.type))}if(this._private.notificationsEnabled){var a=this.renderer();a.notify(e)}},notifications:function(e){var t=this._private;return void 0===e?t.notificationsEnabled:void(t.notificationsEnabled=e?!0:!1)},noNotifications:function(e){this.notifications(!1),e(),this.notifications(!0)},startBatch:function(){var e=this._private;return e.batchingStyle=e.batchingNotify=!0,e.batchStyleEles=[],e.batchNotifyEles=[],e.batchNotifyTypes=[],e.batchStyleEles.ids={},e.batchNotifyEles.ids={},e.batchNotifyTypes.ids={},this},endBatch:function(){var t=this._private;return t.batchingStyle=!1,new e.Collection(this,t.batchStyleEles).updateStyle(),t.batchingNotify=!1,this.notify({type:t.batchNotifyTypes,collection:t.batchNotifyEles}),this},batch:function(e){return this.startBatch(),e(),this.endBatch(),this},batchData:function(e){var t=this;return this.batch(function(){for(var i in e){var r=e[i],n=t.getElementById(i);n.data(r)}})}})}(cytoscape),function(e){"use strict";e.fn.core({renderTo:function(e,t,i,r){var n=this._private.renderer;return n.renderTo(e,t,i,r),this},renderer:function(){return this._private.renderer},forceRender:function(){return this.notify({type:"draw"}),this},resize:function(){return this.notify({type:"resize"}),this.trigger("resize"),this},initRenderer:function(t){var i=this,r=e.extension("renderer",t.name);return null==r?void e.util.error("Can not initialise: No such renderer `%s` found; did you include its JS file?",t.name):void(this._private.renderer=new r(e.util.extend({},t,{cy:i,style:i._private.style})))}})}(cytoscape),function(e){"use strict";e.fn.core({collection:function(t){return e.is.string(t)?this.$(t):e.is.elementOrCollection(t)?t.collection():e.is.array(t)?new e.Collection(this,t):new e.Collection(this)},nodes:function(e){var t=this.$(function(){return this.isNode()});return e?t.filter(e):t},edges:function(e){var t=this.$(function(){return this.isEdge()});return e?t.filter(e):t},$:function(t){var i=new e.Collection(this,this._private.elements);return t?i.filter(t):i}}),e.corefn.elements=e.corefn.filter=e.corefn.$}(cytoscape),function(e){"use strict";e.fn.core({style:function(e){if(e){var t=this.setStyle(e);t.update()}return this._private.style},setStyle:function(t){var i=this._private;return i.style=e.is.stylesheet(t)?t.generateStyle(this):e.is.array(t)?e.style.fromJson(this,t):e.is.string(t)?e.style.fromString(this,t):new e.Style(this),i.style}})}(cytoscape),function(e){"use strict";e.fn.core({autolock:function(e){return void 0===e?this._private.autolock:(this._private.autolock=e?!0:!1,this)},autoungrabify:function(e){return void 0===e?this._private.autoungrabify:(this._private.autoungrabify=e?!0:!1,this)},autounselectify:function(e){return void 0===e?this._private.autounselectify:(this._private.autounselectify=e?!0:!1,this)},panningEnabled:function(e){return void 0===e?this._private.panningEnabled:(this._private.panningEnabled=e?!0:!1,this)},userPanningEnabled:function(e){return void 0===e?this._private.userPanningEnabled:(this._private.userPanningEnabled=e?!0:!1,this)},zoomingEnabled:function(e){return void 0===e?this._private.zoomingEnabled:(this._private.zoomingEnabled=e?!0:!1,this)},userZoomingEnabled:function(e){return void 0===e?this._private.userZoomingEnabled:(this._private.userZoomingEnabled=e?!0:!1,this)},boxSelectionEnabled:function(e){return void 0===e?this._private.boxSelectionEnabled:(this._private.boxSelectionEnabled=e?!0:!1,this)},pan:function(){var t,i,r,n,a,o=arguments,s=this._private.pan;switch(o.length){case 0:return s;case 1:if(e.is.string(o[0]))return t=o[0],s[t];if(e.is.plainObject(o[0])){if(!this._private.panningEnabled)return this;r=o[0],n=r.x,a=r.y,e.is.number(n)&&(s.x=n),e.is.number(a)&&(s.y=a),this.trigger("pan viewport")}break;case 2:if(!this._private.panningEnabled)return this;t=o[0],i=o[1],"x"!==t&&"y"!==t||!e.is.number(i)||(s[t]=i),this.trigger("pan viewport")}return this.notify({type:"viewport"}),this},panBy:function(){var t,i,r,n,a,o=arguments,s=this._private.pan;if(!this._private.panningEnabled)return this;switch(o.length){case 1:e.is.plainObject(o[0])&&(r=o[0],n=r.x,a=r.y,e.is.number(n)&&(s.x+=n),e.is.number(a)&&(s.y+=a),this.trigger("pan viewport"));break;case 2:t=o[0],i=o[1],"x"!==t&&"y"!==t||!e.is.number(i)||(s[t]+=i),this.trigger("pan viewport")}return this.notify({type:"viewport"}),this},fit:function(e,t){var i=this.getFitViewport(e,t);if(i){var r=this._private;r.zoom=i.zoom,r.pan=i.pan,this.trigger("pan zoom viewport"),this.notify({type:"viewport"})}return this},getFitViewport:function(t,i){if(e.is.number(t)&&void 0===i&&(i=t,t=void 0),this._private.panningEnabled&&this._private.zoomingEnabled){var r;if(e.is.string(t)){var n=t;t=this.$(n)}else if(e.is.boundingBox(t)){var a=t;r={x1:a.x1,y1:a.y1,x2:a.x2,y2:a.y2},r.w=r.x2-r.x1,r.h=r.y2-r.y1}else e.is.elementOrCollection(t)||(t=this.elements());r=r||t.boundingBox();var o,s=this.width(),l=this.height();if(i=e.is.number(i)?i:0,!isNaN(s)&&!isNaN(l)&&s>0&&l>0&&!isNaN(r.w)&&!isNaN(r.h)&&r.w>0&&r.h>0){o=Math.min((s-2*i)/r.w,(l-2*i)/r.h),o=o>this._private.maxZoom?this._private.maxZoom:o,o=o<this._private.minZoom?this._private.minZoom:o;var u={x:(s-o*(r.x1+r.x2))/2,y:(l-o*(r.y1+r.y2))/2};return{zoom:o,pan:u}}}},minZoom:function(t){return void 0===t?this._private.minZoom:(e.is.number(t)&&(this._private.minZoom=t),this)},maxZoom:function(t){return void 0===t?this._private.maxZoom:(e.is.number(t)&&(this._private.maxZoom=t),this)},zoom:function(t){var i,r;if(void 0===t)return this._private.zoom;if(e.is.number(t))r=t;else if(e.is.plainObject(t)){if(r=t.level,t.position){var n=t.position,a=this._private.pan,o=this._private.zoom;i={x:n.x*o+a.x,y:n.y*o+a.y}}else t.renderedPosition&&(i=t.renderedPosition);if(i&&!this._private.panningEnabled)return this}if(!this._private.zoomingEnabled)return this;if(!e.is.number(r)||i&&(!e.is.number(i.x)||!e.is.number(i.y)))return this;if(r=r>this._private.maxZoom?this._private.maxZoom:r,r=r<this._private.minZoom?this._private.minZoom:r,i){var s=this._private.pan,l=this._private.zoom,u=r,c={x:-u/l*(i.x-s.x)+i.x,y:-u/l*(i.y-s.y)+i.y};this._private.zoom=r,this._private.pan=c;var d=s.x!==c.x||s.y!==c.y;this.trigger(" zoom "+(d?" pan ":"")+" viewport ")}else this._private.zoom=r,this.trigger("zoom viewport");return this.notify({type:"viewport"}),this},viewport:function(t){var i=this._private,r=!0,n=!0,a=[],o=!1,s=!1;if(!t)return this;if(e.is.number(t.zoom)||(r=!1),e.is.plainObject(t.pan)||(n=!1),!r&&!n)return this;if(r){var l=t.zoom;l<i.minZoom||l>i.maxZoom||!i.zoomingEnabled?o=!0:(i.zoom=l,a.push("zoom"))}if(n&&(!o||!t.cancelOnFailedZoom)&&i.panningEnabled){var u=t.pan;e.is.number(u.x)&&(i.pan.x=u.x,s=!1),e.is.number(u.y)&&(i.pan.y=u.y,s=!1),s||a.push("pan")}return a.length>0&&(a.push("viewport"),this.trigger(a.join(" ")),this.notify({type:"viewport"})),this},center:function(e){var t=this.getCenterPan(e);return t&&(this._private.pan=t,this.trigger("pan viewport"),this.notify({type:"viewport"})),this},getCenterPan:function(t,i){if(this._private.panningEnabled){if(e.is.string(t)){var r=t;t=this.elements(r)}else e.is.elementOrCollection(t)||(t=this.elements());var n=t.boundingBox(),a=this.width(),o=this.height();i=void 0===i?this._private.zoom:i;var s={x:(a-i*(n.x1+n.x2))/2,y:(o-i*(n.y1+n.y2))/2};return s}},reset:function(){return this._private.panningEnabled&&this._private.zoomingEnabled?(this.viewport({pan:{x:0,y:0},zoom:1}),this):this},width:function(){var e=this._private.container;return e?e.clientWidth:1},height:function(){var e=this._private.container;return e?e.clientHeight:1},extent:function(){var e=this._private.pan,t=this._private.zoom,i=this.renderedExtent(),r={x1:(i.x1-e.x)/t,x2:(i.x2-e.x)/t,y1:(i.y1-e.y)/t,y2:(i.y2-e.y)/t};return r.w=r.x2-r.x1,r.h=r.y2-r.y1,r},renderedExtent:function(){var e=this.width(),t=this.height();return{x1:0,y1:0,x2:e,y2:t,w:e,h:t}}}),e.corefn.centre=e.corefn.center,e.corefn.autolockNodes=e.corefn.autolock,e.corefn.autoungrabifyNodes=e.corefn.autoungrabify}(cytoscape),function(e){"use strict";e.fn.collection=e.fn.eles=function(t){for(var i in t){var r=t[i];e.Collection.prototype[i]=r}};var t={prefix:{nodes:"n",edges:"e"},id:{nodes:0,edges:0},generate:function(t,i,r){var n=e.is.element(i)?i._private:i,a=n.group,o=null!=r?r:this.prefix[a]+this.id[a];if(t.getElementById(o).empty())this.id[a]++;else for(;!t.getElementById(o).empty();)o=this.prefix[a]+ ++this.id[a];return o}};e.Element=function(t,i,r){if(!(this instanceof e.Element))return new e.Element(t,i,r);var n=this;if(r=void 0===r||r?!0:!1,void 0===t||void 0===i||!e.is.core(t))return void e.util.error("An element must have a core reference and parameters set");if("nodes"!==i.group&&"edges"!==i.group)return void e.util.error("An element must be of type `nodes` or `edges`; you specified `"+i.group+"`");if(this.length=1,this[0]=this,this._private={cy:t,single:!0,data:i.data||{},layoutData:{},position:i.position||{},autoWidth:void 0,autoHeight:void 0,listeners:[],group:i.group,style:{},rstyle:{},styleCxts:[],removed:!0,selected:i.selected?!0:!1,selectable:void 0===i.selectable?!0:i.selectable?!0:!1,locked:i.locked?!0:!1,grabbed:!1,grabbable:void 0===i.grabbable?!0:i.grabbable?!0:!1,active:!1,classes:{},animation:{current:[],queue:[]},rscratch:{},scratch:{},edges:[],children:[]},i.renderedPosition){var a=i.renderedPosition,o=t.pan(),s=t.zoom();this._private.position={x:(a.x-o.x)/s,y:(a.y-o.y)/s}}if(e.is.string(i.classes))for(var l=i.classes.split(/\\s+/),u=0,c=l.length;c>u;u++){var d=l[u];d&&""!==d&&(n._private.classes[d]=!0)}i.css&&t.style().applyBypass(this,i.css),(void 0===r||r)&&this.restore()},e.Collection=function(i,r,n){if(!(this instanceof e.Collection))return new e.Collection(i,r);if(void 0===i||!e.is.core(i))return void e.util.error("A collection must have a reference to the core");var a={},o={},s=!1;if(r){if(r.length>0&&e.is.plainObject(r[0])&&!e.is.element(r[0])){s=!0;for(var l=[],u={},c=0,d=r.length;d>c;c++){var p=r[c];null==p.data&&(p.data={});var h=p.data;if(null==h.id)h.id=t.generate(i,p);else if(0!==i.getElementById(h.id).length||u[h.id])continue;var v=new e.Element(i,p,!1);l.push(v),u[h.id]=!0}r=l}}else r=[];this.length=0;for(var c=0,d=r.length;d>c;c++){var g=r[c];if(g){var f=g._private.data.id;(!n||n.unique&&!a[f])&&(a[f]=g,o[f]=this.length,this[this.length]=g,this.length++)}}this._private={cy:i,ids:a,indexes:o},s&&this.restore()},e.elefn=e.elesfn=e.Element.prototype=e.Collection.prototype,e.elesfn.cy=function(){return this._private.cy},e.elesfn.element=function(){return this[0]},e.elesfn.collection=function(){return e.is.collection(this)?this:new e.Collection(this._private.cy,[this])},e.elesfn.unique=function(){return new e.Collection(this._private.cy,this,{unique:!0})},e.elesfn.getElementById=function(t){var i=this._private.cy,r=this._private.ids[t];return r?r:e.Collection(i)},e.elesfn.json=function(){var t=this.element();if(null==t)return void 0;var i=t._private,r=e.util.copy({data:i.data,position:i.position,group:i.group,bypass:i.bypass,removed:i.removed,selected:i.selected,selectable:i.selectable,locked:i.locked,grabbed:i.grabbed,grabbable:i.grabbable,classes:""}),n=[];for(var a in i.classes)i.classes[a]&&n.push(a);for(var o=0;o<n.length;o++){var a=n[o];r.classes+=a+(o<n.length-1?" ":"")}return r},e.elesfn.jsons=function(){for(var e=[],t=0;t<this.length;t++){var i=this[t],r=i.json();e.push(r)}return e},e.elesfn.clone=function(){for(var t=this.cy(),i=[],r=0;r<this.length;r++){var n=this[r],a=n.json(),o=new e.Element(t,a,!1);i.push(o)}return new e.Collection(t,i)},e.elesfn.restore=function(i){var r=this,n=[],a=r.cy();void 0===i&&(i=!0);for(var o=[],s=[],l=[],u=0,c=0,d=0,p=r.length;p>d;d++){var h=r[d];h.isNode()?(s.push(h),u++):(l.push(h),c++)}o=s.concat(l);for(var d=0,p=o.length;p>d;d++){var h=o[d];if(h.removed()){var v=h._private,g=v.data;if(void 0===g.id)g.id=t.generate(a,h);else{if(e.is.emptyString(g.id)||!e.is.string(g.id)){e.util.error("Can not create element with invalid string ID `"+g.id+"`");continue}if(0!==a.getElementById(g.id).length){e.util.error("Can not create second element with ID `"+g.id+"`");continue}}var f=g.id;if(h.isEdge()){for(var y=h,m=["source","target"],x=m.length,b=!1,w=0;x>w;w++){var _=m[w],E=g[_];null==E||""===E?(e.util.error("Can not create edge `"+f+"` with unspecified "+_),b=!0):a.getElementById(E).empty()&&(e.util.error("Can not create edge `"+f+"` with nonexistant "+_+" `"+E+"`"),b=!0)}if(b)continue;var S=a.getElementById(g.source),P=a.getElementById(g.target);S._private.edges.push(y),P._private.edges.push(y),y._private.source=S,y._private.target=P}v.ids={},v.ids[f]=h,v.removed=!1,a.addToPool(h),n.push(h)}}for(var d=0;u>d;d++){var D=o[d],g=D._private.data,k=D._private.data.parent,C=null!=k;if(C){var T=a.getElementById(k);if(T.empty())g.parent=void 0;else{for(var N=!1,M=T;!M.empty();){if(D.same(M)){N=!0,g.parent=void 0;break}M=M.parent()}N||(T[0]._private.children.push(D),D._private.parent=T[0],a._private.hasCompoundNodes=!0)}}}if(n=new e.Collection(a,n),n.length>0){var B=n.add(n.connectedNodes()).add(n.parent());B.updateStyle(i),i?n.rtrigger("add"):n.trigger("add")}return r},e.elesfn.removed=function(){var e=this[0];return e&&e._private.removed},e.elesfn.inside=function(){var e=this[0];return e&&!e._private.removed},e.elesfn.remove=function(t){function i(e){for(var t=e._private.edges,i=0;i<t.length;i++)n(t[i])}function r(e){for(var t=e._private.children,i=0;i<t.length;i++)n(t[i])}function n(e){var t=c[e.id()];t||(c[e.id()]=!0,e.isNode()?(u.push(e),i(e),r(e)):u.unshift(e))}function a(e,t){for(var i=e._private.edges,r=0;r<i.length;r++){var n=i[r];if(t===n){i.splice(r,1);break}}}function o(e,t){t=t[0],e=e[0];for(var i=e._private.children,r=0;r<i.length;r++)if(i[r][0]===t[0]){i.splice(r,1);break}}var s=this,l=[],u=[],c={},d=s._private.cy;void 0===t&&(t=!0);for(var p=0,h=s.length;h>p;p++){var v=s[p];n(v)}for(var p=0;p<u.length;p++){var v=u[p];if(v._private.removed=!0,d.removeFromPool(v),l.push(v),v.isEdge()){var g=v.source()[0],f=v.target()[0];a(g,v),a(f,v)}else{var y=v.parent();0!==y.length&&o(y,v)}}var m=d._private.elements;d._private.hasCompoundNodes=!1;for(var p=0;p<m.length;p++){var v=m[p];if(v.isParent()){d._private.hasCompoundNodes=!0;break}}var x=new e.Collection(this.cy(),l);x.size()>0&&(t&&this.cy().notify({type:"remove",collection:x}),x.trigger("remove"));for(var b={},p=0;p<u.length;p++){var v=u[p],w="nodes"===v._private.group,_=v._private.data.parent;if(w&&void 0!==_&&!b[_]){b[_]=!0;var y=d.getElementById(_);y&&0!==y.length&&!y._private.removed&&0===y.children().length&&y.updateStyle()}}return this},e.elesfn.move=function(e){var t=this._private.cy;if(void 0!==e.source||void 0!==e.target){var i=e.source,r=e.target,n=t.getElementById(i).length>0,a=t.getElementById(r).length>0;if(n||a){var o=this.jsons();this.remove();for(var s=0;s<o.length;s++){var l=o[s];"edges"===l.group&&(n&&(l.data.source=i),a&&(l.data.target=r))}return t.add(o)}}else if(void 0!==e.parent){var u=e.parent,c=null===u||t.getElementById(u).length>0;if(c){var o=this.jsons(),d=this.descendants(),p=d.merge(d.add(this).connectedEdges());this.remove();for(var s=0;s<this.length;s++){var l=o[s];"nodes"===l.group&&(l.data.parent=null===u?void 0:u)}}return t.add(o).merge(p.restore())}return this}}(cytoscape),function(e){"use strict";e.fn.eles({stdBreadthFirstSearch:function(t){return t=e.util.extend({},t,{std:!0}),this.breadthFirstSearch(t)},breadthFirstSearch:function(t,i,r){var n,a,o;e.is.plainObject(t)&&!e.is.elementOrCollection(t)&&(n=t,t=n.roots,i=n.visit,r=n.directed,a=n.std,o=n.thisArg),r=2!==arguments.length||e.is.fn(i)?r:i,i=e.is.fn(i)?i:function(){};for(var s,l=this._private.cy,u=e.is.string(t)?this.filter(t):t,c=[],d=[],p={},h={},v={},g=0,f=this.nodes(),y=this.edges(),m=0;m<u.length;m++)u[m].isNode()&&(c.unshift(u[m]),v[u[m].id()]=!0,d.push(u[m]),h[u[m].id()]=0);for(;0!==c.length;){var x,u=c.shift(),b=h[u.id()],w=p[u.id()],_=null==w?void 0:w.connectedNodes().not(u)[0];if(x=a?i.call(o,u,w,_,g++,b):i.call(u,g++,b,u,w,_),x===!0){s=u;break}if(x===!1)break;for(var E=u.connectedEdges(r?function(){return this.data("source")===u.id()}:void 0).intersect(y),m=0;m<E.length;m++){var S=E[m],P=S.connectedNodes(function(){return this.id()!==u.id()}).intersect(f);0===P.length||v[P.id()]||(P=P[0],c.push(P),v[P.id()]=!0,h[P.id()]=h[u.id()]+1,d.push(P),p[P.id()]=S)}}for(var D=[],m=0;m<d.length;m++){var k=d[m],C=p[k.id()];C&&D.push(C),D.push(k)}return{path:new e.Collection(l,D,{unique:!0}),found:new e.Collection(l,s,{unique:!0})}\n},stdDepthFirstSearch:function(t){return t=e.util.extend({},t,{std:!0}),this.depthFirstSearch(t)},depthFirstSearch:function(t,i,r){var n,a,o;e.is.plainObject(t)&&!e.is.elementOrCollection(t)&&(n=t,t=n.roots,i=n.visit,r=n.directed,a=n.std,o=n.thisArg),r=2!==arguments.length||e.is.fn(i)?r:i,i=e.is.fn(i)?i:function(){};for(var s,l=this._private.cy,u=e.is.string(t)?this.filter(t):t,c=[],d=[],p={},h={},v={},g=0,f=this.edges(),y=this.nodes(),m=0;m<u.length;m++)u[m].isNode()&&(c.push(u[m]),d.push(u[m]),h[u[m].id()]=0);for(;0!==c.length;){var u=c.pop();if(!v[u.id()]){v[u.id()]=!0;var x,b=h[u.id()],w=p[u.id()],_=null==w?void 0:w.connectedNodes().not(u)[0];if(x=a?i.call(o,u,w,_,g++,b):i.call(u,g++,b,u,w,_),x===!0){s=u;break}if(x===!1)break;for(var E=u.connectedEdges(r?function(){return this.data("source")===u.id()}:void 0).intersect(f),m=0;m<E.length;m++){var S=E[m],P=S.connectedNodes(function(){return this.id()!==u.id()}).intersect(y);0===P.length||v[P.id()]||(P=P[0],c.push(P),h[P.id()]=h[u.id()]+1,d.push(P),p[P.id()]=S)}}}for(var D=[],m=0;m<d.length;m++){var k=d[m],C=p[k.id()];C&&D.push(C),D.push(k)}return{path:new e.Collection(l,D,{unique:!0}),found:new e.Collection(l,s,{unique:!0})}},kruskal:function(t){function i(e){for(var t=0;t<n.length;t++){var i=n[t];if(i.anySame(e))return{eles:i,index:t}}}t=e.is.fn(t)?t:function(){return 1};for(var r=new e.Collection(this._private.cy,[]),n=[],a=this.nodes(),o=0;o<a.length;o++)n.push(a[o].collection());for(var s=this.edges(),l=s.toArray().sort(function(e,i){var r=t.call(e,e),n=t.call(i,i);return r-n}),o=0;o<l.length;o++){var u=l[o],c=u.source()[0],d=u.target()[0],p=i(c),h=i(d);p.index!==h.index&&(r=r.add(u),n[p.index]=p.eles.add(h.eles),n.splice(h.index,1))}return a.add(r)},dijkstra:function(t,i,r){var n;e.is.plainObject(t)&&!e.is.elementOrCollection(t)&&(n=t,t=n.root,i=n.weight,r=n.directed);var a=this._private.cy;r=e.is.fn(i)?r:i,i=e.is.fn(i)?i:function(){return 1};for(var o=e.is.string(t)?this.filter(t).eq(0):t.eq(0),s={},l={},u={},c=this.edges().filter(function(){return!this.isLoop()}),d=this.nodes(),p=[],h=0;h<d.length;h++)s[d[h].id()]=d[h].same(o)?0:1/0,p.push(d[h]);var v=function(e){return s[e.id()]};p=new e.Collection(a,p);for(var g=e.Minheap(a,p,v),f=function(e,t){for(var n,a=(r?e.edgesTo(t):e.edgesWith(t)).intersect(c),o=1/0,s=0;s<a.length;s++){var l=a[s],u=i.apply(l,[l]);(o>u||!n)&&(o=u,n=l)}return{edge:n,dist:o}};g.size()>0;){var y=g.pop(),m=y.value,x=y.id,b=a.getElementById(x);if(u[x]=m,m===Math.Infinite)break;for(var w=b.neighborhood().intersect(d),h=0;h<w.length;h++){var _=w[h],E=_.id(),S=f(b,_),P=m+S.dist;P<g.getValueById(E)&&(g.edit(E,P),l[E]={node:b,edge:S.edge})}}return{distanceTo:function(t){var i=e.is.string(t)?d.filter(t).eq(0):t.eq(0);return u[i.id()]},pathTo:function(t){var i=e.is.string(t)?d.filter(t).eq(0):t.eq(0),r=[],n=i;if(i.length>0)for(r.unshift(i);l[n.id()];){var o=l[n.id()];r.unshift(o.edge),r.unshift(o.node),n=o.node}return new e.Collection(a,r)}}}}),e.elesfn.bfs=e.elesfn.breadthFirstSearch,e.elesfn.dfs=e.elesfn.depthFirstSearch,e.elesfn.stdBfs=e.elesfn.stdBreadthFirstSearch,e.elesfn.stdDfs=e.elesfn.stdDepthFirstSearch}(cytoscape),function(e){"use strict";e.fn.eles({aStar:function(t){t=t||{};var i=function(){a&&console.log.apply(console,arguments)},r=function(e,t,i,n){if(e==t)return n.push(o.getElementById(t)),n;if(t in i){var a=i[t],s=g[t];return n.push(o.getElementById(t)),n.push(o.getElementById(s)),r(e,a,i,n)}return void 0},n=function(e,t){if(0===e.length)return void 0;for(var i=0,r=t[e[0]],n=1;n<e.length;n++){var a=t[e[n]];r>a&&(r=a,i=n)}return i};if(null!=t.debug)var a=t.debug;else var a=!1;i("Starting aStar...");var o=this._private.cy;if(null==t||null==t.root)return void 0;var s=e.is.string(t.root)?this.filter(t.root)[0]:t.root[0];if(i("Source node: %s",s.id()),null==t.goal)return void 0;var l=e.is.string(t.goal)?this.filter(t.goal)[0]:t.goal[0];if(i("Target node: %s",l.id()),null!=t.heuristic&&e.is.fn(t.heuristic))var u=t.heuristic;else var u=function(){return 0};if(null!=t.weight&&e.is.fn(t.weight))var c=t.weight;else var c=function(){return 1};if(null!=t.directed)var d=t.directed;else var d=!1;var p=[],h=[s.id()],v={},g={},f={},y={};f[s.id()]=0,y[s.id()]=u(s);for(var m=this.edges().not(":loop"),x=this.nodes(),b=0;h.length>0;){var w=n(h,y),_=this.filter("#"+h[w])[0];if(b++,i("\\nStep: %s",b),i("Processing node: %s, fScore = %s",_.id(),y[_.id()]),_.id()==l.id()){i("Found goal node!");var E=r(s.id(),l.id(),v,[]);return E.reverse(),i("Path: %s",E),{found:!0,distance:f[_.id()],path:new e.Collection(o,E),steps:b}}p.push(_.id()),h.splice(w,1),i("Added node to closedSet, removed from openSet."),i("Processing neighbors...");for(var S=_.connectedEdges(d?\'[source = "\'+_.id()+\'"]\':void 0).intersect(m),P=0;P<S.length;P++){var D=S[P],k=D.connectedNodes(\'[id != "\'+_.id()+\'"]\').intersect(x);if(i("   processing neighbor: %s",k.id()),-1==p.indexOf(k.id())){var C=f[_.id()]+c.apply(D,[D]);i("   tentative gScore: %d",C),-1!=h.indexOf(k.id())?C<f[k.id()]&&(f[k.id()]=C,y[k.id()]=C+u(k),v[k.id()]=_.id(),i("   better score, replacing gScore. "),i("   fScore(%s) = %s",k.id(),C)):(f[k.id()]=C,y[k.id()]=C+u(k),h.push(k.id()),v[k.id()]=_.id(),g[k.id()]=D.id(),i("   not in openSet, adding it. "),i("   fScore(%s) = %s",k.id(),C))}else i("   already in closedSet, ignoring it.")}}return i("Reached end of computation without finding our goal"),{found:!1,distance:void 0,path:void 0,steps:b}},floydWarshall:function(t){t=t||{};var i=function(){r&&console.log.apply(console,arguments)};if(null!=t.debug)var r=t.debug;else var r=!1;i("Starting floydWarshall...");var n=this._private.cy;if(null!=t.weight&&e.is.fn(t.weight))var a=t.weight;else var a=function(){return 1};if(null!=t.directed)var o=t.directed;else var o=!1;for(var s=this.edges().not(":loop"),l=this.nodes(),u=l.length,c={},d=0;u>d;d++)c[l[d].id()]=d;for(var p=[],d=0;u>d;d++){for(var h=new Array(u),v=0;u>v;v++)h[v]=d==v?0:1/0;p.push(h)}var g=[],f=[],y=function(e){for(var t=0;u>t;t++){for(var i=new Array(u),r=0;u>r;r++)i[r]=void 0;e.push(i)}};y(g),y(f);for(var d=0;d<s.length;d++){var m=c[s[d].source().id()],x=c[s[d].target().id()],b=a.apply(s[d],[s[d]]);p[m][x]>b&&(p[m][x]=b,g[m][x]=x,f[m][x]=s[d])}if(!o)for(var d=0;d<s.length;d++){var m=c[s[d].target().id()],x=c[s[d].source().id()],b=a.apply(s[d],[s[d]]);p[m][x]>b&&(p[m][x]=b,g[m][x]=x,f[m][x]=s[d])}for(var w=0;u>w;w++)for(var d=0;u>d;d++)for(var v=0;u>v;v++)p[d][w]+p[w][v]<p[d][v]&&(p[d][v]=p[d][w]+p[w][v],g[d][v]=g[d][w]);for(var _=[],d=0;u>d;d++)_.push(l[d].id());var E={distance:function(t,i){if(e.is.string(t))var r=n.filter(t)[0].id();else var r=t.id();if(e.is.string(i))var a=n.filter(i)[0].id();else var a=i.id();return p[c[r]][c[a]]},path:function(t,i){var r=function(e,t,i,r,a){if(e===t)return n.getElementById(r[e]);if(void 0===i[e][t])return void 0;for(var o=[n.getElementById(r[e])],s=e;e!==t;){s=e,e=i[e][t];var l=a[s][e];o.push(l),o.push(n.getElementById(r[e]))}return o};if(e.is.string(t))var a=n.filter(t)[0].id();else var a=t.id();if(e.is.string(i))var o=n.filter(i)[0].id();else var o=i.id();var s=r(c[a],c[o],g,_,f);return new e.Collection(n,s)}};return E},bellmanFord:function(t){t=t||{};var i=function(){r&&console.log.apply(console,arguments)};if(null!=t.debug)var r=t.debug;else var r=!1;if(i("Starting bellmanFord..."),null!=t.weight&&e.is.fn(t.weight))var n=t.weight;else var n=function(){return 1};if(null!=t.directed)var a=t.directed;else var a=!1;if(null==t.root)return void e.util.error("options.root required");if(e.is.string(t.root))var o=this.filter(t.root)[0];else var o=t.root[0];i("Source node: %s",o.id());for(var s=this._private.cy,l=this.edges().not(":loop"),u=this.nodes(),c=u.length,d={},p=0;c>p;p++)d[u[p].id()]=p;for(var h=[],v=[],g=[],p=0;c>p;p++)h[p]=u[p].id()===o.id()?0:1/0,v[p]=void 0;for(var f=!1,p=1;c>p;p++){f=!1;for(var y=0;y<l.length;y++){var m=d[l[y].source().id()],x=d[l[y].target().id()],b=n.apply(l[y],[l[y]]),w=h[m]+b;if(w<h[x]&&(h[x]=w,v[x]=m,g[x]=l[y],f=!0),!a){var w=h[x]+b;w<h[m]&&(h[m]=w,v[m]=x,g[m]=l[y],f=!0)}}if(!f)break}if(f)for(var y=0;y<l.length;y++){var m=d[l[y].source().id()],x=d[l[y].target().id()],b=n.apply(l[y],[l[y]]);if(h[m]+b<h[x])return e.util.error("Error: graph contains a negative weigth cycle!"),{pathTo:void 0,distanceTo:void 0,hasNegativeWeightCycle:!0}}for(var _=[],p=0;c>p;p++)_.push(u[p].id());var E={distanceTo:function(t){if(e.is.string(t))var i=s.filter(t)[0].id();else var i=t.id();return h[d[i]]},pathTo:function(t){var i=function(e,t,i,r,n,a){for(;;){if(n.push(s.getElementById(r[i])),n.push(a[i]),t===i)return n;var o=e[i];if("undefined"==typeof o)return void 0;i=o}};if(e.is.string(t))var r=s.filter(t)[0].id();else var r=t.id();var n=[],a=i(v,d[o.id()],d[r],_,n,g);return null!=a&&a.reverse(),new e.Collection(s,a)},hasNegativeWeightCycle:!1};return E},kargerStein:function(t){t=t||{};var i=function(){a&&console.log.apply(console,arguments)},r=function(e,t,i){for(var r=i[e],n=r[1],a=r[2],o=t[n],s=t[a],l=i.filter(function(e){return t[e[1]]===o&&t[e[2]]===s?!1:t[e[1]]===s&&t[e[2]]===o?!1:!0}),u=0;u<l.length;u++){var c=l[u];c[1]===s?(l[u]=c.slice(0),l[u][1]=o):c[2]===s&&(l[u]=c.slice(0),l[u][2]=o)}for(var u=0;u<t.length;u++)t[u]===s&&(t[u]=o);return l},n=function(e,t,i,a){if(a>=i)return t;var o=Math.floor(Math.random()*t.length),s=r(o,e,t);return n(e,s,i-1,a)};if(null!=t&&null!=t.debug)var a=t.debug;else var a=!1;i("Starting kargerStein...");var o=this._private.cy,s=this.edges().not(":loop"),l=this.nodes(),u=l.length,c=s.length,d=Math.ceil(Math.pow(Math.log(u)/Math.LN2,2)),p=Math.floor(u/Math.sqrt(2));if(2>u)return void e.util.error("At least 2 nodes are required for KargerSteing algorithm!");for(var h={},v=0;u>v;v++)h[l[v].id()]=v;for(var g=[],v=0;c>v;v++){var f=s[v];g.push([v,h[f.source().id()],h[f.target().id()]])}for(var y,m=1/0,x=[],v=0;u>v;v++)x.push(v);for(var b=0;d>=b;b++){var w=x.slice(0),_=n(w,g,u,p),E=w.slice(0),S=n(w,_,p,2),P=n(E,_,p,2);S.length<=P.length&&S.length<m?(m=S.length,y=[S,w]):P.length<=S.length&&P.length<m&&(m=P.length,y=[P,E])}for(var D=y[0].map(function(e){return s[e[0]]}),k=[],C=[],T=y[1][0],v=0;v<y[1].length;v++){var N=y[1][v];N===T?k.push(l[v]):C.push(l[v])}var M={cut:new e.Collection(o,D),partition1:new e.Collection(o,k),partition2:new e.Collection(o,C)};return M},pageRank:function(t){t=t||{};var i=function(e){for(var t=e.length,i=0,r=0;t>r;r++)i+=e[r];for(var r=0;t>r;r++)e[r]=e[r]/i},r=function(){n&&console.log.apply(console,arguments)};if(null!=t&&null!=t.debug)var n=t.debug;else var n=!1;if(r("Starting pageRank..."),null!=t&&null!=t.dampingfactor)var a=t.dampingFactor;else var a=.8;if(null!=t&&null!=t.precision)var o=t.precision;else var o=1e-6;if(null!=t&&null!=t.iterations)var s=t.iterations;else var s=200;if(null!=t&&null!=t.weight&&e.is.fn(t.weight))var l=t.weight;else var l=function(){return 1};for(var u=this._private.cy,c=this.edges().not(":loop"),d=this.nodes(),p=d.length,h=c.length,v={},g=0;p>g;g++)v[d[g].id()]=g;for(var f=[],y=[],m=(1-a)/p,g=0;p>g;g++){for(var x=[],b=0;p>b;b++)x.push(0);f.push(x),y.push(0)}for(var g=0;h>g;g++){var w=c[g],_=v[w.source().id()],E=v[w.target().id()],S=l.apply(w,[w]);f[E][_]+=S,y[_]+=S}for(var P=1/p+m,b=0;p>b;b++)if(0===y[b])for(var g=0;p>g;g++)f[g][b]=P;else for(var g=0;p>g;g++)f[g][b]=f[g][b]/y[b]+m;for(var D,k=[],C=[],g=0;p>g;g++)k.push(1),C.push(0);for(var T=0;s>T;T++){for(var N=C.slice(0),g=0;p>g;g++)for(var b=0;p>b;b++)N[g]+=f[g][b]*k[b];i(N),D=k,k=N;for(var M=0,g=0;p>g;g++)M+=Math.pow(D[g]-k[g],2);if(o>M){r("Stoped at iteration %s",T);break}}r("Result:\\n"+k);var B={rank:function(t){if(e.is.string(t))var i=u.filter(t)[0].id();else var i=t.id();return k[v[i]]}};return B}})}(cytoscape),function(e){"use strict";e.fn.eles({animated:e.define.animated(),clearQueue:e.define.clearQueue(),delay:e.define.delay(),animate:e.define.animate(),stop:e.define.stop()})}(cytoscape),function(e){"use strict";e.fn.eles({classes:function(t){var i,r=this,n=[];if(e.is.fn(t))i=t;else if(!e.is.plainObject(t))return this;for(var a=0;a<r.length;a++){var o=r[a],s=!1;if(t=i?i.apply(o,[a,o]):t,t.add)for(var l=0;l<t.add.length;l++){var u=t.add[l],c=o._private.classes[u];o._private.classes[u]=!0,c||s||(n.push(o),s=!0)}if(t.remove)for(var l=0;l<t.remove.length;l++){var u=t.remove[l],c=o._private.classes[u];o._private.classes[u]=!1,c&&!s&&(n.push(o),s=!0)}if(t.toggle)for(var l=0;l<t.toggle.length;l++){var u=t.toggle[l],c=o._private.classes[u];o._private.classes[u]=!c,s||(n.push(o),s=!0)}}return n.length>0&&new e.Collection(this.cy(),n).updateStyle().trigger("class"),this},addClass:function(t){t=t.split(/\\s+/);for(var i=this,r=[],n=0;n<t.length;n++){var a=t[n];if(!e.is.emptyString(a))for(var o=0;o<i.length;o++){var s=i[o],l=s._private.classes[a];s._private.classes[a]=!0,l||r.push(s)}}return r.length>0&&new e.Collection(this._private.cy,r).updateStyle().trigger("class"),i},hasClass:function(e){var t=this[0];return null!=t&&t._private.classes[e]?!0:!1},toggleClass:function(t,i){for(var r=t.split(/\\s+/),n=this,a=[],o=0,s=n.length;s>o;o++)for(var l=n[o],u=0;u<r.length;u++){var c=r[u];if(!e.is.emptyString(c)){var d=l._private.classes[c],p=i||void 0===i&&!d;p?(l._private.classes[c]=!0,d||a.push(l)):(l._private.classes[c]=!1,d&&a.push(l))}}return a.length>0&&new e.Collection(this._private.cy,a).updateStyle().trigger("class"),n},removeClass:function(t){t=t.split(/\\s+/);for(var i=this,r=[],n=0;n<i.length;n++)for(var a=i[n],o=0;o<t.length;o++){var s=t[o];if(s&&""!==s){var l=a._private.classes[s];a._private.classes[s]=void 0,l&&r.push(a)}}return r.length>0&&new e.Collection(i._private.cy,r).updateStyle(),i.trigger("class"),i},flashClass:function(e,t){var i=this;if(null==t)t=250;else if(0===t)return i;return i.addClass(e),setTimeout(function(){i.removeClass(e)},t),i}})}(cytoscape),function(e){"use strict";e.fn.eles({allAre:function(e){return this.filter(e).length===this.length},is:function(e){return this.filter(e).length>0},some:function(e,t){for(var i=0;i<this.length;i++){var r=e.apply(t,[this[i],i,this]);if(r)return!0}return!1},every:function(e,t){for(var i=0;i<this.length;i++){var r=e.apply(t,[this[i],i,this]);if(!r)return!1}return!0},same:function(e){return e=this.cy().collection(e),this.length!==e.length?!1:this.intersect(e).length===this.length},anySame:function(e){return e=this.cy().collection(e),this.intersect(e).length>0},allAreNeighbors:function(e){return e=this.cy().collection(e),this.neighborhood().intersect(e).length===e.length}})}(cytoscape),function(e){"use strict";e.fn.eles({parent:function(t){for(var i=[],r=this._private.cy,n=0;n<this.length;n++){var a=this[n],o=r.getElementById(a._private.data.parent);o.size()>0&&i.push(o)}return new e.Collection(r,i,{unique:!0}).filter(t)},parents:function(t){for(var i=[],r=this.parent();r.nonempty();){for(var n=0;n<r.length;n++){var a=r[n];i.push(a)}r=r.parent()}return new e.Collection(this.cy(),i,{unique:!0}).filter(t)},commonAncestors:function(e){for(var t,i=0;i<this.length;i++){var r=this[i],n=r.parents();t=t||n,t=t.intersect(n)}return t.filter(e)},orphans:function(e){return this.stdFilter(function(e){return e.isNode()&&e.parent().empty()}).filter(e)},nonorphans:function(e){return this.stdFilter(function(e){return e.isNode()&&e.parent().nonempty()}).filter(e)},children:function(t){for(var i=[],r=0;r<this.length;r++){var n=this[r];i=i.concat(n._private.children)}return new e.Collection(this.cy(),i,{unique:!0}).filter(t)},siblings:function(e){return this.parent().children().not(this).filter(e)},isParent:function(){var e=this[0];return e?0!==e._private.children.length:void 0},isChild:function(){var e=this[0];return e?void 0!==e._private.data.parent&&0!==e.parent().length:void 0},descendants:function(t){function i(e){for(var t=0;t<e.length;t++){var n=e[t];r.push(n),n.children().nonempty()&&i(n.children())}}var r=[];return i(this.children()),new e.Collection(this.cy(),r,{unique:!0}).filter(t)}}),e.elesfn.ancestors=e.elesfn.parents}(cytoscape),function(e){"use strict";var t=1,i=0;e.fn.eles({data:e.define.data({field:"data",bindingEvent:"data",allowBinding:!0,allowSetting:!0,settingEvent:"data",settingTriggersEvent:!0,triggerFnName:"trigger",allowGetting:!0,immutableKeys:{id:!0,source:!0,target:!0,parent:!0},updateStyle:!0}),removeData:e.define.removeData({field:"data",event:"data",triggerFnName:"trigger",triggerEvent:!0,immutableKeys:{id:!0,source:!0,target:!0,parent:!0},updateStyle:!0}),scratch:e.define.data({field:"scratch",allowBinding:!1,allowSetting:!0,settingTriggersEvent:!1,allowGetting:!0}),removeScratch:e.define.removeData({field:"scratch",triggerEvent:!1}),rscratch:e.define.data({field:"rscratch",allowBinding:!1,allowSetting:!0,settingTriggersEvent:!1,allowGetting:!0}),removeRscratch:e.define.removeData({field:"rscratch",triggerEvent:!1}),id:function(){var e=this[0];return e?e._private.data.id:void 0},position:e.define.data({field:"position",bindingEvent:"position",allowBinding:!0,allowSetting:!0,settingEvent:"position",settingTriggersEvent:!0,triggerFnName:"rtrigger",allowGetting:!0,validKeys:["x","y"],onSet:function(e){var t=e.updateCompoundBounds();t.rtrigger("position")},canSet:function(e){return!e.locked()}}),silentPosition:e.define.data({field:"position",bindingEvent:"position",allowBinding:!1,allowSetting:!0,settingEvent:"position",settingTriggersEvent:!1,triggerFnName:"trigger",allowGetting:!0,validKeys:["x","y"],onSet:function(e){e.updateCompoundBounds()},canSet:function(e){return!e.locked()}}),positions:function(t,i){if(e.is.plainObject(t))this.position(t);else if(e.is.fn(t)){for(var r=t,n=0;n<this.length;n++){var a=this[n],t=r.apply(a,[n,a]);if(t&&!a.locked()){var o=a._private.position;o.x=t.x,o.y=t.y}}var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;i?l.trigger("position"):l.rtrigger("position")}return this},silentPositions:function(e){return this.positions(e,!0)},updateCompoundBounds:function(){function t(e){var t=e.children(),i=e._private.style,n=t.boundingBox({includeLabels:!1,includeEdges:!1}),a={top:i["padding-top"].pxValue,bottom:i["padding-bottom"].pxValue,left:i["padding-left"].pxValue,right:i["padding-right"].pxValue},o=e._private.position,s=!1;"auto"===i.width.value&&(e._private.autoWidth=n.w+a.left+a.right,o.x=(n.x1+n.x2-a.left+a.right)/2,s=!0),"auto"===i.height.value&&(e._private.autoHeight=n.h+a.top+a.bottom,o.y=(n.y1+n.y2-a.top+a.bottom)/2,s=!0),s&&r.push(e)}var i=this.cy();if(!i.styleEnabled()||!i.hasCompoundNodes())return i.collection();for(var r=[],n=this.parent();n.nonempty();){for(var a=0;a<n.length;a++){var o=n[a];t(o)}n=n.parent()}return new e.Collection(i,r)},renderedPosition:function(t,i){var r=this[0],n=this.cy(),a=n.zoom(),o=n.pan(),s=e.is.plainObject(t)?t:void 0,l=void 0!==s||void 0!==i&&e.is.string(t);if(r&&r.isNode()){if(!l){var u=r._private.position;return s={x:u.x*a+o.x,y:u.y*a+o.y},void 0===t?s:s[t]}for(var c=0;c<this.length;c++){var r=this[c];void 0!==i?r._private.position[t]=(i-o[t])/a:void 0!==s&&(r._private.position={x:(s.x-o.x)/a,y:(s.y-o.y)/a})}this.rtrigger("position")}else if(!l)return void 0;return this},parentPosition:function(t,i){var r=this[0],n=this.cy(),a=e.is.plainObject(t)?t:void 0,o=void 0!==a||void 0!==i&&e.is.string(t),s=n.hasCompoundNodes();if(r&&r.isNode()){if(!o){var l=r._private.position,u=s?r.parent():null,c=u&&u.length>0,d=c;c&&(u=u[0]);var p=d?u._private.position:{x:0,y:0};return a={x:l.x-p.x,y:l.y-p.y},void 0===t?a:a[t]}for(var h=0;h<this.length;h++){var r=this[h],u=s?r.parent():null,c=u&&u.length>0,d=c;c&&(u=u[0]);var p=d?u._private.position:{x:0,y:0};void 0!==i?r._private.position[t]=i+p[t]:void 0!==a&&(r._private.position={x:a.x+p.x,y:a.y+p.y})}this.rtrigger("position")}else if(!o)return void 0;return this},width:function(){var e=this[0],t=e._private.cy,i=t._private.styleEnabled;if(e){if(i){var r=e._private.style.width;return"auto"===r.strValue?e._private.autoWidth:r.pxValue}return 1}},outerWidth:function(){var e=this[0],r=e._private.cy,n=r._private.styleEnabled;if(e){if(n){var a=e._private.style,o="auto"===a.width.strValue?e._private.autoWidth:a.width.pxValue,s=a["border-width"]?a["border-width"].pxValue*t+i:0;return o+s}return 1}},renderedWidth:function(){var e=this[0];if(e){var t=e.width();return t*this.cy().zoom()}},renderedOuterWidth:function(){var e=this[0];if(e){var t=e.outerWidth();return t*this.cy().zoom()}},height:function(){var e=this[0],t=e._private.cy,i=t._private.styleEnabled;if(e&&"nodes"===e._private.group){if(i){var r=e._private.style.height;return"auto"===r.strValue?e._private.autoHeight:r.pxValue}return 1}},outerHeight:function(){var e=this[0],r=e._private.cy,n=r._private.styleEnabled;if(e&&"nodes"===e._private.group){if(!n)return 1;var a=e._private.style,o="auto"===a.height.strValue?e._private.autoHeight:a.height.pxValue,s=a["border-width"]?a["border-width"].pxValue*t+i:0;return o+s}},renderedHeight:function(){var e=this[0];if(e&&"nodes"===e._private.group){var t=e.height();return t*this.cy().zoom()}},renderedOuterHeight:function(){var e=this[0];if(e&&"nodes"===e._private.group){var t=e.outerHeight();return t*this.cy().zoom()}},renderedBoundingBox:function(e){var t=this.boundingBox(e),i=this.cy(),r=i.zoom(),n=i.pan(),a=t.x1*r+n.x,o=t.x2*r+n.x,s=t.y1*r+n.y,l=t.y2*r+n.y;return{x1:a,x2:o,y1:s,y2:l,w:o-a,h:l-s}},boundingBox:function(e){var t=this,i=t._private.cy,r=i._private,n=r.styleEnabled;e=e||{};var a=void 0===e.includeNodes?!0:e.includeNodes,o=void 0===e.includeEdges?!0:e.includeEdges,s=void 0===e.includeLabels?!0:e.includeLabels;n&&r.renderer.recalculateRenderedStyle(this);for(var l=1/0,u=-1/0,c=1/0,d=-1/0,p=0;p<t.length;p++){var h,v,g,f,y,m,x=t[p],b=x._private,w=n?b.style.display.value:"element",_="nodes"===b.group,E=!1;if("none"!==w){if(_&&a){E=!0;var S=b.position;y=S.x,m=S.y;var P=x.outerWidth(),D=P/2,k=x.outerHeight(),C=k/2;h=y-D,v=y+D,g=m-C,f=m+C,l=l>h?h:l,u=v>u?v:u,c=c>g?g:c,d=f>d?f:d}else if(x.isEdge()&&o){E=!0;var T=x._private.source._private.position,N=x._private.target._private.position,M=x._private.rstyle||{};if(h=T.x,v=N.x,g=T.y,f=N.y,h>v){var B=h;h=v,v=B}if(g>f){var B=g;g=f,f=B}if(l=l>h?h:l,u=v>u?v:u,c=c>g?g:c,d=f>d?f:d,n)for(var I=M.bezierPts||[],P=x._private.style.width.pxValue,z=P/2,L=0;L<I.length;L++){var O=I[L];h=O.x-z,v=O.x+z,g=O.y-z,f=O.y+z,l=l>h?h:l,u=v>u?v:u,c=c>g?g:c,d=f>d?f:d}}if(n){var R=x._private.style,M=x._private.rstyle,X=R.content.strValue,V=R["font-size"],Y=R["text-halign"],A=R["text-valign"],q=M.labelWidth,F=M.labelHeight,j=M.labelX,W=M.labelY;if(E&&s&&X&&V&&null!=F&&null!=q&&null!=j&&null!=W&&Y&&A){var H,$,Z,U,G=F,K=q;if(x.isEdge())H=j-K/2,$=j+K/2,Z=W-G/2,U=W+G/2;else{switch(Y.value){case"left":H=j-K,$=j;break;case"center":H=j-K/2,$=j+K/2;break;case"right":H=j,$=j+K}switch(A.value){case"top":Z=W-G,U=W;break;case"center":Z=W-G/2,U=W+G/2;break;case"bottom":Z=W,U=W+G}}l=l>H?H:l,u=$>u?$:u,c=c>Z?Z:c,d=U>d?U:d}}}}return{x1:l,x2:u,y1:c,y2:d,w:u-l,h:d-c}}}),e.elesfn.modelPosition=e.elesfn.position,e.elesfn.modelPositions=e.elesfn.positions}(cytoscape),function(e){"use strict";function t(e){return function(t){var i=this;if(void 0===t&&(t=!0),0!==i.length&&i.isNode()&&!i.removed()){for(var r=0,n=i[0],a=n._private.edges,o=0;o<a.length;o++){var s=a[o];(t||!s.isLoop())&&(r+=e(n,s))}return r}}}function i(e,t){return function(i){for(var r,n=this.nodes(),a=0;a<n.length;a++){var o=n[a],s=o[e](i);void 0===s||void 0!==r&&!t(s,r)||(r=s)}return r}}e.fn.eles({degree:t(function(e,t){return t.source().same(t.target())?2:1}),indegree:t(function(e,t){return t.target().same(e)?1:0}),outdegree:t(function(e,t){return t.source().same(e)?1:0})}),e.fn.eles({minDegree:i("degree",function(e,t){return t>e}),maxDegree:i("degree",function(e,t){return e>t}),minIndegree:i("indegree",function(e,t){return t>e}),maxIndegree:i("indegree",function(e,t){return e>t}),minOutdegree:i("outdegree",function(e,t){return t>e}),maxOutdegree:i("outdegree",function(e,t){return e>t})}),e.fn.eles({totalDegree:function(e){for(var t=0,i=this.nodes(),r=0;r<i.length;r++)t+=i[r].degree(e);return t}})}(cytoscape),function(e){"use strict";e.fn.eles({on:e.define.on(),one:e.define.on({unbindSelfOnTrigger:!0}),once:e.define.on({unbindAllBindersOnTrigger:!0}),off:e.define.off(),trigger:e.define.trigger(),rtrigger:function(e,t){return 0!==this.length?(this.cy().notify({type:e,collection:this}),this.trigger(e,t),this):void 0}}),e.elesfn.bind=e.elesfn.on,e.elesfn.unbind=e.elesfn.off}(cytoscape),function(e){"use strict";e.fn.eles({nodes:function(e){return this.filter(function(e,t){return t.isNode()}).filter(e)},edges:function(e){return this.filter(function(e,t){return t.isEdge()}).filter(e)},filter:function(t){var i=this._private.cy;if(e.is.fn(t)){for(var r=[],n=0;n<this.length;n++){var a=this[n];t.apply(a,[n,a])&&r.push(a)}return new e.Collection(i,r)}return e.is.string(t)||e.is.elementOrCollection(t)?new e.Selector(t).filter(this):void 0===t?this:new e.Collection(i)},not:function(t){var i=this._private.cy;if(t){e.is.string(t)&&(t=this.filter(t));for(var r=[],n=0;n<this.length;n++){var a=this[n],o=t._private.ids[a.id()];o||r.push(a)}return new e.Collection(i,r)}return this},intersect:function(t){var i=this._private.cy;if(e.is.string(t)){var r=t;return this.filter(r)}for(var n=[],a=this,o=t,s=this.length<t.length,l=s?o._private.ids:a._private.ids,u=s?a:o,c=0;c<u.length;c++){var d=u[c]._private.data.id,p=l[d];p&&n.push(p)}return new e.Collection(i,n)},add:function(t){var i=this._private.cy;if(!t)return this;if(e.is.string(t)){var r=t;t=i.elements(r)}for(var n=[],a=0;a<this.length;a++)n.push(this[a]);for(var a=0;a<t.length;a++){var o=!this._private.ids[t[a].id()];o&&n.push(t[a])}return new e.Collection(i,n)},merge:function(t){var i=this._private,r=i.cy;if(!t)return this;if(e.is.string(t)){var n=t;t=r.elements(n)}for(var a=0;a<t.length;a++){var o=t[a],s=o.id(),l=!i.ids[s];if(l){var u=this.length++;this[u]=o,i.ids[s]=o,i.indexes[s]=u}}return this},unmergeOne:function(e){e=e[0];var t=this._private,i=e.id(),r=t.indexes[i];if(null==r)return this;this[r]=void 0,t.ids[i]=void 0,t.indexes[i]=void 0;var n=r===this.length-1;if(this.length>1&&!n){var a=this.length-1,o=this[a];this[a]=void 0,this[r]=o,t.indexes[o.id()]=r}return this.length--,this},unmerge:function(t){var i=this._private.cy;if(!t)return this;if(e.is.string(t)){var r=t;t=i.elements(r)}for(var n=0;n<t.length;n++)this.unmergeOne(t[n]);return this},map:function(e,t){for(var i=[],r=this,n=0;n<r.length;n++){var a=r[n],o=e.apply(t,[a,n,r]);i.push(o)}return i},stdFilter:function(t,i){for(var r=[],n=this,a=this._private.cy,o=0;o<n.length;o++){var s=n[o],l=t.apply(i,[s,o,n]);l&&r.push(s)}return new e.Collection(a,r)},max:function(e,t){for(var i,r=-1/0,n=this,a=0;a<n.length;a++){var o=n[a],s=e.apply(t,[o,a,n]);s>r&&(r=s,i=o)}return{value:r,ele:i}},min:function(e,t){for(var i,r=1/0,n=this,a=0;a<n.length;a++){var o=n[a],s=e.apply(t,[o,a,n]);r>s&&(r=s,i=o)}return{value:r,ele:i}}})}(cytoscape),function(e){"use strict";e.fn.eles({isNode:function(){return"nodes"===this.group()},isEdge:function(){return"edges"===this.group()},isLoop:function(){return this.isEdge()&&this.source().id()===this.target().id()},isSimple:function(){return this.isEdge()&&this.source().id()!==this.target().id()},group:function(){var e=this[0];return e?e._private.group:void 0}})}(cytoscape),function(e){"use strict";e.fn.eles({each:function(t){if(e.is.fn(t))for(var i=0;i<this.length;i++){var r=this[i],n=t.apply(r,[i,r]);if(n===!1)break}return this},forEach:function(t,i){if(e.is.fn(t))for(var r=0;r<this.length;r++){var n=this[r],a=t.apply(i,[n,r,this]);if(a===!1)break}return this},toArray:function(){for(var e=[],t=0;t<this.length;t++)e.push(this[t]);return e},slice:function(t,i){var r=[],n=this.length;null==i&&(i=n),null==t&&(t=0),0>t&&(t=n+t),0>i&&(i=n+i);for(var a=t;a>=0&&i>a&&n>a;a++)r.push(this[a]);return new e.Collection(this.cy(),r)},size:function(){return this.length},eq:function(t){return this[t]||new e.Collection(this.cy())},first:function(){return this[0]||new e.Collection(this.cy())},last:function(){return this[this.length-1]||new e.Collection(this.cy())},empty:function(){return 0===this.length},nonempty:function(){return!this.empty()},sort:function(t){if(!e.is.fn(t))return this;var i=this.cy(),r=this.toArray().sort(t);return new e.Collection(i,r)},sortByZIndex:function(){return this.sort(e.Collection.zIndexSort)},zDepth:function(){var e=this[0];if(!e)return void 0;var t=e._private,i=t.group;if("nodes"===i)return t.data.parent?e.parents().size():0;var r=t.source,n=t.target,a=r._private.data.parent?r.parents().size():0,o=n._private.data.parent?n.parents().size():0;return Math.max(a-1,o-1,0)+.5}}),e.Collection.zIndexSort=function(e,t){var i=e.cy(),r=e._private,n=t._private,a=r.style["z-index"].value-n.style["z-index"].value,o=0,s=0,l=i.hasCompoundNodes(),u="nodes"===r.group,c="edges"===r.group,d="nodes"===n.group,p="edges"===n.group;l&&(o=e.zDepth(),s=t.zDepth());var h=o-s,v=0===h;return v?u&&p?1:c&&d?-1:0===a?r.index-n.index:a:h}}(cytoscape),function(e){"use strict";e.fn.eles({layoutPositions:function(t,i,r){var n=this.nodes(),a=this.cy();if(t.trigger({type:"layoutstart",layout:t}),i.animate){for(var o=0;o<n.length;o++){var s=n[o],l=o===n.length-1,u=r.call(s,o,s),c=s.position();e.is.number(c.x)&&e.is.number(c.y)||s.silentPosition({x:0,y:0}),s.animate({position:u},{duration:i.animationDuration,step:l?function(){i.fit&&a.fit(i.padding)}:void 0,complete:l?function(){null!=i.zoom&&a.zoom(i.zoom),i.pan&&a.pan(i.pan),i.fit&&a.fit(i.padding),t.one("layoutstop",i.stop),t.trigger({type:"layoutstop",layout:t})}:void 0})}t.one("layoutready",i.ready),t.trigger({type:"layoutready",layout:t})}else n.positions(r),i.fit&&a.fit(i.padding),null!=i.zoom&&a.zoom(i.zoom),i.pan&&a.pan(i.pan),t.one("layoutready",i.ready),t.trigger({type:"layoutready",layout:t}),t.one("layoutstop",i.stop),t.trigger({type:"layoutstop",layout:t});return this},layout:function(t){var i=this.cy();return i.layout(e.util.extend({},t,{eles:this})),this},makeLayout:function(t){var i=this.cy();return i.makeLayout(e.util.extend({},t,{eles:this}))}})}(cytoscape),function(e){"use strict";e.fn.eles({updateStyle:function(e){var t=this._private.cy;if(!t.styleEnabled())return this;if(t._private.batchingStyle){for(var i=t._private.batchStyleEles,r=0;r<this.length;r++){var n=this[r];i.ids[n._private.id]||i.push(n)}return this}var a=t.style();e=e||void 0===e?!0:!1,a.apply(this);var o=this.updateCompoundBounds(),s=o.length>0?this.add(o):this;return e?s.rtrigger("style"):s.trigger("style"),this},updateMappers:function(e){var t=this._private.cy,i=t.style();if(e=e||void 0===e?!0:!1,!t.styleEnabled())return this;i.updateMappers(this);var r=this.updateCompoundBounds(),n=r.length>0?this.add(r):this;return e?n.rtrigger("style"):n.trigger("style"),this},renderedCss:function(e){var t=this.cy();if(!t.styleEnabled())return this;var i=this[0];if(i){var r=i.cy().style().getRenderedStyle(i);return void 0===e?r:r[e]}},css:function(t,i){var r=this.cy();if(!r.styleEnabled())return this;var n=!1,a=r.style();if(e.is.plainObject(t)){var o=t;a.applyBypass(this,o,n);var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;l.rtrigger("style")}else if(e.is.string(t)){if(void 0===i){var u=this[0];return u?u._private.style[t].strValue:void 0}a.applyBypass(this,t,i,n);var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;l.rtrigger("style")}else if(void 0===t){var u=this[0];return u?a.getRawStyle(u):void 0}return this},removeCss:function(e){var t=this.cy();if(!t.styleEnabled())return this;var i=!1,r=t.style(),n=this;if(void 0===e)for(var a=0;a<n.length;a++){var o=n[a];r.removeAllBypasses(o,i)}else{e=e.split(/\\s+/);for(var a=0;a<n.length;a++){var o=n[a];r.removeBypasses(o,e,i)}}var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;return l.rtrigger("style"),this},show:function(){return this.css("display","element"),this},hide:function(){return this.css("display","none"),this},visible:function(){var e=this.cy();if(!e.styleEnabled())return!0;var t=this[0],i=e.hasCompoundNodes();if(t){var r=t._private.style;if("visible"!==r.visibility.value||"element"!==r.display.value)return!1;if("nodes"===t._private.group){if(!i)return!0;\nvar n=t._private.data.parent?t.parents():null;if(n)for(var a=0;a<n.length;a++){var o=n[a],s=o._private.style,l=s.visibility.value,u=s.display.value;if("visible"!==l||"element"!==u)return!1}return!0}var c=t._private.source,d=t._private.target;return c.visible()&&d.visible()}},hidden:function(){var e=this[0];return e?!e.visible():void 0},effectiveOpacity:function(){var e=this.cy();if(!e.styleEnabled())return 1;var t=e.hasCompoundNodes(),i=this[0];if(i){var r=i._private,n=r.style.opacity.value;if(!t)return n;var a=r.data.parent?i.parents():null;if(a)for(var o=0;o<a.length;o++){var s=a[o],l=s._private.style.opacity.value;n=l*n}return n}},transparent:function(){var e=this[0],t=e.cy().hasCompoundNodes();return e?t?0===e.effectiveOpacity():0===e._private.style.opacity.value:void 0},isFullAutoParent:function(){var e=this.cy();if(!e.styleEnabled())return!1;var t=this[0];if(t){var i="auto"===t._private.style.width.value,r="auto"===t._private.style.height.value;return t.isParent()&&i&&r}}}),e.elesfn.style=e.elesfn.css,e.elesfn.renderedStyle=e.elesfn.renderedCss,e.elesfn.removeStyle=e.elesfn.removeCss}(cytoscape),function(e){"use strict";function t(e){return function(){var t=arguments;if(2===t.length){var i=t[0],r=t[1];this.bind(e.event,i,r)}else if(1===t.length){var r=t[0];this.bind(e.event,r)}else if(0===t.length){for(var n=0;n<this.length;n++){var a=this[n],o=!e.ableField||a._private[e.ableField];if(e.overrideAble){var s=e.overrideAble(a);if(void 0!==s&&(o=s,!s))return this}o&&(a._private[e.field]=e.value)}this.updateStyle(),this.trigger(e.event)}return this}}function i(i){e.elesfn[i.field]=function(){var e=this[0];if(e){if(i.overrideField){var t=i.overrideField(e);if(void 0!==t)return t}return e._private[i.field]}},e.elesfn[i.on]=t({event:i.on,field:i.field,ableField:i.ableField,overrideAble:i.overrideAble,value:!0}),e.elesfn[i.off]=t({event:i.off,field:i.field,ableField:i.ableField,overrideAble:i.overrideAble,value:!1})}i({field:"locked",overrideField:function(e){return e.cy().autolock()?!0:void 0},on:"lock",off:"unlock"}),i({field:"grabbable",overrideField:function(e){return e.cy().autoungrabify()?!1:void 0},on:"grabify",off:"ungrabify"}),i({field:"selected",ableField:"selectable",overrideAble:function(e){return e.cy().autounselectify()?!1:void 0},on:"select",off:"unselect"}),i({field:"selectable",overrideField:function(e){return e.cy().autounselectify()?!1:void 0},on:"selectify",off:"unselectify"}),e.elesfn.grabbed=function(){var e=this[0];return e?e._private.grabbed:void 0},i({field:"active",on:"activate",off:"unactivate"}),e.elesfn.inactive=function(){var e=this[0];return e?!e._private.active:void 0}}(cytoscape),function(e){"use strict";function t(t){return function(i){for(var r=[],n=this._private.cy,a=0;a<this.length;a++){var o=this[a],s=o._private[t.attr];s&&r.push(s)}return new e.Collection(n,r,{unique:!0}).filter(i)}}function i(t){return function(i){var r=[],n=this._private.cy,a=t||{};e.is.string(i)&&(i=n.$(i));for(var o=i.connectedEdges(),s=this._private.ids,l=0;l<o.length;l++){var u,c=o[l],d=c._private.data;if(a.thisIs){var p=d[a.thisIs];u=s[p]}else u=s[d.source]||s[d.target];u&&r.push(c)}return new e.Collection(n,r,{unique:!0})}}function r(t){var i={codirected:!1};return t=e.util.extend({},i,t),function(i){for(var r=this._private.cy,n=[],a=this.edges(),o=t,s=0;s<a.length;s++)for(var l=a[s],u=l.source()[0],c=u.id(),d=l.target()[0],p=d.id(),h=u._private.edges,v=0;v<h.length;v++){var g=h[v],f=g._private.data,y=f.target,m=f.source,x=y===p&&m===c,b=c===y&&p===m;(o.codirected&&x||!o.codirected&&(x||b))&&n.push(g)}return new e.Collection(r,n,{unique:!0}).filter(i)}}e.fn.eles({roots:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n];if(a.isNode()){var o=a.connectedEdges(function(){return this.data("target")===a.id()&&this.data("source")!==a.id()}).length>0;o||r.push(a)}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},leaves:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n];if(a.isNode()){var o=a.connectedEdges(function(){return this.data("source")===a.id()&&this.data("target")!==a.id()}).length>0;o||r.push(a)}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},outgoers:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n],o=a.id();if(a.isNode())for(var s=a._private.edges,l=0;l<s.length;l++){var u=s[l],c=u._private.data.source,d=u._private.data.target;c===o&&d!==o&&(r.push(u),r.push(u.target()[0]))}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},successors:function(t){for(var i=this,r=[],n={};;){var a=i.outgoers();if(0===a.length)break;for(var o=!1,s=0;s<a.length;s++){var l=a[s],u=l.id();n[u]||(n[u]=!0,r.push(l),o=!0)}if(!o)break;i=a}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},incomers:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n],o=a.id();if(a.isNode())for(var s=a._private.edges,l=0;l<s.length;l++){var u=s[l],c=u._private.data.source,d=u._private.data.target;d===o&&c!==o&&(r.push(u),r.push(u.source()[0]))}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},predecessors:function(t){for(var i=this,r=[],n={};;){var a=i.incomers();if(0===a.length)break;for(var o=!1,s=0;s<a.length;s++){var l=a[s],u=l.id();n[u]||(n[u]=!0,r.push(l),o=!0)}if(!o)break;i=a}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)}}),e.fn.eles({neighborhood:function(t){for(var i=[],r=this._private.cy,n=this.nodes(),a=0;a<n.length;a++)for(var o=n[a],s=o.connectedEdges(),l=0;l<s.length;l++){var u=s[l],c=u.connectedNodes().not(o);c.length>0&&i.push(c[0]),i.push(u[0])}return new e.Collection(r,i,{unique:!0}).filter(t)},closedNeighborhood:function(e){return this.neighborhood().add(this).filter(e)},openNeighborhood:function(e){return this.neighborhood(e)}}),e.fn.eles({source:function(e){var t,i=this[0];return i&&(t=i._private.source),t&&e?t.filter(e):t},target:function(e){var t,i=this[0];return i&&(t=i._private.target),t&&e?t.filter(e):t},sources:t({attr:"source"}),targets:t({attr:"target"})}),e.fn.eles({edgesWith:i(),edgesTo:i({thisIs:"source"})}),e.fn.eles({connectedEdges:function(t){for(var i=[],r=this._private.cy,n=this,a=0;a<n.length;a++){var o=n[a];if(o.isNode())for(var s=o._private.edges,l=0;l<s.length;l++){var u=s[l];i.push(u)}}return new e.Collection(r,i,{unique:!0}).filter(t)},connectedNodes:function(t){for(var i=[],r=this._private.cy,n=this,a=0;a<n.length;a++){var o=n[a];o.isEdge()&&(i.push(o.source()[0]),i.push(o.target()[0]))}return new e.Collection(r,i,{unique:!0}).filter(t)},parallelEdges:r(),codirectedEdges:r({codirected:!0})})}(cytoscape),function(e){"use strict";e.fn.eles({fit:function(){},center:function(){}})}(cytoscape),function(e){"use strict";e.Minheap=function(t,i,r){return new e.Heap(t,i,e.Heap.minHeapComparator,r)},e.Maxheap=function(t,i,r){return new e.Heap(t,i,e.Heap.maxHeapComparator,r)},e.Heap=function(t,i,r,n){if("undefined"!=typeof r&&"undefined"!=typeof i){"undefined"==typeof n&&(n=e.Heap.idFn);var a,o,s,l=[],u={},c=[],d=0;for(i=this.getArgumentAsCollection(i,t),s=i.length,d=0;s>d;d+=1){if(l.push(n.call(t,i[d],d,i)),a=i[d].id(),u.hasOwnProperty(a))throw"ERROR: Multiple items with the same id found: "+a;u[a]=d,c.push(a)}for(this._private={cy:t,heap:l,pointers:u,elements:c,comparator:r,extractor:n,length:s},d=Math.floor(s/2);d>=0;d-=1)o=this.heapify(d);return o}},e.Heap.idFn=function(e){return e.id()},e.Heap.minHeapComparator=function(e,t){return e>=t},e.Heap.maxHeapComparator=function(e,t){return t>=e},e.fn.heap=function(t){for(var i in t){var r=t[i];e.Heap.prototype[i]=r}},e.heapfn=e.Heap.prototype,e.heapfn.size=function(){return this._private.length},e.heapfn.getArgumentAsCollection=function(t,i){var r;if("undefined"==typeof i&&(i=this._private.cy),e.is.elementOrCollection(t))r=t;else{for(var n=[],a=[].concat.apply([],[t]),o=0;o<a.length;o++){var s=a[o],l=i.getElementById(s);l.length>0&&n.push(l)}r=new e.Collection(i,n)}return r},e.heapfn.isHeap=function(){var e,t,i,r,n,a=this._private.heap,o=a.length,s=this._private.comparator;for(e=0;o>e;e+=1)if(t=2*e+1,i=t+1,r=o>t?s(a[t],a[e]):!0,n=o>i?s(a[i],a[e]):!0,!r||!n)return!1;return!0},e.heapfn.heapSwap=function(e,t){var i=this._private.heap,r=this._private.pointers,n=this._private.elements,a=i[e],o=n[e],s=n[e],l=n[t];i[e]=i[t],n[e]=n[t],r[s]=t,r[l]=e,i[t]=a,n[t]=o},e.heapfn.heapify=function(e,t){var i,r,n,a,o,s,l,u=0,c=!1;for("undefined"==typeof t&&(t=!0),i=this._private.heap,u=i.length,s=this._private.comparator,r=e;!c;)t?(n=2*r+1,a=n+1,o=r,u>n&&!s(i[n],i[o])&&(o=n),u>a&&!s(i[a],i[o])&&(o=a),c=o===r,c||(this.heapSwap(o,r),r=o)):(l=Math.floor((r-1)/2),o=r,c=0>l||s(i[o],i[l]),c||(this.heapSwap(o,l),r=l))},e.heapfn.insert=function(e){var t,i,r,n,a,o=this.getArgumentAsCollection(e),s=o.length;for(a=0;s>a;a+=1){if(t=o[a],i=this._private.heap.length,r=this._private.extractor(t),n=t.id(),this._private.pointers.hasOwnProperty(n))throw"ERROR: Multiple items with the same id found: "+n;this._private.heap.push(r),this._private.elements.push(n),this._private.pointers[n]=i,this.heapify(i,!1)}this._private.length=this._private.heap.length},e.heapfn.getValueById=function(e){if(this._private.pointers.hasOwnProperty(e)){var t=this._private.pointers[e];return this._private.heap[t]}},e.heapfn.contains=function(e){for(var t=this.getArgumentAsCollection(e),i=0;i<t.length;i+=1){var r=t[i].id();if(!this._private.pointers.hasOwnProperty(r))return!1}return!0},e.heapfn.top=function(){return this._private.length>0?{value:this._private.heap[0],id:this._private.elements[0]}:void 0},e.heapfn.pop=function(){if(this._private.length>0){var e,t,i,r=this.top(),n=this._private.length-1;return this.heapSwap(0,n),e=this._private.elements[n],t=this._private.heap[n],i=e,this._private.heap.pop(),this._private.elements.pop(),this._private.length=this._private.heap.length,this._private.pointers[i]=void 0,this.heapify(0),r}},e.heapfn.findDirectionHeapify=function(e){var t=Math.floor((e-1)/2),i=this._private.heap,r=0>t||this._private.comparator(i[e],i[t]);this.heapify(e,r)},e.heapfn.edit=function(t,i){for(var r=this.getArgumentAsCollection(t),n=0;n<r.length;n+=1){var a=r[n].id(),o=this._private.pointers[a],s=this._private.heap[o];e.is.number(i)?this._private.heap[o]=i:e.is.fn(i)&&(this._private.heap[o]=i.call(this._private.cy,s,o)),this.findDirectionHeapify(o)}},e.heapfn.delete=function(e){for(var t=this.getArgumentAsCollection(e),i=0;i<t.length;i+=1){var r,n,a,o=t[i].id(),s=this._private.pointers[o],l=this._private.length-1;s!==l&&this.heapSwap(s,l),r=this._private.elements[l],n=this._private.heap[l],a=r,this._private.heap.pop(),this._private.elements.pop(),this._private.length=this._private.heap.length,this._private.pointers[a]=void 0,this.findDirectionHeapify(s)}return n}}(cytoscape),function(e){"use strict";function t(e){t.CANVAS_LAYERS=5,t.SELECT_BOX=0,t.DRAG=2,t.NODE=4,t.TEXTURE_BUFFER=0,t.BUFFER_COUNT=2,this.options=e,this.data={select:[void 0,void 0,void 0,void 0,0],renderer:this,cy:e.cy,container:e.cy.container(),canvases:new Array(t.CANVAS_LAYERS),contexts:new Array(t.CANVAS_LAYERS),canvasNeedsRedraw:new Array(t.CANVAS_LAYERS),bufferCanvases:new Array(t.BUFFER_COUNT),bufferContexts:new Array(t.CANVAS_LAYERS)},this.hoverData={down:null,last:null,downTime:null,triggerMode:null,dragging:!1,initialPan:[null,null],capture:!1},this.timeoutData={panTimeout:null},this.dragData={possibleDragElements:[]},this.touchData={start:null,capture:!1,startPosition:[null,null,null,null,null,null],singleTouchStartTime:null,singleTouchMoved:!0,now:[null,null,null,null,null,null],earlier:[null,null,null,null,null,null]},this.zoomData={freeToZoom:!1,lastPointerX:null},this.redraws=0,this.showFps=e.showFps,this.bindings=[],this.data.canvasContainer=document.createElement("div");var i=this.data.canvasContainer.style;i.position="absolute",i.zIndex="0",i.overflow="hidden",this.data.container.appendChild(this.data.canvasContainer);for(var r=0;r<t.CANVAS_LAYERS;r++)this.data.canvases[r]=document.createElement("canvas"),this.data.contexts[r]=this.data.canvases[r].getContext("2d"),this.data.canvases[r].style.position="absolute",this.data.canvases[r].setAttribute("data-id","layer"+r),this.data.canvases[r].style.zIndex=String(t.CANVAS_LAYERS-r),this.data.canvasContainer.appendChild(this.data.canvases[r]),this.data.canvasNeedsRedraw[r]=!1;this.data.topCanvas=this.data.canvases[0],this.data.canvases[t.NODE].setAttribute("data-id","layer"+t.NODE+"-node"),this.data.canvases[t.SELECT_BOX].setAttribute("data-id","layer"+t.SELECT_BOX+"-selectbox"),this.data.canvases[t.DRAG].setAttribute("data-id","layer"+t.DRAG+"-drag");for(var r=0;r<t.BUFFER_COUNT;r++)this.data.bufferCanvases[r]=document.createElement("canvas"),this.data.bufferContexts[r]=this.data.bufferCanvases[r].getContext("2d"),this.data.bufferCanvases[r].style.position="absolute",this.data.bufferCanvases[r].setAttribute("data-id","buffer"+r),this.data.bufferCanvases[r].style.zIndex=String(-r-1),this.data.bufferCanvases[r].style.visibility="hidden";this.hideEdgesOnViewport=e.hideEdgesOnViewport,this.hideLabelsOnViewport=e.hideLabelsOnViewport,this.textureOnViewport=e.textureOnViewport,this.wheelSensitivity=e.wheelSensitivity,this.motionBlurEnabled=void 0===e.motionBlur?!0:e.motionBlur,this.forcedPixelRatio=e.pixelRatio,this.motionBlur=!0,this.tapThreshold=e.tapThreshold,this.tapThreshold2=e.tapThreshold*e.tapThreshold,this.tapholdDuration=500,this.load()}t.panOrBoxSelectDelay=400,t.isTouch=e.is.touch();var i="undefined"!=typeof Path2D;t.usePaths=function(){return i},t.prototype.notify=function(i){var r;r=e.is.array(i.type)?i.type:[i.type];for(var n=0;n<r.length;n++){var a=r[n];switch(a){case"destroy":return void this.destroy();case"add":case"remove":case"load":this.updateNodesCache(),this.updateEdgesCache();break;case"viewport":this.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;break;case"style":this.updateCachedZSortedEles()}("load"===a||"resize"===a)&&(this.invalidateContainerClientCoordsCache(),this.matchCanvasSize(this.data.container))}this.data.canvasNeedsRedraw[t.NODE]=!0,this.data.canvasNeedsRedraw[t.DRAG]=!0,this.redraw()},t.prototype.destroy=function(){this.destroyed=!0;for(var e=0;e<this.bindings.length;e++){var t=this.bindings[e],i=t;i.target.removeEventListener(i.event,i.handler,i.useCapture)}this.removeObserver&&this.removeObserver.disconnect()};for(var r in e.math)t.prototype[r]=e.math[r];e("renderer","canvas",t)}(cytoscape),function(e){"use strict";var t=e("renderer","canvas"),i=t.prototype,r=t.arrowShapes={};t.arrowShapeHeight=.3;var n=function(e,t,i,r,n,a){var o=i-n/2,s=i+n/2,l=r-a/2,u=r+a/2;return e>=o&&s>=e&&t>=l&&u>=t},a=function(e,t,i,r,n){r=-r;var a=e*Math.cos(r)-t*Math.sin(r),o=e*Math.sin(r)+t*Math.cos(r),s=a*i,l=o*i,u=s+n.x,c=l+n.y;return{x:u,y:c}};r.arrow={_points:[-.15,-.3,0,0,.15,-.3],collide:function(t,i,n,a,o,s,l,u){var c=r.arrow._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.arrow._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r.triangle=r.arrow,r["triangle-backcurve"]={_ctrlPt:[0,-.15],collide:function(t,i,n,a,o,s,l,u){var c=r.triangle._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o,s=r.triangle._points,l=0;l<s.length/2;l++){var u=a(s[2*l],s[2*l+1],t,i,n);0===l&&(o=u),e.lineTo(u.x,u.y)}var c=this._ctrlPt,d=a(c[0],c[1],t,i,n);e.quadraticCurveTo(d.x,d.y,o.x,o.y)},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r["triangle-tee"]={_points:[-.15,-.3,0,0,.15,-.3,-.15,-.3],_pointsTee:[-.15,-.4,-.15,-.5,.15,-.5,.15,-.4],collide:function(t,i,n,a,o,s,l,u){var c=r["triangle-tee"]._points,d=r["triangle-tee"]._pointsTee,p=e.math.pointInsidePolygon(t,i,d,n,a,o,s,l,u)||e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u);return p},roughCollide:n,draw:function(e,t,i,n){for(var o=r["triangle-tee"]._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}var u=r["triangle-tee"]._pointsTee,c=a(u[0],u[1],t,i,n);e.moveTo(c.x,c.y);for(var s=0;s<u.length/2;s++){var l=a(u[2*s],u[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r["half-triangle-overshot"]={_points:[0,-.25,-.5,-.25,.5,.25],leavePathOpen:!0,matchEdgeWidth:!0,collide:function(t,i,r,n,a,o,s,l){var u=this._points;return e.math.pointInsidePolygon(t,i,u,r,n,a,o,s,l)},roughCollide:n,draw:function(e,t,i,r){for(var n=this._points,o=0;o<n.length/2;o++){var s=a(n[2*o],n[2*o+1],t,i,r);e.lineTo(s.x,s.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r.none={collide:function(){return!1},roughCollide:function(){return!1},draw:function(){},spacing:function(){return 0},gap:function(){return 0}},r.circle={_baseRadius:.15,collide:function(e,t,i,n,a,o,s,l){if(a!=o){var u=(o+l)/(a+l);return t/=u,n/=u,Math.pow(i-e,2)+Math.pow(n-t,2)<=Math.pow((a+l)*r.circle._baseRadius,2)}return Math.pow(i-e,2)+Math.pow(n-t,2)<=Math.pow((a+l)*r.circle._baseRadius,2)},roughCollide:n,draw:function(e,t,i,n){e.arc(n.x,n.y,r.circle._baseRadius*t,0,2*Math.PI,!1)},spacing:function(e){return i.getArrowWidth(e._private.style.width.pxValue)*r.circle._baseRadius},gap:function(e){return 2*e._private.style.width.pxValue}},r.inhibitor={_points:[-.25,0,-.25,-.1,.25,-.1,.25,0],collide:function(t,i,n,a,o,s,l,u){var c=r.inhibitor._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.inhibitor._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 1},gap:function(){return 1}},r.tee=r.inhibitor,r.square={_points:[-.15,0,.15,0,.15,-.3,-.15,-.3],collide:function(t,i,n,a,o,s,l,u){var c=r.square._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.square._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r.diamond={_points:[-.15,-.15,0,-.3,.15,-.15,0,0],collide:function(t,i,n,a,o,s,l,u){var c=r.diamond._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.diamond._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return e._private.style.width.pxValue}}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.getCachedNodes=function(){var e=this.data,t=this.data.cy;return null==e.cache&&(e.cache={}),null==e.cache.cachedNodes&&(e.cache.cachedNodes=t.nodes()),e.cache.cachedNodes},t.prototype.updateNodesCache=function(){var e=this.data,t=this.data.cy;null==e.cache&&(e.cache={}),e.cache.cachedNodes=t.nodes()},t.prototype.getCachedEdges=function(){var e=this.data,t=this.data.cy;return null==e.cache&&(e.cache={}),null==e.cache.cachedEdges&&(e.cache.cachedEdges=t.edges()),e.cache.cachedEdges},t.prototype.updateEdgesCache=function(){var e=this.data,t=this.data.cy;null==e.cache&&(e.cache={}),e.cache.cachedEdges=t.edges()}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.projectIntoViewport=function(e,t){var i=this.findContainerClientCoords(),r=i[0],n=i[1],a=e-r,o=t-n;return a-=this.data.cy.pan().x,o-=this.data.cy.pan().y,a/=this.data.cy.zoom(),o/=this.data.cy.zoom(),[a,o]},t.prototype.findContainerClientCoords=function(){var e=this.data.container,t=this.containerBB=this.containerBB||e.getBoundingClientRect();return[t.left,t.top,t.right-t.left,t.bottom-t.top]},t.prototype.invalidateContainerClientCoordsCache=function(){this.containerBB=null},t.prototype.findNearestElement=function(i,r,n){function a(e){var a=e.outerWidth(),o=e.outerHeight(),l=a/2,c=o/2,d=e._private.position;if(d.x-l<=i&&i<=d.x+l&&d.y-c<=r&&r<=d.y+c){var p=!n||e.visible()&&!e.transparent();if(n&&!p)return;var h=t.nodeShapes[s.getNodeShape(e)],g=e._private.style["border-width"].pxValue/2;h.checkPoint(i,r,g,a+v,o+v,d.x,d.y)&&u.push(e)}}function o(o){var l,c=o._private.rscratch,d=o._private.style,v=d.width.pxValue,g=v*v,f=2*v,y=o._private.source,m=o._private.target,x=!1,b=function(){if(void 0!==l)return l;if(!n)return l=!0,!0;var e=o.visible()&&!o.transparent();return e?(l=!0,!0):(l=!1,!1)};if("self"===c.edgeType)((x=e.math.inBezierVicinity(i,r,c.startX,c.startY,c.cp2ax,c.cp2ay,c.selfEdgeMidX,c.selfEdgeMidY,g))&&b()&&g+h>e.math.sqDistanceToQuadraticBezier(i,r,c.startX,c.startY,c.cp2ax,c.cp2ay,c.selfEdgeMidX,c.selfEdgeMidY)||(x=e.math.inBezierVicinity(i,r,c.selfEdgeMidX,c.selfEdgeMidY,c.cp2cx,c.cp2cy,c.endX,c.endY,g))&&b()&&g+h>e.math.sqDistanceToQuadraticBezier(i,r,c.selfEdgeMidX,c.selfEdgeMidY,c.cp2cx,c.cp2cy,c.endX,c.endY))&&u.push(o);else if("haystack"===c.edgeType){var w=d["haystack-radius"].value,_=w/2,E=m._private.position,S=m.width(),P=m.height(),D=y._private.position,k=y.width(),C=y.height(),T=D.x+c.source.x*k*_,N=D.y+c.source.y*C*_,M=E.x+c.target.x*S*_,B=E.y+c.target.y*P*_;(x=e.math.inLineVicinity(i,r,T,N,M,B,f))&&b()&&g+h>e.math.sqDistanceToFiniteLine(i,r,T,N,M,B)&&u.push(o)}else"straight"===c.edgeType?(x=e.math.inLineVicinity(i,r,c.startX,c.startY,c.endX,c.endY,f))&&b()&&g+h>e.math.sqDistanceToFiniteLine(i,r,c.startX,c.startY,c.endX,c.endY)&&u.push(o):"bezier"===c.edgeType&&(x=e.math.inBezierVicinity(i,r,c.startX,c.startY,c.cp2x,c.cp2y,c.endX,c.endY,g))&&b()&&g+h>e.math.sqDistanceToQuadraticBezier(i,r,c.startX,c.startY,c.cp2x,c.cp2y,c.endX,c.endY)&&u.push(o);if(x&&b()&&0===u.length||u[u.length-1]!==o){var I=t.arrowShapes[d["source-arrow-shape"].value],z=t.arrowShapes[d["target-arrow-shape"].value],y=y||o._private.source,m=m||o._private.target,E=m._private.position,D=y._private.position,L=s.getArrowWidth(d.width.pxValue),O=s.getArrowHeight(d.width.pxValue),R=L,X=O;(I.roughCollide(i,r,c.arrowStartX,c.arrowStartY,L,O,[c.arrowStartX-D.x,c.arrowStartY-D.y],0)&&I.collide(i,r,c.arrowStartX,c.arrowStartY,L,O,[c.arrowStartX-D.x,c.arrowStartY-D.y],0)||z.roughCollide(i,r,c.arrowEndX,c.arrowEndY,R,X,[c.arrowEndX-E.x,c.arrowEndY-E.y],0)&&z.collide(i,r,c.arrowEndX,c.arrowEndY,R,X,[c.arrowEndX-E.x,c.arrowEndY-E.y],0))&&u.push(o)}p&&u.length>0&&u[u.length-1]===o&&(a(y),a(m))}for(var s=this,l=this.getCachedZSortedEles(),u=[],c=t.isTouch,d=this.data.cy.zoom(),p=this.data.cy.hasCompoundNodes(),h=(c?256:32)/d,v=(c?16:0)/d,g=l.length-1;g>=0;g--){var f=l[g];if(u.length>0)break;"nodes"===f._private.group?a(l[g]):o(l[g])}return u.length>0?u[u.length-1]:null},t.prototype.getAllInBox=function(i,r,n,a){var o=this.getCachedNodes(),s=this.getCachedEdges(),l=[],u=Math.min(i,n),c=Math.max(i,n),d=Math.min(r,a),p=Math.max(r,a);i=u,n=c,r=d,a=p;for(var h,v=0;v<o.length;v++){var g=o[v]._private.position,f=this.getNodeShape(o[v]),y=this.getNodeWidth(o[v]),m=this.getNodeHeight(o[v]),x=o[v]._private.style["border-width"].pxValue/2,b=t.nodeShapes[f];b.intersectBox(i,r,n,a,y,m,g.x,g.y,x)&&l.push(o[v])}for(var v=0;v<s.length;v++){var w=s[v]._private.rscratch;if("self"==s[v]._private.rscratch.edgeType&&((h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,w.cp2ax,w.cp2ay,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkBezierInBox(i,r,n,a,w.startX,w.startY,w.cp2ax,w.cp2ay,w.endX,w.endY,s[v]._private.style.width.pxValue))||(h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,w.cp2cx,w.cp2cy,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkBezierInBox(i,r,n,a,w.startX,w.startY,w.cp2cx,w.cp2cy,w.endX,w.endY,s[v]._private.style.width.pxValue)))&&l.push(s[v]),"bezier"==w.edgeType&&(h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,w.cp2x,w.cp2y,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkBezierInBox(i,r,n,a,w.startX,w.startY,w.cp2x,w.cp2y,w.endX,w.endY,s[v]._private.style.width.pxValue))&&l.push(s[v]),"straight"==w.edgeType&&(h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,.5*w.startX+.5*w.endX,.5*w.startY+.5*w.endY,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkStraightEdgeInBox(i,r,n,a,w.startX,w.startY,w.endX,w.endY,s[v]._private.style.width.pxValue))&&l.push(s[v]),"haystack"==w.edgeType){var _=s[v].target()[0],E=_.position(),S=s[v].source()[0],P=S.position(),D=P.x+w.source.x,k=P.y+w.source.y,C=E.x+w.target.x,T=E.y+w.target.y,N=D>=i&&n>=D&&k>=r&&a>=k,M=C>=i&&n>=C&&T>=r&&a>=T;N&&M&&l.push(s[v])}}return l},t.prototype.getNodeWidth=function(e){return e.width()},t.prototype.getNodeHeight=function(e){return e.height()},t.prototype.getNodeShape=function(e){var t=e._private.style.shape.value;return e.isParent()?"rectangle"===t||"roundrectangle"===t?t:"rectangle":t},t.prototype.getNodePadding=function(e){var t=e._private.style["padding-left"].pxValue,i=e._private.style["padding-right"].pxValue,r=e._private.style["padding-top"].pxValue,n=e._private.style["padding-bottom"].pxValue;return isNaN(t)&&(t=0),isNaN(i)&&(i=0),isNaN(r)&&(r=0),isNaN(n)&&(n=0),{left:t,right:i,top:r,bottom:n}},t.prototype.zOrderSort=e.Collection.zIndexSort,t.prototype.updateCachedZSortedEles=function(){this.getCachedZSortedEles(!0)},t.prototype.getCachedZSortedEles=function(e){var t=this.lastZOrderCachedNodes,i=this.lastZOrderCachedEdges,r=this.getCachedNodes(),n=this.getCachedEdges(),a=[];if(!e&&t&&i&&t===r&&i===n)a=this.cachedZSortedEles;else{for(var o=0;o<r.length;o++)r[o].visible()&&!r[o].transparent()&&a.push(r[o]);for(var o=0;o<n.length;o++)n[o].visible()&&!n[o].transparent()&&a.push(n[o]);a.sort(this.zOrderSort),this.cachedZSortedEles=a}return this.lastZOrderCachedNodes=r,this.lastZOrderCachedEdges=n,a},t.prototype.projectBezier=function(t){function i(e){a.push({x:r(e[0],e[2],e[4],.05),y:r(e[1],e[3],e[5],.05)}),a.push({x:r(e[0],e[2],e[4],.25),y:r(e[1],e[3],e[5],.25)}),a.push({x:r(e[0],e[2],e[4],.4),y:r(e[1],e[3],e[5],.4)});var t={x:r(e[0],e[2],e[4],.5),y:r(e[1],e[3],e[5],.5)};a.push(t),"self"===n.edgeType?(n.midX=n.selfEdgeMidX,n.midY=n.selfEdgeMidY):(n.midX=t.x,n.midY=t.y),a.push({x:r(e[0],e[2],e[4],.6),y:r(e[1],e[3],e[5],.6)}),a.push({x:r(e[0],e[2],e[4],.75),y:r(e[1],e[3],e[5],.75)}),a.push({x:r(e[0],e[2],e[4],.95),y:r(e[1],e[3],e[5],.95)})}var r=e.math.qbezierAt,n=t._private.rscratch,a=t._private.rstyle.bezierPts=[];"self"===n.edgeType?(i([n.startX,n.startY,n.cp2ax,n.cp2ay,n.selfEdgeMidX,n.selfEdgeMidY]),i([n.selfEdgeMidX,n.selfEdgeMidY,n.cp2cx,n.cp2cy,n.endX,n.endY])):"bezier"===n.edgeType&&i([n.startX,n.startY,n.cp2x,n.cp2y,n.endX,n.endY])},t.prototype.recalculateNodeLabelProjection=function(e){var t=e._private.style.content.strValue;if(t&&!t.match(/^\\s+$/)){var i,r,n=e.outerWidth(),a=e.outerHeight(),o=e._private.position,s=e._private.style["text-halign"].strValue,l=e._private.style["text-valign"].strValue,u=e._private.rscratch,c=e._private.rstyle;switch(s){case"left":i=o.x-n/2;break;case"right":i=o.x+n/2;break;default:i=o.x}switch(l){case"top":r=o.y-a/2;break;case"bottom":r=o.y+a/2;break;default:r=o.y}u.labelX=i,u.labelY=r,c.labelX=i,c.labelY=r,this.applyLabelDimensions(e)}},t.prototype.recalculateEdgeLabelProjection=function(t){var i=t._private.style.content.strValue;if(i&&!i.match(/^\\s+$/)){var r,n,a,o,s=t._private.rscratch,l=t._private.rstyle;if("self"==s.edgeType)a=s.selfEdgeMidX,o=s.selfEdgeMidY;else if("straight"==s.edgeType)a=(s.startX+s.endX)/2,o=(s.startY+s.endY)/2;else if("bezier"==s.edgeType)a=e.math.qbezierAt(s.startX,s.cp2x,s.endX,.5),o=e.math.qbezierAt(s.startY,s.cp2y,s.endY,.5);else if("haystack"==s.edgeType){var u=t._private.source._private.position,c=t._private.target._private.position;a=(u.x+s.source.x+c.x+s.target.x)/2,o=(u.y+s.source.y+c.y+s.target.y)/2}r=a,n=o,s.labelX=r,s.labelY=n,l.labelX=r,l.labelY=n,this.applyLabelDimensions(t)}},t.prototype.applyLabelDimensions=function(e){var t=e._private.rscratch,i=e._private.rstyle,r=this.getLabelText(e),n=this.calculateLabelDimensions(e,r);i.labelWidth=n.width,t.labelWidth=n.width,i.labelHeight=n.height,t.labelHeight=n.height},t.prototype.getLabelText=function(e){var t=e._private.style,i=e._private.style.content.strValue,r=t["text-transform"].value;return"none"==r||("uppercase"==r?i=i.toUpperCase():"lowercase"==r&&(i=i.toLowerCase())),i},t.prototype.calculateLabelDimensions=function(e,t){var i=this,r=e._private.style,n=r["font-style"].strValue,a=r["font-size"].pxValue+"px",o=r["font-family"].strValue,s=r["font-weight"].strValue,l=e._private.labelKey,u=i.labelDimCache||(i.labelDimCache={});if(u[l])return u[l];var c=this.labelCalcDiv;c||(c=this.labelCalcDiv=document.createElement("div"),document.body.appendChild(c));var d=c.style;return d.fontFamily=o,d.fontStyle=n,d.fontSize=a,d.fontWeight=s,d.position="absolute",d.left="-9999px",d.top="-9999px",d.zIndex="-1",d.visibility="hidden",d.pointerEvents="none",d.padding="0",d.lineHeight="1",c.textContent=t,u[l]={width:c.clientWidth,height:c.clientHeight},u[l]},t.prototype.recalculateRenderedStyle=function(e){for(var t=[],i=[],r={},n=0;n<e.length;n++){var a=e[n],o=a._private,s=o.rscratch,l=o.rstyle,u=o.data.id,c=null!=s.boundingBoxKey&&o.boundingBoxKey===s.boundingBoxKey,d=null!=s.labelKey&&o.labelKey===s.labelKey,p=c&&d;if("nodes"===a._private.group){var h=o.position,v=null!=l.nodeX&&null!=l.nodeY&&h.x===l.nodeX&&h.y===l.nodeY;v&&p||i.push(a),l.nodeX=h.x,l.nodeY=h.y}else{var g=a._private.source._private.position,f=a._private.target._private.position,y=null!=l.srcX&&null!=l.srcY&&g.x===l.srcX&&g.y===l.srcY,m=null!=l.tgtX&&null!=l.tgtY&&f.x===l.tgtX&&f.y===l.tgtY,x=y&&m;if(!x||!p){var b=o.style["curve-style"].value;if("bezier"===b){if(!r[u]){t.push(a),r[u]=!0;for(var w=a.parallelEdges(),n=0;n<w.length;n++){var _=w[n],E=_._private.data.id;r[E]||(t.push(_),r[E]=!0)}}}else t.push(a)}l.srcX=g.x,l.srcY=g.y,l.tgtX=f.x,l.tgtY=f.y}s.boundingBoxKey=o.boundingBoxKey,s.labelKey=o.labelKey}this.recalculateEdgeProjections(t),this.recalculateLabelProjections(i,t)},t.prototype.recalculateLabelProjections=function(e,t){for(var i=0;i<e.length;i++)this.recalculateNodeLabelProjection(e[i]);for(var i=0;i<t.length;i++)this.recalculateEdgeLabelProjection(t[i])},t.prototype.recalculateEdgeProjections=function(e){this.findEdgeControlPoints(e)},t.prototype.findEdgeControlPoints=function(i){if(i&&0!==i.length){for(var r,n={},a=[],o=[],s=0;s<i.length;s++){var l=i[s],u=l._private.style,c="unbundled-bezier"===u["curve-style"].value;if("none"!==u.display.value)if("haystack"!==u["curve-style"].value){var d=l._private.data.source,p=l._private.data.target;r=d>p?p+"-"+d:d+"-"+p,c&&(r="unbundled"+l._private.data.id),null==n[r]&&(n[r]=[],a.push(r)),n[r].push(l),c&&(n[r].hasUnbundled=!0)}else o.push(l)}for(var h,v,g,f,y,m,x,b,w,_,E,S,P,D,k=0;k<a.length;k++){r=a[k];var C=n[r];if(C.sort(function(e,t){return e._private.index-t._private.index}),h=C[0]._private.source,v=C[0]._private.target,h._private.data.id>v._private.data.id){var T=h;h=v,v=T}if(g=h._private.position,f=v._private.position,y=this.getNodeWidth(h),m=this.getNodeHeight(h),x=this.getNodeWidth(v),b=this.getNodeHeight(v),w=t.nodeShapes[this.getNodeShape(h)],_=t.nodeShapes[this.getNodeShape(v)],E=h._private.style["border-width"].pxValue,S=v._private.style["border-width"].pxValue,D=!1,C.length>1&&h!==v||C.hasUnbundled){var N=w.intersectLine(g.x,g.y,y,m,f.x,f.y,E/2),M=_.intersectLine(f.x,f.y,x,b,g.x,g.y,S/2),B={x1:N[0],x2:M[0],y1:N[1],y2:M[1]},I=M[1]-N[1],z=M[0]-N[0],L=Math.sqrt(z*z+I*I),O={x:z,y:I},R={x:O.x/L,y:O.y/L};P={x:-R.y,y:R.x},(_.checkPoint(N[0],N[1],S/2,x,b,f.x,f.y)||w.checkPoint(M[0],M[1],E/2,y,m,g.x,g.y))&&(P={},D=!0)}for(var l,X,s=0;s<C.length;s++){l=C[s],X=l._private.rscratch;var V=X.lastEdgeIndex,Y=s,A=X.lastNumEdges,q=C.length,F=l._private.style,j=F["control-point-step-size"].pxValue,W=void 0!==F["control-point-distance"]?F["control-point-distance"].pxValue:void 0,H=F["control-point-weight"].value,c="unbundled-bezier"===F["curve-style"].value,$=X.lastSrcCtlPtX,Z=g.x,U=X.lastSrcCtlPtY,G=g.y,K=X.lastSrcCtlPtW,J=h.outerWidth(),Q=X.lastSrcCtlPtH,et=h.outerHeight(),tt=X.lastTgtCtlPtX,it=f.x,rt=X.lastTgtCtlPtY,nt=f.y,at=X.lastTgtCtlPtW,ot=v.outerWidth(),st=X.lastTgtCtlPtH,lt=v.outerHeight();\nif(X.badBezier=D?!0:!1,$!==Z||U!==G||K!==J||Q!==et||tt!==it||rt!==nt||at!==ot||st!==lt||!(V===Y&&A===q||c)){if(X.lastSrcCtlPtX=Z,X.lastSrcCtlPtY=G,X.lastSrcCtlPtW=J,X.lastSrcCtlPtH=et,X.lastTgtCtlPtX=it,X.lastTgtCtlPtY=nt,X.lastTgtCtlPtW=ot,X.lastTgtCtlPtH=lt,X.lastEdgeIndex=Y,X.lastNumEdges=q,h===v){X.edgeType="self";var ut=s,ct=j;c&&(ut=0,ct=W),X.cp2ax=g.x,X.cp2ay=g.y-(1+Math.pow(m,1.12)/100)*ct*(ut/3+1),X.cp2cx=h._private.position.x-(1+Math.pow(y,1.12)/100)*ct*(ut/3+1),X.cp2cy=g.y,X.selfEdgeMidX=(X.cp2ax+X.cp2cx)/2,X.selfEdgeMidY=(X.cp2ay+X.cp2cy)/2}else if(C.length%2!==1||s!==Math.floor(C.length/2)||c){var dt,pt=(.5-C.length/2+s)*j,ht=e.math.signum(pt);dt=c?W:void 0!==W?ht*W:void 0;var vt=void 0!==dt?dt:pt,gt=1-H,ft=H,yt=l._private.source!==h;yt&&(gt=H,ft=1-H);var mt={x:B.x1*gt+B.x2*ft,y:B.y1*gt+B.y2*ft};X.edgeType="bezier",X.cp2x=mt.x+P.x*vt,X.cp2y=mt.y+P.y*vt}else X.edgeType="straight";this.findEndpoints(l);var xt=!e.is.number(X.startX)||!e.is.number(X.startY),bt=!e.is.number(X.arrowStartX)||!e.is.number(X.arrowStartY),wt=!e.is.number(X.endX)||!e.is.number(X.endY),_t=!e.is.number(X.arrowEndX)||!e.is.number(X.arrowEndY),Et=3,St=this.getArrowWidth(l._private.style.width.pxValue)*t.arrowShapeHeight,Pt=Et*St,Dt=e.math.distance({x:X.cp2x,y:X.cp2y},{x:X.startX,y:X.startY}),kt=Pt>Dt,Ct=e.math.distance({x:X.cp2x,y:X.cp2y},{x:X.endX,y:X.endY}),Tt=Pt>Ct;if("bezier"===X.edgeType){var Nt=!1;if(xt||bt||kt){Nt=!0;var Mt={x:X.cp2x-g.x,y:X.cp2y-g.y},Bt=Math.sqrt(Mt.x*Mt.x+Mt.y*Mt.y),It={x:Mt.x/Bt,y:Mt.y/Bt},zt=Math.max(y,m),Lt={x:X.cp2x+2*It.x*zt,y:X.cp2y+2*It.y*zt},Ot=w.intersectLine(g.x,g.y,y,m,Lt.x,Lt.y,E/2);kt?(X.cp2x=X.cp2x+It.x*(Pt-Dt),X.cp2y=X.cp2y+It.y*(Pt-Dt)):(X.cp2x=Ot[0]+It.x*Pt,X.cp2y=Ot[1]+It.y*Pt)}if(wt||_t||Tt){Nt=!0;var Mt={x:X.cp2x-f.x,y:X.cp2y-f.y},Bt=Math.sqrt(Mt.x*Mt.x+Mt.y*Mt.y),It={x:Mt.x/Bt,y:Mt.y/Bt},zt=Math.max(y,m),Lt={x:X.cp2x+2*It.x*zt,y:X.cp2y+2*It.y*zt},Rt=_.intersectLine(f.x,f.y,x,b,Lt.x,Lt.y,S/2);Tt?(X.cp2x=X.cp2x+It.x*(Pt-Ct),X.cp2y=X.cp2y+It.y*(Pt-Ct)):(X.cp2x=Rt[0]+It.x*Pt,X.cp2y=Rt[1]+It.y*Pt)}Nt&&this.findEndpoints(l)}else"straight"===X.edgeType&&(X.midX=(Z+it)/2,X.midY=(G+nt)/2);this.projectBezier(l)}}}for(var s=0;s<o.length;s++){var l=o[s],Xt=l._private.rscratch;if(!Xt.haystack){var Vt=2*Math.random()*Math.PI;Xt.source={x:Math.cos(Vt),y:Math.sin(Vt)};var Vt=2*Math.random()*Math.PI;Xt.target={x:Math.cos(Vt),y:Math.sin(Vt)},Xt.edgeType="haystack",Xt.haystack=!0}}return n}},t.prototype.findEndpoints=function(i){var r,n=i.source()[0],a=i.target()[0],o=i._private.style["target-arrow-shape"].value,s=i._private.style["source-arrow-shape"].value,l=a._private.style["border-width"].pxValue,u=n._private.style["border-width"].pxValue,c=i._private.rscratch;if("self"==i._private.rscratch.edgeType){var d=[c.cp2cx,c.cp2cy];r=t.nodeShapes[this.getNodeShape(a)].intersectLine(a._private.position.x,a._private.position.y,this.getNodeWidth(a),this.getNodeHeight(a),d[0],d[1],l/2);var p=e.math.shortenIntersection(r,d,t.arrowShapes[o].spacing(i)),h=e.math.shortenIntersection(r,d,t.arrowShapes[o].gap(i));c.endX=h[0],c.endY=h[1],c.arrowEndX=p[0],c.arrowEndY=p[1];var d=[c.cp2ax,c.cp2ay];r=t.nodeShapes[this.getNodeShape(n)].intersectLine(n._private.position.x,n._private.position.y,this.getNodeWidth(n),this.getNodeHeight(n),d[0],d[1],u/2);var v=e.math.shortenIntersection(r,d,t.arrowShapes[s].spacing(i)),g=e.math.shortenIntersection(r,d,t.arrowShapes[s].gap(i));c.startX=g[0],c.startY=g[1],c.arrowStartX=v[0],c.arrowStartY=v[1]}else if("straight"==c.edgeType){r=t.nodeShapes[this.getNodeShape(a)].intersectLine(a._private.position.x,a._private.position.y,this.getNodeWidth(a),this.getNodeHeight(a),n.position().x,n.position().y,l/2),c.noArrowPlacement=0===r.length?!0:!1;var p=e.math.shortenIntersection(r,[n.position().x,n.position().y],t.arrowShapes[o].spacing(i)),h=e.math.shortenIntersection(r,[n.position().x,n.position().y],t.arrowShapes[o].gap(i));c.endX=h[0],c.endY=h[1],c.arrowEndX=p[0],c.arrowEndY=p[1],r=t.nodeShapes[this.getNodeShape(n)].intersectLine(n._private.position.x,n._private.position.y,this.getNodeWidth(n),this.getNodeHeight(n),a.position().x,a.position().y,u/2),c.noArrowPlacement=0===r.length?!0:!1;var v=e.math.shortenIntersection(r,[a.position().x,a.position().y],t.arrowShapes[s].spacing(i)),g=e.math.shortenIntersection(r,[a.position().x,a.position().y],t.arrowShapes[s].gap(i));c.startX=g[0],c.startY=g[1],c.arrowStartX=v[0],c.arrowStartY=v[1]}else if("bezier"==c.edgeType){var d=[c.cp2x,c.cp2y];r=t.nodeShapes[this.getNodeShape(a)].intersectLine(a._private.position.x,a._private.position.y,this.getNodeWidth(a),this.getNodeHeight(a),d[0],d[1],l/2);var p=e.math.shortenIntersection(r,d,t.arrowShapes[o].spacing(i)),h=e.math.shortenIntersection(r,d,t.arrowShapes[o].gap(i));c.endX=h[0],c.endY=h[1],c.arrowEndX=p[0],c.arrowEndY=p[1],r=t.nodeShapes[this.getNodeShape(n)].intersectLine(n._private.position.x,n._private.position.y,this.getNodeWidth(n),this.getNodeHeight(n),d[0],d[1],u/2);var v=e.math.shortenIntersection(r,d,t.arrowShapes[s].spacing(i)),g=e.math.shortenIntersection(r,d,t.arrowShapes[s].gap(i));c.startX=g[0],c.startY=g[1],c.arrowStartX=v[0],c.arrowStartY=v[1]}else if(c.isArcEdge)return},t.prototype.findEdges=function(e){for(var t=this.getCachedEdges(),i={},r=[],n=0;n<e.length;n++)i[e[n]._private.data.id]=e[n];for(var n=0;n<t.length;n++)(i[t[n]._private.data.source]||i[t[n]._private.data.target])&&r.push(t[n]);return r},t.prototype.getArrowWidth=t.prototype.getArrowHeight=function(e){var t=this.arrowWidthCache=this.arrowWidthCache||{},i=t[e];return i?i:(i=Math.max(Math.pow(13.37*e,.9),29),t[e]=i,i)}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.drawEdge=function(e,i,r){var n=i._private.rscratch,a=t.usePaths();if(!n.badBezier&&("bezier"!==n.edgeType&&"straight"!==n.edgeType||!isNaN(n.startX))){var o=i._private.style;if(!(o.width.pxValue<=0)){var s=o["overlay-padding"].pxValue,l=o["overlay-opacity"].value,u=o["overlay-color"].value;if(r){if(0===l)return;this.strokeStyle(e,u[0],u[1],u[2],l),e.lineCap="round","self"!=i._private.rscratch.edgeType||a||(e.lineCap="butt")}else{var c=o["line-color"].value;this.strokeStyle(e,c[0],c[1],c[2],o.opacity.value),e.lineCap="butt"}var d,p,h,v;h=d=i._private.source,v=p=i._private.target;var g=v._private.position,f=v.width(),y=v.height(),m=h._private.position,x=h.width(),b=h.height(),w=o.width.pxValue+(r?2*s:0),_=r?"solid":o["line-style"].value;if(e.lineWidth=w,"haystack"!==n.edgeType,"haystack"===n.edgeType){var E=o["haystack-radius"].value,S=E/2;this.drawStyledEdge(i,e,n.haystackPts=[n.source.x*x*S+m.x,n.source.y*b*S+m.y,n.target.x*f*S+g.x,n.target.y*y*S+g.y],_,w)}else if("self"===n.edgeType){var P=i._private.rscratch,D=[P.startX,P.startY,P.cp2ax,P.cp2ay,P.selfEdgeMidX,P.selfEdgeMidY,P.selfEdgeMidX,P.selfEdgeMidY,P.cp2cx,P.cp2cy,P.endX,P.endY],P=i._private.rscratch;this.drawStyledEdge(i,e,D,_,w)}else if("straight"===n.edgeType){var k=p._private.position.x-d._private.position.x,C=p._private.position.y-d._private.position.y,T=n.endX-n.startX,N=n.endY-n.startY;if(0>k*T+C*N)n.straightEdgeTooShort=!0;else{var P=n;this.drawStyledEdge(i,e,[P.startX,P.startY,P.endX,P.endY],_,w),n.straightEdgeTooShort=!1}}else{var P=n;this.drawStyledEdge(i,e,[P.startX,P.startY,P.cp2x,P.cp2y,P.endX,P.endY],_,w)}"haystack"===n.edgeType?this.drawArrowheads(e,i,r):n.noArrowPlacement!==!0&&void 0!==n.startX&&this.drawArrowheads(e,i,r)}}},t.prototype.drawStyledEdge=function(e,i,r,n){var a,o=e._private.rscratch,s=i,l=!1,u=t.usePaths();if(u){for(var c=r,d=o.pathCacheKey&&c.length===o.pathCacheKey.length,p=d,h=0;p&&h<c.length;h++)o.pathCacheKey[h]!==c[h]&&(p=!1);p?(a=i=o.pathCache,l=!0):(a=i=new Path2D,o.pathCacheKey=c,o.pathCache=a)}if(s.setLineDash)switch(n){case"dotted":s.setLineDash([1,1]);break;case"dashed":s.setLineDash([6,3]);break;case"solid":s.setLineDash([])}l||(i.beginPath&&i.beginPath(),i.moveTo(r[0],r[1]),6===r.length?i.quadraticCurveTo(r[2],r[3],r[4],r[5]):12===r.length?(i.quadraticCurveTo(r[2],r[3],r[4],r[5]),i.quadraticCurveTo(r[8],r[9],r[10],r[11])):i.lineTo(r[2],r[3])),i=s,u?i.stroke(a):i.stroke(),i.setLineDash&&i.setLineDash([])},t.prototype.drawArrowheads=function(e,t,i){function r(i,r,n,a,o){var s=g[i+"-arrow-shape"].value;if("none"!==s){var l=e.globalCompositeOperation;e.globalCompositeOperation="destination-out",d.fillStyle(e,255,255,255,1);var u="hollow"===g[i+"-arrow-fill"].value?"both":"filled",c=g[i+"-arrow-fill"].value;"half-triangle-overshot"===s&&(c="hollow",u="hollow"),d.drawArrowShape(t,i,e,u,g.width.pxValue,g[i+"-arrow-shape"].value,r,n,a,o),e.globalCompositeOperation=l;var p=g[i+"-arrow-color"].value;d.fillStyle(e,p[0],p[1],p[2],g.opacity.value),d.drawArrowShape(t,i,e,c,g.width.pxValue,g[i+"-arrow-shape"].value,r,n,a,o)}}if(!i){var n,a,o,s,l,u,c=t._private.rscratch,d=this,p="haystack"===c.edgeType,h=t.source().position(),v=t.target().position();p?(o=c.haystackPts[0],s=c.haystackPts[1],l=c.haystackPts[2],u=c.haystackPts[3]):(o=c.arrowStartX,s=c.arrowStartY,l=c.arrowEndX,u=c.arrowEndY);var g=t._private.style;n=o-h.x,a=s-h.y,p||isNaN(o)||isNaN(s)||isNaN(n)||isNaN(a)||r("source",o,s,n,a);var f=c.midX,y=c.midY;p&&(f=(o+l)/2,y=(s+u)/2),n=o-l,a=s-u,"self"===c.edgeType&&(n=1,a=-1),isNaN(f)||isNaN(y)||r("mid-target",f,y,n,a),n*=-1,a*=-1,isNaN(f)||isNaN(y)||r("mid-source",f,y,n,a),n=l-v.x,a=u-v.y,p||isNaN(l)||isNaN(u)||isNaN(n)||isNaN(a)||r("target",l,u,n,a)}},t.prototype.drawArrowShape=function(e,i,r,n,a,o,s,l,u,c){var d,p=t.usePaths(),h=e._private.rscratch,v=!1,g=r,f={x:s,y:l},y=Math.asin(c/Math.sqrt(u*u+c*c));0>u?y+=Math.PI/2:y=-(Math.PI/2+y);var m=this.getArrowWidth(a),x=t.arrowShapes[o];if(p){var b=m+"$"+o+"$"+y+"$"+s+"$"+l;h.arrowPathCacheKey=h.arrowPathCacheKey||{},h.arrowPathCache=h.arrowPathCache||{};var w=h.arrowPathCacheKey[i]===b;w?(d=r=h.arrowPathCache[i],v=!0):(d=r=new Path2D,h.arrowPathCacheKey[i]=b,h.arrowPathCache[i]=d)}r.beginPath&&r.beginPath(),v||x.draw(r,m,y,f),!x.leavePathOpen&&r.closePath&&r.closePath(),r=g,("filled"===n||"both"===n)&&(p?r.fill(d):r.fill()),("hollow"===n||"both"===n)&&(r.lineWidth=x.matchEdgeWidth?a:1,r.lineJoin="miter",p?r.stroke(d):r.stroke())}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.getCachedImage=function(e,t){var i=this,r=i.imageCache=i.imageCache||{};if(r[e]&&r[e].image)return r[e].image;var n=r[e]=r[e]||{},a=n.image=new Image;return a.addEventListener("load",t),a.src=e,a},t.prototype.drawInscribedImage=function(e,i,r){var n=this,a=r._private.position.x,o=r._private.position.y,s=r._private.style,l=s["background-fit"].value,u=s["background-position-x"],c=s["background-position-y"],d=s["background-repeat"].value,p=r.width(),h=r.height(),v=r._private.rscratch,g=s["background-clip"].value,f="node"===g,y=s["background-image-opacity"].value,m=i.width,x=i.height;if(0!==m&&0!==x){if("contain"===l){var b=Math.min(p/m,h/x);m*=b,x*=b}else if("cover"===l){var b=Math.max(p/m,h/x);m*=b,x*=b}var w=a-p/2;w+="%"===u.units?(p-m)*u.value/100:u.pxValue;var _=o-h/2;_+="%"===c.units?(h-x)*c.value/100:c.pxValue,v.pathCache&&(w-=a,_-=o,a=0,o=0);var E=e.globalAlpha;if(e.globalAlpha=y,"no-repeat"===d)f&&(e.save(),v.pathCache?e.clip(v.pathCache):(t.nodeShapes[n.getNodeShape(r)].drawPath(e,a,o,p,h),e.clip())),e.drawImage(i,0,0,i.width,i.height,w,_,m,x),f&&e.restore();else{var S=e.createPattern(i,d);e.fillStyle=S,t.nodeShapes[n.getNodeShape(r)].drawPath(e,a,o,p,h),e.translate(w,_),e.fill(),e.translate(-w,-_)}e.globalAlpha=E}}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.drawEdgeText=function(e,t){var i=t._private.style.content.strValue;if(!(!i||i.match(/^\\s+$/)||this.hideEdgesOnViewport&&(this.dragData.didDrag||this.pinching||this.hoverData.dragging||this.data.wheel||this.swipePanning))){var r=t._private.style["font-size"].pxValue*t.cy().zoom(),n=t._private.style["min-zoomed-font-size"].pxValue;if(!(n>r)){e.textAlign="center",e.textBaseline="middle";var a=t._private.rscratch;this.drawText(e,t,a.labelX,a.labelY)}}},t.prototype.drawNodeText=function(e,t){var i=t._private.style.content.strValue;if(i&&!i.match(/^\\s+$/)){var r=t._private.style["font-size"].pxValue*t.cy().zoom(),n=t._private.style["min-zoomed-font-size"].pxValue;if(!(n>r)){var a=t._private.style["text-halign"].strValue,o=t._private.style["text-valign"].strValue,s=t._private.rscratch;switch(a){case"left":e.textAlign="right";break;case"right":e.textAlign="left";break;default:e.textAlign="center"}switch(o){case"top":e.textBaseline="bottom";break;case"bottom":e.textBaseline="top";break;default:e.textBaseline="middle"}this.drawText(e,t,s.labelX,s.labelY)}}},t.prototype.getFontCache=function(e){var t;this.fontCaches=this.fontCaches||[];for(var i=0;i<this.fontCaches.length;i++)if(t=this.fontCaches[i],t.context===e)return t;return t={context:e},this.fontCaches.push(t),t},t.prototype.setupTextStyle=function(e,t){var i=t.effectiveOpacity(),r=t._private.style,n=r["font-style"].strValue,a=r["font-size"].pxValue+"px",o=r["font-family"].strValue,s=r["font-weight"].strValue,l=r["text-opacity"].value*r.opacity.value*i,u=r["text-outline-opacity"].value*l,c=r.color.value,d=r["text-outline-color"].value,p=t._private.fontKey,h=this.getFontCache(e);h.key!==p&&(e.font=n+" "+s+" "+a+" "+o,h.key=p);var v=String(r.content.value),g=r["text-transform"].value;return"none"==g||("uppercase"==g?v=v.toUpperCase():"lowercase"==g&&(v=v.toLowerCase())),e.lineJoin="round",this.fillStyle(e,c[0],c[1],c[2],l),this.strokeStyle(e,d[0],d[1],d[2],u),v},t.prototype.drawText=function(e,t,i,r){var n=t._private.style,a=t.effectiveOpacity();if(0!==a){var o=this.setupTextStyle(e,t);if(null!=o&&!isNaN(i)&&!isNaN(r)){var s=2*n["text-outline-width"].value;s>0&&(e.lineWidth=s,e.strokeText(o,i,r)),e.fillText(o,i,r)}}}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.drawNode=function(e,i,r){var n,a,o,s=this,l=i._private.style,u=i._private.rscratch,c=t.usePaths(),d=e,p=!1,h=l["overlay-padding"].pxValue,v=l["overlay-opacity"].value,g=l["overlay-color"].value;if(!r||0!==v){var f=i.effectiveOpacity();if(0!==f)if(n=this.getNodeWidth(i),a=this.getNodeHeight(i),e.lineWidth=l["border-width"].pxValue,void 0!==r&&r)v>0&&(this.fillStyle(e,g[0],g[1],g[2],v),t.nodeShapes.roundrectangle.drawPath(e,i._private.position.x,i._private.position.y,n+2*h,a+2*h),e.fill());else{var y=l["background-color"].value,m=l["border-color"].value,x=l["border-style"].value;if(this.fillStyle(e,y[0],y[1],y[2],l["background-opacity"].value*l.opacity.value*f),this.strokeStyle(e,m[0],m[1],m[2],l["border-opacity"].value*l.opacity.value*f),e.lineJoin="miter",e.setLineDash)switch(x){case"dotted":e.setLineDash([1,1]);break;case"dashed":e.setLineDash([4,2]);break;case"solid":case"double":e.setLineDash([])}var b=l["background-image"].value[2]||l["background-image"].value[1],w=l.shape.strValue,_=i._private.position;if(c){var E=w+"$"+n+"$"+a;e.translate(_.x,_.y),u.pathCacheKey===E?(o=e=u.pathCache,p=!0):(o=e=new Path2D,u.pathCacheKey=E,u.pathCache=o)}if(!p){var S=_;c&&(S={x:0,y:0}),t.nodeShapes[this.getNodeShape(i)].drawPath(e,S.x,S.y,n,a)}if(e=d,c?e.fill(o):e.fill(),void 0!==b){var P=this.getCachedImage(b,function(){s.data.canvasNeedsRedraw[t.NODE]=!0,s.data.canvasNeedsRedraw[t.DRAG]=!0,s.redraw()});P.complete&&this.drawInscribedImage(e,P,i)}var D=l["background-blacken"].value,k=l["border-width"].pxValue;if(this.hasPie(i)&&(this.drawPie(e,i),(0!==D||0!==k)&&(c||t.nodeShapes[this.getNodeShape(i)].drawPath(e,_.x,_.y,n,a))),D>0?(this.fillStyle(e,0,0,0,D),c?e.fill(o):e.fill()):0>D&&(this.fillStyle(e,255,255,255,-D),c?e.fill(o):e.fill()),k>0&&(c?e.stroke(o):e.stroke(),"double"===x)){e.lineWidth=l["border-width"].pxValue/3;var C=e.globalCompositeOperation;e.globalCompositeOperation="destination-out",c?e.stroke(o):e.stroke(),e.globalCompositeOperation=C}c&&e.translate(-_.x,-_.y),e.setLineDash&&e.setLineDash([])}}},t.prototype.hasPie=function(e){return e=e[0],e._private.hasPie},t.prototype.drawPie=function(i,r){r=r[0];var n=r._private.style["pie-size"],a=this.getNodeWidth(r),o=this.getNodeHeight(r),s=r._private.position.x,l=r._private.position.y,u=Math.min(a,o)/2,c=0,d=t.usePaths();d&&(s=0,l=0),"%"===n.units?u=u*n.value/100:void 0!==n.pxValue&&(u=n.pxValue/2);for(var p=1;p<=e.style.pieBackgroundN;p++){var h=r._private.style["pie-"+p+"-background-size"].value,v=r._private.style["pie-"+p+"-background-color"].value,g=r._private.style["pie-"+p+"-background-opacity"].value,f=h/100,y=1.5*Math.PI+2*Math.PI*c,m=2*Math.PI*f,x=y+m;0===h||c>=1||c+f>1||(i.beginPath(),i.moveTo(s,l),i.arc(s,l,u,y,x),i.closePath(),this.fillStyle(i,v[0],v[1],v[2],g),i.fill(),c+=f)}}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.getPixelRatio=function(){var e=this.data.contexts[0];if(null!=this.forcedPixelRatio)return this.forcedPixelRatio;var t=e.backingStorePixelRatio||e.webkitBackingStorePixelRatio||e.mozBackingStorePixelRatio||e.msBackingStorePixelRatio||e.oBackingStorePixelRatio||e.backingStorePixelRatio||1;return(window.devicePixelRatio||1)/t},t.prototype.paintCache=function(e){for(var t,i=this.paintCaches=this.paintCaches||[],r=!0,n=0;n<i.length;n++)if(t=i[n],t.context===e){r=!1;break}return r&&(t={context:e},i.push(t)),t},t.prototype.fillStyle=function(e,t,i,r,n){e.fillStyle="rgba("+t+","+i+","+r+","+n+")"},t.prototype.strokeStyle=function(e,t,i,r,n){e.strokeStyle="rgba("+t+","+i+","+r+","+n+")"},t.prototype.matchCanvasSize=function(e){var i,r=this.data,n=e.clientWidth,a=e.clientHeight,o=this.getPixelRatio(),s=n*o,l=a*o;if(s!==this.canvasWidth||l!==this.canvasHeight){this.fontCaches=null;var u=r.canvasContainer;u.style.width=n+"px",u.style.height=a+"px";for(var c=0;c<t.CANVAS_LAYERS;c++)i=r.canvases[c],(i.width!==s||i.height!==l)&&(i.width=s,i.height=l,i.style.width=n+"px",i.style.height=a+"px");for(var c=0;c<t.BUFFER_COUNT;c++)i=r.bufferCanvases[c],(i.width!==s||i.height!==l)&&(i.width=s,i.height=l,i.style.width=n+"px",i.style.height=a+"px");this.textureMult=1,1>=o&&(i=r.bufferCanvases[t.TEXTURE_BUFFER],this.textureMult=2,i.width=s*this.textureMult,i.height=l*this.textureMult),this.canvasWidth=s,this.canvasHeight=l}},t.prototype.renderTo=function(e,t,i,r){this.redraw({forcedContext:e,forcedZoom:t,forcedPan:i,drawAllLayers:!0,forcedPxRatio:r})},t.prototype.timeToRender=function(){return this.redrawTotalTime/this.redrawCount},t.minRedrawLimit=1e3/60,t.maxRedrawLimit=1e3,t.motionBlurDelay=100,t.prototype.redraw=function(i){function r(){function i(e,t){if(e.setTransform(1,0,0,1,0,0),"motionBlur"===t){var i=e.globalCompositeOperation;e.globalCompositeOperation="destination-out",u.fillStyle(e,255,255,255,.666),e.fillRect(0,0,u.canvasWidth,u.canvasHeight),e.globalCompositeOperation=i}else n||void 0!==t&&!t||e.clearRect(0,0,u.canvasWidth,u.canvasHeight);a||(e.translate(b.x,b.y),e.scale(m,m)),l&&e.translate(l.x,l.y),s&&e.scale(s,s)}function r(e,t){for(var i=e.eles,r=0;r<i.length;r++){var n=i[r];n.isNode()?(u.drawNode(t,n),I||u.drawNodeText(t,n),u.drawNode(t,n,!0)):B||(u.drawEdge(t,n),I||u.drawEdgeText(t,n),u.drawEdge(t,n,!0))}}var g=u.getCachedEdges(),f=d.style()._private.coreStyle,y=d.zoom(),m=void 0!==s?s:y,x=d.pan(),b={x:x.x,y:x.y};l&&(b=l),m*=c,b.x*=c,b.y*=c;var _={drag:{nodes:[],edges:[],eles:[]},nondrag:{nodes:[],edges:[],eles:[]}},E=u.textureOnViewport&&!n&&(u.pinching||u.hoverData.dragging||u.swipePanning||u.data.wheelZooming);if(E){var S;if(!u.textureCache){u.textureCache={},S=u.textureCache.bb=d.elements().boundingBox(),u.textureCache.texture=u.data.bufferCanvases[t.TEXTURE_BUFFER];var P=u.data.bufferContexts[t.TEXTURE_BUFFER];P.setTransform(1,0,0,1,0,0),P.clearRect(0,0,u.canvasWidth*u.textureMult,u.canvasHeight*u.textureMult),u.redraw({forcedContext:P,drawOnlyNodeLayer:!0,forcedPxRatio:c*u.textureMult});var D=u.textureCache.viewport={zoom:d.zoom(),pan:d.pan(),width:u.canvasWidth,height:u.canvasHeight};D.mpan={x:(0-D.pan.x)/D.zoom,y:(0-D.pan.y)/D.zoom}}h[t.DRAG]=!1,h[t.NODE]=!1;var k=p.contexts[t.NODE],C=u.textureCache.texture,D=u.textureCache.viewport;S=u.textureCache.bb,k.setTransform(1,0,0,1,0,0),k.clearRect(0,0,D.width,D.height);var T=f["outside-texture-bg-color"].value,N=f["outside-texture-bg-opacity"].value;u.fillStyle(k,T[0],T[1],T[2],N),k.fillRect(0,0,D.width,D.height);var y=d.zoom();i(k,!1),k.clearRect(D.mpan.x,D.mpan.y,D.width/D.zoom/c,D.height/D.zoom/c),k.drawImage(C,D.mpan.x,D.mpan.y,D.width/D.zoom/c,D.height/D.zoom/c)}else u.textureOnViewport&&!n&&(u.textureCache=null);var M=u.pinching||u.hoverData.dragging||u.swipePanning||u.data.wheelZooming||u.hoverData.draggingEles,B=u.hideEdgesOnViewport&&M,I=u.hideLabelsOnViewport&&M;if(h[t.DRAG]||h[t.NODE]||a||o){B||u.findEdgeControlPoints(g);for(var z=u.getCachedZSortedEles(),L=d.extent(),O=0;O<z.length;O++){var R,X=z[O],S=n?null:X.boundingBox(),V=n?!0:e.math.boundingBoxesIntersect(L,S);V&&(R=X._private.rscratch.inDragLayer?_.drag:_.nondrag,R.eles.push(X))}}var Y=h[t.DRAG]&&!h[t.NODE]&&v&&!u.clearedNodeLayerForMotionBlur;if(Y&&(u.clearedNodeLayerForMotionBlur=!0),h[t.NODE]||a||o||Y){var k=n||p.contexts[t.NODE];i(k,v&&!Y?"motionBlur":void 0),r(_.nondrag,k),a||(h[t.NODE]=!1)}if(!o&&(h[t.DRAG]||a)){var k=n||p.contexts[t.DRAG];i(k,v?"motionBlur":void 0),r(_.drag,k),a||(h[t.DRAG]=!1)}if(u.showFps||!o&&h[t.SELECT_BOX]&&!a){var k=n||p.contexts[t.SELECT_BOX];if(i(k),1==p.select[4]&&u.hoverData.selecting){var y=p.cy.zoom(),A=f["selection-box-border-width"].value/y;k.lineWidth=A,k.fillStyle="rgba("+f["selection-box-color"].value[0]+","+f["selection-box-color"].value[1]+","+f["selection-box-color"].value[2]+","+f["selection-box-opacity"].value+")",k.fillRect(p.select[0],p.select[1],p.select[2]-p.select[0],p.select[3]-p.select[1]),A>0&&(k.strokeStyle="rgba("+f["selection-box-border-color"].value[0]+","+f["selection-box-border-color"].value[1]+","+f["selection-box-border-color"].value[2]+","+f["selection-box-opacity"].value+")",k.strokeRect(p.select[0],p.select[1],p.select[2]-p.select[0],p.select[3]-p.select[1]))}if(p.bgActivePosistion&&!u.hoverData.selecting){var y=p.cy.zoom(),q=p.bgActivePosistion;k.fillStyle="rgba("+f["active-bg-color"].value[0]+","+f["active-bg-color"].value[1]+","+f["active-bg-color"].value[2]+","+f["active-bg-opacity"].value+")",k.beginPath(),k.arc(q.x,q.y,f["active-bg-size"].pxValue/y,0,2*Math.PI),k.fill()}var F=u.averageRedrawTime;if(u.showFps&&F){F=Math.round(F);var j=Math.round(1e3/F);k.setTransform(1,0,0,1,0,0),k.fillStyle="rgba(255, 0, 0, 0.75)",k.strokeStyle="rgba(255, 0, 0, 0.75)",k.lineWidth=1,k.fillText("1 frame = "+F+" ms = "+j+" fps",0,20);var W=60;k.strokeRect(0,30,250,20),k.fillRect(0,30,250*Math.min(j/W,1),20)}a||(h[t.SELECT_BOX]=!1)}var H=+new Date;void 0===u.averageRedrawTime&&(u.averageRedrawTime=H-w),void 0===u.redrawCount&&(u.redrawCount=0),u.redrawCount++,void 0===u.redrawTotalTime&&(u.redrawTotalTime=0),u.redrawTotalTime+=H-w,u.lastRedrawTime=H-w,u.averageRedrawTime=u.averageRedrawTime/2+(H-w)/2,u.currentlyDrawing=!1,u.clearingMotionBlur&&(u.clearingMotionBlur=!1,u.motionBlurCleared=!0,u.motionBlur=!0),v&&(u.motionBlurTimeout=setTimeout(function(){u.motionBlurTimeout=null,u.clearedNodeLayerForMotionBlur=!1,u.motionBlur=!1,u.clearingMotionBlur=!0,h[t.NODE]=!0,h[t.DRAG]=!0,u.redraw()},t.motionBlurDelay))}i=i||{};var n=i.forcedContext,a=i.drawAllLayers,o=i.drawOnlyNodeLayer,s=i.forcedZoom,l=i.forcedPan,u=this,c=void 0===i.forcedPxRatio?this.getPixelRatio():i.forcedPxRatio,d=u.data.cy,p=u.data,h=p.canvasNeedsRedraw,v=void 0!==i.motionBlur?i.motionBlur:u.motionBlur;v=v&&!n&&u.motionBlurEnabled,v&&u.motionBlurTimeout&&clearTimeout(u.motionBlurTimeout),!n&&this.redrawTimeout&&clearTimeout(this.redrawTimeout),this.redrawTimeout=null,void 0===this.averageRedrawTime&&(this.averageRedrawTime=0);var g=t.minRedrawLimit,f=t.maxRedrawLimit,y=this.averageRedrawTime;y=g>y?g:y,y=f>y?y:f,void 0===this.lastDrawTime&&(this.lastDrawTime=0);var m=+new Date,x=m-this.lastDrawTime,b=x>=y;if(!n){if(!b||this.currentlyDrawing)return void(this.redrawTimeout=setTimeout(function(){u.redraw()},y));this.lastDrawTime=m,this.currentlyDrawing=!0}var w=+new Date;n?r():e.util.requestAnimationFrame(r),n||u.initrender||(u.initrender=!0,d.trigger("initrender"))}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.drawPolygonPath=function(e,t,i,r,n,a){var o=r/2,s=n/2;e.beginPath&&e.beginPath(),e.moveTo(t+o*a[0],i+s*a[1]);for(var l=1;l<a.length/2;l++)e.lineTo(t+o*a[2*l],i+s*a[2*l+1]);e.closePath()},t.prototype.drawPolygon=function(e,t,i,r,n,a){this.drawPolygonPath(e,t,i,r,n,a),e.fill()},t.prototype.drawRoundRectanglePath=function(t,i,r,n,a){var o=n/2,s=a/2,l=e.math.getRoundRectangleRadius(n,a);t.beginPath&&t.beginPath(),t.moveTo(i,r-s),t.arcTo(i+o,r-s,i+o,r,l),t.arcTo(i+o,r+s,i,r+s,l),t.arcTo(i-o,r+s,i-o,r,l),t.arcTo(i-o,r-s,i,r-s,l),t.lineTo(i,r-s),t.closePath()},t.prototype.drawRoundRectangle=function(e,t,i,r,n,a){this.drawRoundRectanglePath(e,t,i,r,n,a),e.fill()}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.createBuffer=function(e,t){var i=document.createElement("canvas");return i.width=e,i.height=t,[i,i.getContext("2d")]},t.prototype.bufferCanvasImage=function(e){var t=this.data,i=t.cy,r=i.elements().boundingBox(),n=e.full?Math.ceil(r.w):this.data.container.clientWidth,a=e.full?Math.ceil(r.h):this.data.container.clientHeight,o=1;void 0!==e.scale&&(n*=e.scale,a*=e.scale,o=e.scale);var s=document.createElement("canvas");s.width=n,s.height=a,s.style.width=n+"px",s.style.height=a+"px";var l=s.getContext("2d");if(n>0&&a>0)if(l.clearRect(0,0,n,a),e.bg&&(l.fillStyle=e.bg,l.rect(0,0,n,a),l.fill()),l.globalCompositeOperation="source-over",e.full)this.redraw({forcedContext:l,drawAllLayers:!0,forcedZoom:o,forcedPan:{x:-r.x1*o,y:-r.y1*o},forcedPxRatio:1});else{var u=i.pan(),c={x:u.x*o,y:u.y*o},d=i.zoom()*o;this.redraw({forcedContext:l,drawAllLayers:!0,forcedZoom:d,forcedPan:c,forcedPxRatio:1})}return s},t.prototype.png=function(e){return this.bufferCanvasImage(e).toDataURL("image/png")}}(cytoscape),function(e){"use strict";var t=e("renderer","canvas");t.prototype.registerBinding=function(e,t,i,r){this.bindings.push({target:e,event:t,handler:i,useCapture:r}),e.addEventListener(t,i,r)},t.prototype.nodeIsDraggable=function(e){return 0!==e._private.style.opacity.value&&"visible"==e._private.style.visibility.value&&"element"==e._private.style.display.value&&!e.locked()&&e.grabbable()?!0:!1},t.prototype.load=function(){var i=this,r=function(e){var t;if(e.addToList&&i.data.cy.hasCompoundNodes()){if(!e.addToList.hasId){e.addToList.hasId={};for(var r=0;r<e.addToList.length;r++){var n=e.addToList[r];e.addToList.hasId[n.id()]=!0}}t=e.addToList.hasId}return t||{}},n=function(e,t){if(e._private.cy.hasCompoundNodes())for(var i=r(t),n=e.descendants(),a=0;a<n.size();a++){var o=n[a],s=o._private;t.inDragLayer&&(s.rscratch.inDragLayer=!0),t.addToList&&!i[o.id()]&&(t.addToList.push(o),i[o.id()]=!0,s.grabbed=!0);for(var l=s.edges,u=0;t.inDragLayer&&u<l.length;u++)l[u]._private.rscratch.inDragLayer=!0}},a=function(e,t){var i=e._private,a=r(t);t.inDragLayer&&(i.rscratch.inDragLayer=!0),t.addToList&&!a[e.id()]&&(t.addToList.push(e),a[e.id()]=!0,i.grabbed=!0);for(var s=i.edges,l=0;t.inDragLayer&&l<s.length;l++)s[l]._private.rscratch.inDragLayer=!0;n(e,t),o(e,{inDragLayer:!0})},o=function(e,t){var i=e;if(e._private.cy.hasCompoundNodes()){for(;i.parent().nonempty();)i=i.parent()[0];if(i!=e){for(var n=i.descendants().add(i).not(e).not(e.descendants()),a=n.connectedEdges(),o=r(t),s=0;s<n.size();s++)void 0!==t.inDragLayer&&(n[s]._private.rscratch.inDragLayer=t.inDragLayer),t.addToList&&!o[n[s].id()]&&(t.addToList.push(n[s]),o[n[s].id()]=!0,n[s]._private.grabbed=!0);for(var l=0;void 0!==t.inDragLayer&&l<a.length;l++)a[l]._private.rscratch.inDragLayer=t.inDragLayer}}};"undefined"!=typeof MutationObserver?(i.removeObserver=new MutationObserver(function(e){for(var t=0;t<e.length;t++){var r=e[t],n=r.removedNodes;if(n)for(var a=0;a<n.length;a++){var o=n[a];if(o===i.data.container){i.destroy();break}}}}),i.removeObserver.observe(i.data.container.parentNode,{childList:!0})):i.registerBinding(i.data.container,"DOMNodeRemoved",function(){i.destroy()}),i.registerBinding(window,"resize",e.util.debounce(function(){i.invalidateContainerClientCoordsCache(),i.matchCanvasSize(i.data.container),i.data.canvasNeedsRedraw[t.NODE]=!0,i.redraw()},100));for(var s=function(e){i.registerBinding(e,"scroll",function(){i.invalidateContainerClientCoordsCache()})},l=i.data.cy.container();s(l),l.parentNode;)l=l.parentNode;i.registerBinding(i.data.container,"contextmenu",function(e){e.preventDefault()});var u=function(){return 0!==i.data.select[4]};i.registerBinding(i.data.container,"mousedown",function(r){r.preventDefault(),i.hoverData.capture=!0,i.hoverData.which=r.which;var n=i.data.cy,o=i.projectIntoViewport(r.clientX,r.clientY),s=i.data.select,l=i.findNearestElement(o[0],o[1],!0),u=i.dragData.possibleDragElements;i.hoverData.mdownPos=o;var c=function(){i.hoverData.tapholdCancelled=!1,clearTimeout(i.hoverData.tapholdTimeout),i.hoverData.tapholdTimeout=setTimeout(function(){if(!i.hoverData.tapholdCancelled){var t=i.hoverData.down;t?t.trigger(new e.Event(r,{type:"taphold",cyPosition:{x:o[0],y:o[1]}})):n.trigger(new e.Event(r,{type:"taphold",cyPosition:{x:o[0],y:o[1]}}))}},i.tapholdDuration)};if(3==r.which){i.hoverData.cxtStarted=!0;var d=new e.Event(r,{type:"cxttapstart",cyPosition:{x:o[0],y:o[1]}});l?(l.activate(),l.trigger(d),i.hoverData.down=l):n.trigger(d),i.hoverData.downTime=(new Date).getTime(),i.hoverData.cxtDragged=!1}else if(1==r.which){if(l&&l.activate(),null!=l){if(i.nodeIsDraggable(l)){var p=new e.Event(r,{type:"grab",cyPosition:{x:o[0],y:o[1]}});if(l.isNode()&&!l.selected())u=i.dragData.possibleDragElements=[],a(l,{addToList:u}),l.trigger(p);else if(l.isNode()&&l.selected()){u=i.dragData.possibleDragElements=[];for(var h=n.$(function(){return this.isNode()&&this.selected()}),v=0;v<h.length;v++)i.nodeIsDraggable(h[v])&&a(h[v],{addToList:u});l.trigger(p)}i.data.canvasNeedsRedraw[t.NODE]=!0,i.data.canvasNeedsRedraw[t.DRAG]=!0}l.trigger(new e.Event(r,{type:"mousedown",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:"tapstart",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:"vmousedown",cyPosition:{x:o[0],y:o[1]}}))}else null==l&&n.trigger(new e.Event(r,{type:"mousedown",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:"tapstart",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:"vmousedown",cyPosition:{x:o[0],y:o[1]}}));if(i.hoverData.down=l,i.hoverData.downTime=(new Date).getTime(),null==l||l.isEdge()){s[4]=1;var g=Math.max(0,t.panOrBoxSelectDelay-(+new Date-i.hoverData.downTime));clearTimeout(i.bgActiveTimeout),n.boxSelectionEnabled()||l&&l.isEdge()?i.bgActiveTimeout=setTimeout(function(){l&&l.unactivate(),i.data.bgActivePosistion={x:o[0],y:o[1]},c(),i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()},g):(i.data.bgActivePosistion={x:o[0],y:o[1]},c(),i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw())}}s[0]=s[2]=o[0],s[1]=s[3]=o[1]},!1),i.registerBinding(window,"mousemove",e.util.throttle(function(r){var n=!1,o=i.hoverData.capture;if(!o){var s=i.findContainerClientCoords();if(!(r.clientX>s[0]&&r.clientX<s[0]+i.canvasWidth&&r.clientY>s[1]&&r.clientY<s[1]+i.canvasHeight))return;for(var l=i.data.container,u=r.target,c=u.parentNode,d=!1;c;){if(c===l){d=!0;break}c=c.parentNode}if(!d)return}var p=i.data.cy,h=p.zoom(),v=(p.pan(),i.projectIntoViewport(r.clientX,r.clientY)),g=i.data.select,f=null;i.hoverData.draggingEles||(f=i.findNearestElement(v[0],v[1],!0));var y=i.hoverData.last,m=i.hoverData.down,x=[v[0]-g[2],v[1]-g[3]],b=i.dragData.possibleDragElements,w=g[2]-g[0],_=w*w,E=g[3]-g[1],S=E*E,P=_+S,D=P*h*h;i.hoverData.tapholdCancelled=!0;var k=function(){var e=i.hoverData.dragDelta=i.hoverData.dragDelta||[];0===e.length?(e.push(0),e.push(0)):(e[0]+=x[0],e[1]+=x[1])};if(n=!0,null!=f?f.trigger(new e.Event(r,{type:"mousemove",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:"vmousemove",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:"tapdrag",cyPosition:{x:v[0],y:v[1]}})):null==f&&p.trigger(new e.Event(r,{type:"mousemove",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:"vmousemove",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:"tapdrag",cyPosition:{x:v[0],y:v[1]}})),3===i.hoverData.which){var C=new e.Event(r,{type:"cxtdrag",cyPosition:{x:v[0],y:v[1]}});\nm?m.trigger(C):p.trigger(C),i.hoverData.cxtDragged=!0,i.hoverData.cxtOver&&f===i.hoverData.cxtOver||(i.hoverData.cxtOver&&i.hoverData.cxtOver.trigger(new e.Event(r,{type:"cxtdragout",cyPosition:{x:v[0],y:v[1]}})),i.hoverData.cxtOver=f,f&&f.trigger(new e.Event(r,{type:"cxtdragover",cyPosition:{x:v[0],y:v[1]}})))}else if(i.hoverData.dragging){if(n=!0,p.panningEnabled()&&p.userPanningEnabled()){var T;if(i.hoverData.justStartedPan){var N=i.hoverData.mdownPos;T={x:(v[0]-N[0])*h,y:(v[1]-N[1])*h},i.hoverData.justStartedPan=!1}else T={x:x[0]*h,y:x[1]*h};p.panBy(T)}v=i.projectIntoViewport(r.clientX,r.clientY)}else if(1==g[4]&&(null==m||m.isEdge())&&(!p.boxSelectionEnabled()||+new Date-i.hoverData.downTime>=t.panOrBoxSelectDelay)&&!i.hoverData.selecting&&D>=i.tapThreshold2&&p.panningEnabled()&&p.userPanningEnabled())i.hoverData.dragging=!0,i.hoverData.selecting=!1,i.hoverData.justStartedPan=!0,g[4]=0;else{if(p.boxSelectionEnabled()&&Math.pow(g[2]-g[0],2)+Math.pow(g[3]-g[1],2)>7&&g[4]&&(clearTimeout(i.bgActiveTimeout),i.data.bgActivePosistion=void 0,i.hoverData.selecting=!0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()),m&&m.isEdge()&&m.active()&&m.unactivate(),f!=y&&(y&&(y.trigger(new e.Event(r,{type:"mouseout",cyPosition:{x:v[0],y:v[1]}})),y.trigger(new e.Event(r,{type:"tapdragout",cyPosition:{x:v[0],y:v[1]}}))),f&&(f.trigger(new e.Event(r,{type:"mouseover",cyPosition:{x:v[0],y:v[1]}})),f.trigger(new e.Event(r,{type:"tapdragover",cyPosition:{x:v[0],y:v[1]}}))),i.hoverData.last=f),m&&m.isNode()&&i.nodeIsDraggable(m))if(D>=i.tapThreshold2){var M=!i.dragData.didDrag;M&&(i.data.canvasNeedsRedraw[t.NODE]=!0),i.dragData.didDrag=!0;for(var B=[],I=0;I<b.length;I++){var z=b[I];if(i.hoverData.draggingEles||a(z,{inDragLayer:!0}),z.isNode()&&i.nodeIsDraggable(z)&&z.grabbed()){var L=z._private.position;if(B.push(z),e.is.number(x[0])&&e.is.number(x[1])&&(L.x+=x[0],L.y+=x[1],M)){var O=i.hoverData.dragDelta;e.is.number(O[0])&&e.is.number(O[1])&&(L.x+=O[0],L.y+=O[1])}}}i.hoverData.draggingEles=!0;var R=new e.Collection(p,B);R.updateCompoundBounds(),R.trigger("position drag"),i.data.canvasNeedsRedraw[t.DRAG]=!0,i.redraw()}else k();n=!0}return g[2]=v[0],g[3]=v[1],n?(r.stopPropagation&&r.stopPropagation(),r.preventDefault&&r.preventDefault(),!1):void 0},1e3/30,{trailing:!0}),!1),i.registerBinding(window,"mouseup",function(r){var n=i.hoverData.capture;if(n){i.hoverData.capture=!1;var a=i.data.cy,s=i.projectIntoViewport(r.clientX,r.clientY),l=i.data.select,u=i.findNearestElement(s[0],s[1],!0),c=i.dragData.possibleDragElements,d=i.hoverData.down,p=r.shiftKey;if(i.data.bgActivePosistion&&(i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()),i.data.bgActivePosistion=void 0,clearTimeout(i.bgActiveTimeout),i.hoverData.cxtStarted=!1,i.hoverData.draggingEles=!1,i.hoverData.selecting=!1,d&&d.unactivate(),3===i.hoverData.which){var h=new e.Event(r,{type:"cxttapend",cyPosition:{x:s[0],y:s[1]}});if(d?d.trigger(h):a.trigger(h),!i.hoverData.cxtDragged){var v=new e.Event(r,{type:"cxttap",cyPosition:{x:s[0],y:s[1]}});d?d.trigger(v):a.trigger(v)}i.hoverData.cxtDragged=!1,i.hoverData.which=null}else{if(null!=d||i.dragData.didDrag||Math.pow(l[2]-l[0],2)+Math.pow(l[3]-l[1],2)>7&&l[4]||i.hoverData.dragging||(a.$(function(){return this.selected()}).unselect(),c.length>0&&(i.data.canvasNeedsRedraw[t.NODE]=!0),i.dragData.possibleDragElements=c=[]),null!=u?u.trigger(new e.Event(r,{type:"mouseup",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"tapend",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"vmouseup",cyPosition:{x:s[0],y:s[1]}})):null==u&&a.trigger(new e.Event(r,{type:"mouseup",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"tapend",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"vmouseup",cyPosition:{x:s[0],y:s[1]}})),Math.pow(l[2]-l[0],2)+Math.pow(l[3]-l[1],2)===0&&(null!=u?u.trigger(new e.Event(r,{type:"click",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"tap",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"vclick",cyPosition:{x:s[0],y:s[1]}})):null==u&&a.trigger(new e.Event(r,{type:"click",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"tap",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:"vclick",cyPosition:{x:s[0],y:s[1]}}))),u!=d||i.dragData.didDrag||null!=u&&u._private.selectable&&(i.hoverData.dragging||("additive"===a.selectionType()||p?u.selected()?u.unselect():u.select():p||(a.$(":selected").not(u).unselect(),u.select())),i.data.canvasNeedsRedraw[t.NODE]=!0),a.boxSelectionEnabled()&&Math.pow(l[2]-l[0],2)+Math.pow(l[3]-l[1],2)>7&&l[4]){var g=[],f=i.getAllInBox(l[0],l[1],l[2],l[3]);i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,f.length>0&&(i.data.canvasNeedsRedraw[t.NODE]=!0);for(var y=0;y<f.length;y++)f[y]._private.selectable&&g.push(f[y]);var m=new e.Collection(a,g);"additive"===a.selectionType()?m.select():(p||a.$(":selected").not(m).unselect(),m.select()),i.redraw()}if(i.hoverData.dragging&&(i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()),i.hoverData.dragging=!1,!l[4]){i.data.canvasNeedsRedraw[t.DRAG]=!0,i.data.canvasNeedsRedraw[t.NODE]=!0;for(var y=0;y<c.length;y++)if("nodes"===c[y]._private.group){c[y]._private.rscratch.inDragLayer=!1,c[y]._private.grabbed=!1;for(var x=c[y]._private.edges,b=0;b<x.length;b++)x[b]._private.rscratch.inDragLayer=!1;o(c[y],{inDragLayer:!1})}else"edges"===c[y]._private.group&&(c[y]._private.rscratch.inDragLayer=!1);d&&d.trigger("free")}}l[4]=0,i.hoverData.down=null,i.dragData.didDrag=!1,i.hoverData.dragDelta=[]}},!1);var c=function(e){if(!i.scrollingPage){var r=i.data.cy,n=i.projectIntoViewport(e.clientX,e.clientY),a=[n[0]*r.zoom()+r.pan().x,n[1]*r.zoom()+r.pan().y];if(i.hoverData.draggingEles||i.hoverData.dragging||i.hoverData.cxtStarted||u())return void e.preventDefault();if(r.panningEnabled()&&r.userPanningEnabled()&&r.zoomingEnabled()&&r.userZoomingEnabled()){e.preventDefault(),i.data.wheelZooming=!0,clearTimeout(i.data.wheelTimeout),i.data.wheelTimeout=setTimeout(function(){i.data.wheelZooming=!1,i.data.canvasNeedsRedraw[t.NODE]=!0,i.redraw()},150);var o=e.deltaY/-250||e.wheelDeltaY/1e3||e.wheelDelta/1e3;o*=i.wheelSensitivity;var s=1===e.deltaMode;s&&(o*=33),r.zoom({level:r.zoom()*Math.pow(10,o),renderedPosition:{x:a[0],y:a[1]}})}}};i.registerBinding(i.data.container,"wheel",c,!0),i.registerBinding(window,"scroll",function(){i.scrollingPage=!0,clearTimeout(i.scrollingPageTimeout),i.scrollingPageTimeout=setTimeout(function(){i.scrollingPage=!1},250)},!0),i.registerBinding(i.data.container,"mouseout",function(t){var r=i.projectIntoViewport(t.clientX,t.clientY);i.data.cy.trigger(new e.Event(t,{type:"mouseout",cyPosition:{x:r[0],y:r[1]}}))},!1),i.registerBinding(i.data.container,"mouseover",function(t){var r=i.projectIntoViewport(t.clientX,t.clientY);i.data.cy.trigger(new e.Event(t,{type:"mouseover",cyPosition:{x:r[0],y:r[1]}}))},!1);var d,p,h,v,g,f,y,m,x,b,w,_,E,S=function(e,t,i,r){return Math.sqrt((i-e)*(i-e)+(r-t)*(r-t))},P=function(e,t,i,r){return(i-e)*(i-e)+(r-t)*(r-t)};i.registerBinding(i.data.container,"touchstart",function(r){clearTimeout(this.threeFingerSelectTimeout),r.target!==i.data.link&&r.preventDefault(),i.touchData.capture=!0,i.data.bgActivePosistion=void 0;var n=i.data.cy,o=i.getCachedNodes(),s=i.getCachedEdges(),l=i.touchData.now,u=i.touchData.earlier;if(r.touches[0]){var c=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=c[0],l[1]=c[1]}if(r.touches[1]){var c=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);l[2]=c[0],l[3]=c[1]}if(r.touches[2]){var c=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);l[4]=c[0],l[5]=c[1]}if(r.touches[1]){var D=function(e){for(var t=0;t<e.length;t++)e[t]._private.grabbed=!1,e[t]._private.rscratch.inDragLayer=!1,e[t].active()&&e[t].unactivate()};D(o),D(s);var k=i.findContainerClientCoords();x=k[0],b=k[1],w=k[2],_=k[3],d=r.touches[0].clientX-x,p=r.touches[0].clientY-b,h=r.touches[1].clientX-x,v=r.touches[1].clientY-b,E=d>=0&&w>=d&&h>=0&&w>=h&&p>=0&&_>=p&&v>=0&&_>=v;var C=n.pan(),T=n.zoom();g=S(d,p,h,v),f=P(d,p,h,v),y=[(d+h)/2,(p+v)/2],m=[(y[0]-C.x)/T,(y[1]-C.y)/T];var N=200,M=N*N;if(M>f&&!r.touches[2]){var B=i.findNearestElement(l[0],l[1],!0),I=i.findNearestElement(l[2],l[3],!0);return B&&B.isNode()?(B.activate().trigger(new e.Event(r,{type:"cxttapstart",cyPosition:{x:l[0],y:l[1]}})),i.touchData.start=B):I&&I.isNode()?(I.activate().trigger(new e.Event(r,{type:"cxttapstart",cyPosition:{x:l[0],y:l[1]}})),i.touchData.start=I):(n.trigger(new e.Event(r,{type:"cxttapstart",cyPosition:{x:l[0],y:l[1]}})),i.touchData.start=null),i.touchData.start&&(i.touchData.start._private.grabbed=!1),i.touchData.cxt=!0,i.touchData.cxtDragged=!1,i.data.bgActivePosistion=void 0,void i.redraw()}}if(r.touches[2]);else if(r.touches[1]);else if(r.touches[0]){var z=i.findNearestElement(l[0],l[1],!0);if(null!=z){if(z.activate(),i.touchData.start=z,z.isNode()&&i.nodeIsDraggable(z)){var L=i.dragData.touchDragEles=[];if(i.data.canvasNeedsRedraw[t.NODE]=!0,i.data.canvasNeedsRedraw[t.DRAG]=!0,z.selected())for(var O=n.$(function(){return this.isNode()&&this.selected()}),R=0;R<O.length;R++){var X=O[R];i.nodeIsDraggable(X)&&a(X,{addToList:L})}else a(z,{addToList:L});z.trigger(new e.Event(r,{type:"grab",cyPosition:{x:l[0],y:l[1]}}))}z.trigger(new e.Event(r,{type:"touchstart",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:"tapstart",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:"vmousdown",cyPosition:{x:l[0],y:l[1]}}))}null==z&&(n.trigger(new e.Event(r,{type:"touchstart",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:"tapstart",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:"vmousedown",cyPosition:{x:l[0],y:l[1]}})),i.data.bgActivePosistion={x:c[0],y:c[1]},i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw());for(var V=0;V<l.length;V++)u[V]=l[V],i.touchData.startPosition[V]=l[V];i.touchData.singleTouchMoved=!1,i.touchData.singleTouchStartTime=+new Date,clearTimeout(i.touchData.tapholdTimeout),i.touchData.tapholdTimeout=setTimeout(function(){i.touchData.singleTouchMoved!==!1||i.pinching||(i.touchData.start?i.touchData.start.trigger(new e.Event(r,{type:"taphold",cyPosition:{x:l[0],y:l[1]}})):(i.data.cy.trigger(new e.Event(r,{type:"taphold",cyPosition:{x:l[0],y:l[1]}})),n.$(":selected").unselect()))},i.tapholdDuration)}},!1),i.registerBinding(window,"touchmove",e.util.throttle(function(r){var n=i.data.select,o=i.touchData.capture;o&&r.preventDefault();var s=i.data.cy,l=i.touchData.now,u=i.touchData.earlier,c=s.zoom();if(r.touches[0]){var y=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=y[0],l[1]=y[1]}if(r.touches[1]){var y=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);l[2]=y[0],l[3]=y[1]}if(r.touches[2]){var y=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);l[4]=y[0],l[5]=y[1]}for(var w=[],_=0;_<l.length;_++)w[_]=l[_]-u[_];var D=i.touchData.startPosition,k=l[0]-D[0],C=k*k,T=l[1]-D[1],N=T*T,M=C+N,B=M*c*c;if(o&&i.touchData.cxt){var I=r.touches[0].clientX-x,z=r.touches[0].clientY-b,L=r.touches[1].clientX-x,O=r.touches[1].clientY-b,R=P(I,z,L,O),X=R/f,V=150,Y=V*V,A=1.5,q=A*A;if(X>=q||R>=Y){i.touchData.cxt=!1,i.touchData.start&&(i.touchData.start.unactivate(),i.touchData.start=null),i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;var F=new e.Event(r,{type:"cxttapend",cyPosition:{x:l[0],y:l[1]}});i.touchData.start?i.touchData.start.trigger(F):s.trigger(F)}}if(o&&i.touchData.cxt){var F=new e.Event(r,{type:"cxtdrag",cyPosition:{x:l[0],y:l[1]}});i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.touchData.start?i.touchData.start.trigger(F):s.trigger(F),i.touchData.start&&(i.touchData.start._private.grabbed=!1),i.touchData.cxtDragged=!0;var j=i.findNearestElement(l[0],l[1],!0);i.touchData.cxtOver&&j===i.touchData.cxtOver||(i.touchData.cxtOver&&i.touchData.cxtOver.trigger(new e.Event(r,{type:"cxtdragout",cyPosition:{x:l[0],y:l[1]}})),i.touchData.cxtOver=j,j&&j.trigger(new e.Event(r,{type:"cxtdragover",cyPosition:{x:l[0],y:l[1]}})))}else if(o&&r.touches[2]&&s.boxSelectionEnabled())i.data.bgActivePosistion=void 0,clearTimeout(this.threeFingerSelectTimeout),this.lastThreeTouch=+new Date,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,n&&0!==n.length&&void 0!==n[0]?(n[2]=(l[0]+l[2]+l[4])/3,n[3]=(l[1]+l[3]+l[5])/3):(n[0]=(l[0]+l[2]+l[4])/3,n[1]=(l[1]+l[3]+l[5])/3,n[2]=(l[0]+l[2]+l[4])/3+1,n[3]=(l[1]+l[3]+l[5])/3+1),n[4]=1,i.redraw();else if(o&&r.touches[1]&&s.zoomingEnabled()&&s.panningEnabled()&&s.userZoomingEnabled()&&s.userPanningEnabled()){i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;var W=i.dragData.touchDragEles;if(W){i.data.canvasNeedsRedraw[t.DRAG]=!0;for(var H=0;H<W.length;H++)W[H]._private.grabbed=!1,W[H]._private.rscratch.inDragLayer=!1}var I=r.touches[0].clientX-x,z=r.touches[0].clientY-b,L=r.touches[1].clientX-x,O=r.touches[1].clientY-b,$=S(I,z,L,O),Z=$/g;if(1!=Z&&E){var U=I-d,G=z-p,K=L-h,J=O-v,Q=(U+K)/2,et=(G+J)/2,tt=s.zoom(),it=tt*Z,rt=s.pan(),nt=m[0]*tt+rt.x,at=m[1]*tt+rt.y,ot={x:-it/tt*(nt-rt.x-Q)+nt,y:-it/tt*(at-rt.y-et)+at};if(i.touchData.start){var W=i.dragData.touchDragEles;if(W)for(var H=0;H<W.length;H++)W[H]._private.grabbed=!1,W[H]._private.rscratch.inDragLayer=!1;i.touchData.start._private.active=!1,i.touchData.start._private.grabbed=!1,i.touchData.start._private.rscratch.inDragLayer=!1,i.data.canvasNeedsRedraw[t.DRAG]=!0,i.touchData.start.trigger("free").trigger("unactivate")}s.viewport({zoom:it,pan:ot,cancelOnFailedZoom:!0}),g=$,d=I,p=z,h=L,v=O,i.pinching=!0}if(r.touches[0]){var y=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=y[0],l[1]=y[1]}if(r.touches[1]){var y=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);l[2]=y[0],l[3]=y[1]}if(r.touches[2]){var y=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);l[4]=y[0],l[5]=y[1]}}else if(r.touches[0]){var st=i.touchData.start,lt=i.touchData.last,j=j||i.findNearestElement(l[0],l[1],!0);if(null!=st&&"nodes"==st._private.group&&i.nodeIsDraggable(st))if(B>=i.tapThreshold2){for(var W=i.dragData.touchDragEles,ut=0;ut<W.length;ut++){var ct=W[ut];if(i.nodeIsDraggable(ct)&&ct.isNode()&&ct.grabbed()){i.dragData.didDrag=!0;var dt=ct._private.position,pt=!i.hoverData.draggingEles;if(e.is.number(w[0])&&e.is.number(w[1])&&(dt.x+=w[0],dt.y+=w[1]),pt){a(ct,{inDragLayer:!0});var ht=i.touchData.dragDelta;e.is.number(ht[0])&&e.is.number(ht[1])&&(dt.x+=ht[0],dt.y+=ht[1])}}}var vt=new e.Collection(s,ct);vt.updateCompoundBounds(),vt.trigger("position drag"),i.hoverData.draggingEles=!0,i.data.canvasNeedsRedraw[t.DRAG]=!0,i.touchData.startPosition[0]==u[0]&&i.touchData.startPosition[1]==u[1]&&(i.data.canvasNeedsRedraw[t.NODE]=!0),i.redraw()}else{var ht=i.touchData.dragDelta=i.touchData.dragDelta||[];0===ht.length?(ht.push(0),ht.push(0)):(ht[0]+=w[0],ht[1]+=w[1])}null!=st&&(st.trigger(new e.Event(r,{type:"touchmove",cyPosition:{x:l[0],y:l[1]}})),st.trigger(new e.Event(r,{type:"tapdrag",cyPosition:{x:l[0],y:l[1]}})),st.trigger(new e.Event(r,{type:"vmousemove",cyPosition:{x:l[0],y:l[1]}}))),null==st&&(null!=j&&(j.trigger(new e.Event(r,{type:"touchmove",cyPosition:{x:l[0],y:l[1]}})),j.trigger(new e.Event(r,{type:"tapdrag",cyPosition:{x:l[0],y:l[1]}})),j.trigger(new e.Event(r,{type:"vmousemove",cyPosition:{x:l[0],y:l[1]}}))),null==j&&(s.trigger(new e.Event(r,{type:"touchmove",cyPosition:{x:l[0],y:l[1]}})),s.trigger(new e.Event(r,{type:"tapdrag",cyPosition:{x:l[0],y:l[1]}})),s.trigger(new e.Event(r,{type:"vmousemove",cyPosition:{x:l[0],y:l[1]}})))),j!=lt&&(lt&&lt.trigger(new e.Event(r,{type:"tapdragout",cyPosition:{x:l[0],y:l[1]}})),j&&j.trigger(new e.Event(r,{type:"tapdragover",cyPosition:{x:l[0],y:l[1]}}))),i.touchData.last=j;for(var H=0;H<l.length;H++)l[H]&&i.touchData.startPosition[H]&&Math.abs(l[H]-i.touchData.startPosition[H])>4&&(i.touchData.singleTouchMoved=!0);if(o&&(null==st||st.isEdge())&&s.panningEnabled()&&s.userPanningEnabled()){i.swipePanning?s.panBy({x:w[0]*c,y:w[1]*c}):B>=i.tapThreshold2&&(i.swipePanning=!0,s.panBy({x:k*c,y:T*c})),st&&(st.unactivate(),i.data.bgActivePosistion||(i.data.bgActivePosistion={x:l[0],y:l[1]}),i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.touchData.start=null);var y=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=y[0],l[1]=y[1]}}for(var _=0;_<l.length;_++)u[_]=l[_]},1e3/30,{trailing:!0}),!1),i.registerBinding(window,"touchcancel",function(){var e=i.touchData.start;i.touchData.capture=!1,e&&e.unactivate()}),i.registerBinding(window,"touchend",function(r){var n=i.touchData.start,a=i.touchData.capture;if(a){i.touchData.capture=!1,r.preventDefault();var s=i.data.select;i.swipePanning=!1,i.hoverData.draggingEles=!1;var l=i.data.cy,u=l.zoom(),c=i.touchData.now,d=i.touchData.earlier;if(r.touches[0]){var p=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);c[0]=p[0],c[1]=p[1]}if(r.touches[1]){var p=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);c[2]=p[0],c[3]=p[1]}if(r.touches[2]){var p=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);c[4]=p[0],c[5]=p[1]}n&&n.unactivate();var h;if(i.touchData.cxt){if(h=new e.Event(r,{type:"cxttapend",cyPosition:{x:c[0],y:c[1]}}),n?n.trigger(h):l.trigger(h),!i.touchData.cxtDragged){var v=new e.Event(r,{type:"cxttap",cyPosition:{x:c[0],y:c[1]}});n?n.trigger(v):l.trigger(v)}return i.touchData.start&&(i.touchData.start._private.grabbed=!1),i.touchData.cxt=!1,i.touchData.start=null,void i.redraw()}if(!r.touches[2]&&l.boxSelectionEnabled()){clearTimeout(this.threeFingerSelectTimeout);var g=[],f=i.getAllInBox(s[0],s[1],s[2],s[3]);s[0]=void 0,s[1]=void 0,s[2]=void 0,s[3]=void 0,s[4]=0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;for(var y=0;y<f.length;y++)f[y]._private.selectable&&g.push(f[y]);var m=new e.Collection(l,g);"single"===l.selectionType()&&l.$(":selected").not(m).unselect(),m.select(),m.length>0?i.data.canvasNeedsRedraw[t.NODE]=!0:i.redraw()}var x=!1;if(null!=n&&(n._private.active=!1,x=!0,n.unactivate()),r.touches[2])i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;else if(r.touches[1]);else if(r.touches[0]);else if(!r.touches[0]){if(i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,null!=n){n._private.grabbed&&(n._private.grabbed=!1,n.trigger("free"),n._private.rscratch.inDragLayer=!1);for(var b=n._private.edges,w=0;w<b.length;w++)b[w]._private.rscratch.inDragLayer=!1;if(o(n,!1),n.selected())for(var _=l.$("node:selected"),E=0;E<_.length;E++){var S=_[E];S._private.rscratch.inDragLayer=!1,S._private.grabbed=!1;for(var b=S._private.edges,w=0;w<b.length;w++)b[w]._private.rscratch.inDragLayer=!1;o(S,!1)}i.data.canvasNeedsRedraw[t.DRAG]=!0,i.data.canvasNeedsRedraw[t.NODE]=!0,n.trigger(new e.Event(r,{type:"touchend",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"tapend",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"vmouseup",cyPosition:{x:c[0],y:c[1]}})),n.unactivate(),i.touchData.start=null}else{var P=i.findNearestElement(c[0],c[1],!0);null!=P&&P.trigger(new e.Event(r,{type:"touchend",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"tapend",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"vmouseup",cyPosition:{x:c[0],y:c[1]}})),null==P&&l.trigger(new e.Event(r,{type:"touchend",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"tapend",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"vmouseup",cyPosition:{x:c[0],y:c[1]}}))}var D=i.touchData.startPosition[0]-c[0],k=D*D,C=i.touchData.startPosition[1]-c[1],T=C*C,N=k+T,M=N*u*u;null!=n&&!i.dragData.didDrag&&n._private.selectable&&M<i.tapThreshold2&&!i.pinching&&("single"===l.selectionType()?(l.$(":selected").not(n).unselect(),n.select()):n.selected()?n.unselect():n.select(),x=!0,i.data.canvasNeedsRedraw[t.NODE]=!0),i.touchData.singleTouchMoved===!1&&(n?n.trigger(new e.Event(r,{type:"tap",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"vclick",cyPosition:{x:c[0],y:c[1]}})):l.trigger(new e.Event(r,{type:"tap",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:"vclick",cyPosition:{x:c[0],y:c[1]}}))),i.touchData.singleTouchMoved=!0}for(var w=0;w<c.length;w++)d[w]=c[w];i.dragData.didDrag=!1,r.touches[0]&&(i.touchData.dragDelta=[]),x&&n&&n.updateStyle(!1),r.touches.length<2&&(i.pinching=!1,i.data.canvasNeedsRedraw[t.NODE]=!0,i.redraw())}},!1)}}(cytoscape),function(e){"use strict";for(var t=e("renderer","canvas"),i=t.prototype,r=t.usePaths(),n=t.nodeShapes={},a=Math.sin(0),o=Math.cos(0),s={},l={},u=.1,c=0*Math.PI;c<2*Math.PI;c+=u)s[c]=Math.sin(c),l[c]=Math.cos(c);n.ellipse={draw:function(e,t,i,r,a){n.ellipse.drawPath(e,t,i,r,a),e.fill()},drawPath:function(e,t,i,n,c){if(r){e.beginPath&&e.beginPath();for(var d,p,h=n/2,v=c/2,g=0*Math.PI;g<2*Math.PI;g+=u)d=t-h*s[g]*a+h*l[g]*o,p=i+v*l[g]*a+v*s[g]*o,0===g?e.moveTo(d,p):e.lineTo(d,p);e.closePath()}else e.beginPath&&e.beginPath(),e.translate(t,i),e.scale(n/2,c/2),e.arc(0,0,1,0,2*Math.PI*.999,!1),e.closePath(),e.scale(2/n,2/c),e.translate(-t,-i)},intersectLine:function(t,i,r,n,a,o,s){var l=e.math.intersectLineEllipse(a,o,t,i,r/2+s,n/2+s);return l},intersectBox:function(t,i,r,n,a,o,s,l,u){return e.math.boxIntersectEllipse(t,i,r,n,u,a,o,s,l)},checkPoint:function(e,t,i,r,n,a,o){return e-=a,t-=o,e/=r/2+i,t/=n/2+i,Math.pow(e,2)+Math.pow(t,2)<=1}},n.triangle={points:e.math.generateUnitNgonPointsFitToSquare(3,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.triangle.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.triangle.points)},intersectLine:function(t,i,r,a,o,s,l){return e.math.polygonIntersectLine(o,s,n.triangle.points,t,i,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.triangle.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.triangle.points,s,l,a,o,[0,-1],r)}},n.square={points:e.math.generateUnitNgonPointsFitToSquare(4,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.square.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.square.points)},intersectLine:function(t,i,r,a,o,s,l){return e.math.polygonIntersectLine(o,s,n.square.points,t,i,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.square.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.square.points,s,l,a,o,[0,-1],r)}},n.rectangle=n.square,n.octogon={},n.roundrectangle={points:e.math.generateUnitNgonPointsFitToSquare(4,0),draw:function(e,t,r,n,a){i.drawRoundRectangle(e,t,r,n,a,10)},drawPath:function(e,t,r,n,a){i.drawRoundRectanglePath(e,t,r,n,a,10)},intersectLine:function(t,i,r,n,a,o,s){return e.math.roundRectangleIntersectLine(a,o,t,i,r,n,s)},intersectBox:function(t,i,r,n,a,o,s,l,u){return e.math.roundRectangleIntersectBox(t,i,r,n,a,o,s,l,u)},checkPoint:function(t,i,r,a,o,s,l){var u=e.math.getRoundRectangleRadius(a,o);if(e.math.pointInsidePolygon(t,i,n.roundrectangle.points,s,l,a,o-2*u,[0,-1],r))return!0;if(e.math.pointInsidePolygon(t,i,n.roundrectangle.points,s,l,a-2*u,o,[0,-1],r))return!0;var c=function(e,t,i,r,n,a,o){return e-=i,t-=r,e/=n/2+o,t/=a/2+o,Math.pow(e,2)+Math.pow(t,2)<=1};return c(t,i,s-a/2+u,l-o/2+u,2*u,2*u,r)?!0:c(t,i,s+a/2-u,l-o/2+u,2*u,2*u,r)?!0:c(t,i,s+a/2-u,l+o/2-u,2*u,2*u,r)?!0:c(t,i,s-a/2+u,l+o/2-u,2*u,2*u,r)?!0:!1}},n.pentagon={points:e.math.generateUnitNgonPointsFitToSquare(5,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.pentagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.pentagon.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.pentagon.points,e,t,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.pentagon.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.pentagon.points,s,l,a,o,[0,-1],r)}},n.hexagon={points:e.math.generateUnitNgonPointsFitToSquare(6,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.hexagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.hexagon.points)},intersectLine:function(t,i,r,a,o,s,l){return e.math.polygonIntersectLine(o,s,n.hexagon.points,t,i,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.hexagon.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.hexagon.points,s,l,a,o,[0,-1],r)}},n.heptagon={points:e.math.generateUnitNgonPointsFitToSquare(7,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.heptagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.heptagon.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.heptagon.points,e,t,r/2,a/2,l)},intersectBox:function(e,t,r,a,o,s,l,u,c){var d=n.heptagon.points;return i.boxIntersectPolygon(e,t,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.heptagon.points,s,l,a,o,[0,-1],r)}},n.octagon={points:e.math.generateUnitNgonPointsFitToSquare(8,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.octagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.octagon.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.octagon.points,e,t,r/2,a/2,l)},intersectBox:function(e,t,r,a,o,s,l,u,c){var d=n.octagon.points;return i.boxIntersectPolygon(e,t,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.octagon.points,s,l,a,o,[0,-1],r)}};var d=new Array(20),p=e.math.generateUnitNgonPoints(5,0),h=e.math.generateUnitNgonPoints(5,Math.PI/5),v=.5*(3-Math.sqrt(5));v*=1.57;for(var c=0;c<h.length/2;c++)h[2*c]*=v,h[2*c+1]*=v;for(var c=0;5>c;c++)d[4*c]=p[2*c],d[4*c+1]=p[2*c+1],d[4*c+2]=h[2*c],d[4*c+3]=h[2*c+1];d=e.math.fitPolygonToSquare(d),n.star5=n.star={points:d,draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.star5.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.star5.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.star5.points,e,t,r/2,a/2,l)},intersectBox:function(e,t,r,a,o,s,l,u,c){var d=n.star5.points;return i.boxIntersectPolygon(e,t,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.star5.points,s,l,a,o,[0,-1],r)}}}(cytoscape),function(e){"use strict";function t(t){this._private={},this._private.options=e.util.extend({},i,t)}var i={animate:!0,maxSimulationTime:4e3,fit:!0,padding:30,boundingBox:void 0,ungrabifyWhileSimulating:!1,ready:void 0,stop:void 0,repulsion:void 0,stiffness:void 0,friction:void 0,gravity:!0,fps:void 0,precision:void 0,nodeMass:void 0,edgeLength:void 0,stepSize:.1,stableEnergy:function(e){var t=e;return t.max<=.5||t.mean<=.3},infinite:!1};t.prototype.run=function(){var t=this,i=this._private.options;return e.util.require("arbor",function(r){function n(e,t){return null==t?void 0:"function"==typeof t?t.apply(e,[e._private.data,{nodes:u.length,edges:c.length,element:e}]):t}function a(e){if(!e.isFullAutoParent()){var t=e._private.data.id,r=n(e,i.nodeMass),a=e._private.locked,o=e.position(),s=h.fromScreen({x:o.x,y:o.y});e.scratch().arbor=h.addNode(t,{element:e,mass:r,fixed:a,x:a?s.x:void 0,y:a?s.y:void 0})}}function o(e){var t=e.source().id(),r=e.target().id(),a=n(e,i.edgeLength);e.scratch().arbor=h.addEdge(t,r,{length:a})}var s=i.cy,l=i.eles,u=l.nodes().not(":parent"),c=l.edges(),d=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:s.width(),h:s.height()}),p=!1;if(t.trigger({type:"layoutstart",layout:t}),void 0!==i.liveUpdate&&(i.animate=i.liveUpdate),s.nodes().size()<=1)return i.fit&&s.reset(),s.nodes().position({x:Math.round((d.x1+d.x2)/2),y:Math.round((d.y1+d.y2)/2)}),t.one("layoutready",i.ready),t.trigger({type:"layoutready",layout:t}),t.one("layoutstop",i.stop),void t.trigger({type:"layoutstop",layout:t});var h=t._private.system=r.ParticleSystem();h.parameters({repulsion:i.repulsion,stiffness:i.stiffness,friction:i.friction,gravity:i.gravity,fps:i.fps,dt:i.dt,precision:i.precision}),i.animate&&i.fit&&s.fit(d,i.padding);var v,g=250,f=!1,y=+new Date,m={init:function(){},redraw:function(){var e=h.energy();if(!i.infinite&&null!=i.stableEnergy&&null!=e&&e.n>0&&i.stableEnergy(e))return void t.stop();i.infinite||1/0==g||(clearTimeout(v),v=setTimeout(P,g));var r=s.collection();h.eachNode(function(e,t){var i=e.data,n=i.element;null!=n&&(n.locked()||n.grabbed()||(n.silentPosition({x:d.x1+t.x,y:d.y1+t.y}),r.merge(n)))}),i.animate&&r.length>0&&(p=!0,r.rtrigger("position"),i.fit&&s.fit(i.padding),y=+new Date,p=!1),f||(f=!0,t.one("layoutready",i.ready),t.trigger({type:"layoutready",layout:t}))}};h.renderer=m,h.screenSize(d.w,d.h),h.screenPadding(i.padding,i.padding,i.padding,i.padding),h.screenStep(i.stepSize);var x;u.on("grab free position",x=function(e){if(!p){var t=this.position(),n=h.fromScreen(t);if(n){var a=r.Point(n.x,n.y),o=i.padding;switch(d.x1+o<=t.x&&t.x<=d.x2-o&&d.y1+o<=t.y&&t.y<=d.y2-o&&(this.scratch().arbor.p=a),e.type){case"grab":this.scratch().arbor.fixed=!0;break;case"free":this.scratch().arbor.fixed=!1}}}});var b;u.on("lock unlock",b=function(){node.scratch().arbor.fixed=node.locked()});var w;l.on("remove",w=function(){});var _;s.on("add","*",_=function(){});var E;s.on("resize",E=function(){if(null==i.boundingBox&&null!=t._private.system){var e=s.width(),r=s.height();h.screenSize(e,r)}}),u.each(function(e,t){a(t)}),c.each(function(e,t){o(t)});var S=u.filter(":grabbable");i.ungrabifyWhileSimulating&&S.ungrabify();var P=t._private.doneHandler=function(){t._private.doneHandler=null,i.animate||(i.fit&&s.reset(),u.rtrigger("position")),u.off("grab free position",x),u.off("lock unlock",b),l.off("remove",w),s.off("add","*",_),s.off("resize",E),i.ungrabifyWhileSimulating&&S.grabify(),t.one("layoutstop",i.stop),t.trigger({type:"layoutstop",layout:t})};h.start(),!i.infinite&&null!=i.maxSimulationTime&&i.maxSimulationTime>0&&1/0!==i.maxSimulationTime&&setTimeout(function(){t.stop()},i.maxSimulationTime)}),this},t.prototype.stop=function(){return null!=this._private.system&&this._private.system.stop(),this._private.doneHandler&&this._private.doneHandler(),this},e("layout","arbor",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,directed:!1,padding:30,circle:!1,boundingBox:void 0,avoidOverlap:!0,roots:void 0,maximalAdjustments:0,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){var t,i=this.options,r=i,n=i.cy,a=r.eles,o=a.nodes().not(":parent"),s=a,l=e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()});if(e.is.elementOrCollection(r.roots))t=r.roots;else if(e.is.array(r.roots)){for(var u=[],c=0;c<r.roots.length;c++){var d=r.roots[c],p=n.getElementById(d);u.push(p)}t=new e.Collection(n,u)}else if(e.is.string(r.roots))t=n.$(r.roots);else if(r.directed)t=o.roots();else{for(var h=[],v=o;v.length>0;){var g=n.collection();a.bfs({roots:v[0],visit:function(e,t,i){g=g.add(i)},directed:!1}),v=v.not(g),h.push(g)}t=n.collection();for(var c=0;c<h.length;c++){var f=h[c],y=f.maxDegree(!1),m=f.filter(function(){return this.degree(!1)===y});t=t.add(m)}}var x=[],b={},w={},_={},E={},S={};s.bfs({roots:t,directed:r.directed,visit:function(e,t,i,r,n){var a=this[0],o=a.id();if(x[t]||(x[t]=[]),x[t].push(a),b[o]=!0,w[o]=t,_[o]=n,E[o]=r,n){var s=n.id(),l=S[s]=S[s]||[];l.push(i)}}});for(var P=[],c=0;c<o.length;c++){var p=o[c];b[p.id()]||P.push(p)}for(var D=3*P.length,k=0;0!==P.length&&D>k;){for(var C=P.shift(),T=C.neighborhood().nodes(),N=!1,c=0;c<T.length;c++){var M=w[T[c].id()];if(void 0!==M){x[M].push(C),N=!0;break}}N||P.push(C),k++}for(;0!==P.length;){var C=P.shift(),N=!1;N||(0===x.length&&x.push([]),x[0].push(C))}var B=function(){for(var e=0;e<x.length;e++)for(var t=x[e],i=0;i<t.length;i++){var r=t[i];r._private.scratch.breadthfirst={depth:e,index:i}}};B();for(var I=function(e){for(var t,i=e.connectedEdges(function(){return this.data("target")===e.id()\n}),r=e._private.scratch.breadthfirst,n=0,a=0;a<i.length;a++){var o=i[a],s=o.source()[0],l=s._private.scratch.breadthfirst;r.depth<=l.depth&&n<l.depth&&(n=l.depth,t=s)}return t},z=0;z<r.maximalAdjustments;z++){for(var L=x.length,O=[],c=0;L>c;c++)for(var M=x[c],R=M.length,X=0;R>X;X++){var p=M[X],V=p._private.scratch.breadthfirst,Y=I(p);Y&&(V.intEle=Y,O.push(p))}for(var c=0;c<O.length;c++){var p=O[c],V=p._private.scratch.breadthfirst,Y=V.intEle,A=Y._private.scratch.breadthfirst;x[V.depth].splice(V.index,1);for(var q=A.depth+1;q>x.length-1;)x.push([]);x[q].push(p),V.depth=q,V.index=x[q].length-1}B()}var F=0;if(r.avoidOverlap){for(var c=0;c<o.length;c++){var j=o[c].outerWidth(),W=o[c].outerHeight();F=Math.max(F,j,W)}F*=1.75}for(var H={},$=function(e){if(H[e.id()])return H[e.id()];for(var t=e._private.scratch.breadthfirst.depth,i=e.neighborhood().nodes(),r=0,n=0,a=0;a<i.length;a++){var o=i[a],s=o._private.scratch.breadthfirst.index,l=o._private.scratch.breadthfirst.depth,u=x[l].length;(t>l||0===t)&&(r+=s/u,n++)}return n=Math.max(1,n),r/=n,0===n&&(r=void 0),H[e.id()]=r,r},Z=function(e,t){var i=$(e),r=$(t);return i-r},U=0;3>U;U++){for(var c=0;c<x.length;c++)x[c]=x[c].sort(Z);B()}for(var G=0,c=0;c<x.length;c++)G=Math.max(x[c].length,G);for(var K={x:l.x1+l.w/2,y:l.x1+l.h/2},J=function(e,t){var i=e._private.scratch.breadthfirst,n=i.depth,a=i.index,o=x[n].length;r.strictHierarchy&&(o=G);var s=Math.max(l.w/(o+1),F),u=Math.max(l.h/(x.length+1),F),c=Math.min(l.w/2/x.length,l.h/2/x.length);if(c=Math.max(c,F),r.strictHierarchy&&!r.circle){var d={x:K.x+(a+1-(o+1)/2)*s,y:(n+1)*u};if(t)return d;var p=S[e.id()];if(p){d.x=0;for(var h=0;h<p.length;h++){var v=Q[p[h].id()];d.x+=v.x}d.x/=p.length}return d}if(r.circle){var g=c*n+c-(x.length>0&&x[0].length<=3?c/2:0),f=2*Math.PI/x[n].length*a;return 0===n&&1===x[0].length&&(g=1),{x:K.x+g*Math.cos(f),y:K.y+g*Math.sin(f)}}return{x:K.x+(a+1-(o+1)/2)*s,y:(n+1)*u}},Q={},c=x.length-1;c>=0;c--)for(var M=x[c],X=0;X<M.length;X++){var C=M[X];Q[C.id()]=J(C,c===x.length-1)}return o.layoutPositions(this,r,function(){return Q[this.id()]}),this},e("layout","breadthfirst",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,padding:30,boundingBox:void 0,avoidOverlap:!0,radius:void 0,startAngle:1.5*Math.PI,counterclockwise:!1,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){for(var t,i=this.options,r=i,n=i.cy,a=r.eles,o=a.nodes().not(":parent"),s=e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()}),l={x:s.x1+s.w/2,y:s.y1+s.h/2},u=r.startAngle,c=2*Math.PI/o.length,d=0,p=0;p<o.length;p++){var h=o[p].outerWidth(),v=o[p].outerHeight();d=Math.max(d,h,v)}if(t=e.is.number(r.radius)?r.radius:o.length<=1?0:Math.min(s.h,s.w)/2-d,o.length>1&&r.avoidOverlap){d*=1.75;var c=2*Math.PI/o.length,g=Math.cos(c)-Math.cos(0),f=Math.sin(c)-Math.sin(0),y=Math.sqrt(d*d/(g*g+f*f));t=Math.max(y,t)}var m=function(){var e=t*Math.cos(u),i=t*Math.sin(u),n={x:l.x+e,y:l.y+i};return u=r.counterclockwise?u-c:u+c,n};return o.layoutPositions(this,r,m),this},e("layout","circle",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={animate:!0,refresh:1,maxSimulationTime:4e3,ungrabifyWhileSimulating:!1,fit:!0,padding:30,boundingBox:void 0,ready:function(){},stop:function(){},randomize:!1,avoidOverlap:!0,handleDisconnected:!0,nodeSpacing:function(){return 10},flow:void 0,alignment:void 0,edgeLength:void 0,edgeSymDiffLength:void 0,edgeJaccardLength:void 0,unconstrIter:void 0,userConstIter:void 0,allConstIter:void 0,infinite:!1};t.prototype.run=function(){var t=this,i=this.options;return e.util.require("cola",function(r){var n=i.cy,a=i.eles,o=a.nodes(),s=a.edges(),l=!1,u=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()}),c=function(t,i){if(e.is.fn(t)){var r=t;return r.apply(i,[i])}return t},d=function(){for(var e={min:1/0,max:-1/0},t={min:1/0,max:-1/0},r=0;r<o.length;r++){var a=o[r],s=a._private.scratch.cola;e.min=Math.min(e.min,s.x),e.max=Math.max(e.max,s.x),t.min=Math.min(t.min,s.y),t.max=Math.max(t.max,s.y)}o.positions(function(i,r){var n=r._private.position,a=r._private.scratch.cola;r.grabbed()||(n.x=u.x1+a.x-e.min,n.y=u.y1+a.y-t.min)}),l||(h(),l=!0),i.fit&&n.fit(i.padding)},p=function(){t.manuallyStopped=!1,i.ungrabifyWhileSimulating&&y.grabify(),o.off("grab free position",m),o.off("lock unlock",x),t.one("layoutstop",i.stop),t.trigger({type:"layoutstop",layout:t})},h=function(){t.one("layoutready",i.ready),t.trigger({type:"layoutready",layout:t})},v=i.refresh,g=1;i.refresh<0?(g=Math.abs(i.refresh),v=1):v=Math.max(1,v);var f=r.adaptor({trigger:function(e){switch(e.type){case"tick":i.animate&&d();break;case"end":d(),(!i.infinite||t.manuallyStopped)&&p()}},kick:function(t){var r=0,n=function(){var e=t();return e&&i.infinite&&f.resume(),e},a=function(){var e,t=r;if(r=(r+1)%g,0!==t)return!1;for(var i=0;v>i&&!e;i++)e=e||n();return e};if(i.animate){var o=function(){a()||e.util.requestAnimationFrame(o)};e.util.requestAnimationFrame(o)}else for(;!n(););},on:function(){},drag:function(){}});t.adaptor=f;var y=o.filter(":grabbable");i.ungrabifyWhileSimulating&&y.ungrabify();var m;o.on("grab free position",m=function(t){var i=this,r=i._private.scratch.cola,n=i._private.position;switch(i.grabbed()?(r.x=n.x-u.x1,r.y=n.y-u.y1,f.dragstart(r)):e.is.number(r.x)&&e.is.number(r.y)&&(n.x=r.x+u.x1,n.y=r.y+u.y1),t.type){case"grab":f.dragstart(r),f.resume();break;case"free":f.dragend(r)}});var x;o.on("lock unlock",x=function(){var e=this,t=e._private.scratch.cola;e.locked()?f.dragstart(t):f.dragend(t)});var b=o.stdFilter(function(e){return!e.isParent()});if(f.nodes(b.map(function(e,t){var r=c(i.nodeSpacing,e),n=e.position(),a=e._private.scratch.cola={x:i.randomize?Math.round(Math.random()*u.w):n.x,y:i.randomize?Math.round(Math.random()*u.h):n.y,width:e.outerWidth()+2*r,height:e.outerHeight()+2*r,index:t};return a})),i.alignment){var w=[],_=[];b.forEach(function(e){var t=c(i.alignment,e),r=e._private.scratch.cola,n=r.index;t&&(null!=t.x&&w.push({node:n,offset:t.x}),null!=t.y&&_.push({node:n,offset:t.y}))});var E=[];w.length>0&&E.push({type:"alignment",axis:"x",offsets:w}),_.length>0&&E.push({type:"alignment",axis:"y",offsets:_}),f.constraints(E)}f.groups(o.stdFilter(function(e){return e.isParent()}).map(function(e,t){return e._private.scratch.cola={index:t,leaves:e.children().stdFilter(function(e){return!e.isParent()}).map(function(e){return e[0]._private.scratch.cola.index})},e}).map(function(e){return e._private.scratch.cola.groups=e.children().stdFilter(function(e){return e.isParent()}).map(function(e){return e._private.scratch.cola.index}),e._private.scratch.cola}));var S,P;null!=i.edgeLength?(S=i.edgeLength,P="linkDistance"):null!=i.edgeSymDiffLength?(S=i.edgeSymDiffLength,P="symmetricDiffLinkLengths"):null!=i.edgeJaccardLength?(S=i.edgeJaccardLength,P="jaccardLinkLengths"):(S=100,P="linkDistance");var D=function(e){return e.calcLength};if(f.links(s.stdFilter(function(e){return!e.source().isParent()&&!e.target().isParent()}).map(function(e){var t=e._private.scratch.cola={source:e.source()[0]._private.scratch.cola.index,target:e.target()[0]._private.scratch.cola.index};return null!=S&&(t.calcLength=c(S,e)),t})),f.size([u.w,u.h]),null!=S&&f[P](D),i.flow){var k,C="y",T=50;e.is.string(i.flow)?k={axis:i.flow,minSeparation:T}:e.is.number(i.flow)?k={axis:C,minSeparation:i.flow}:e.is.plainObject(i.flow)?(k=i.flow,k.axis=k.axis||C,k.minSeparation=null!=k.minSeparation?k.minSeparation:T):k={axis:C,minSeparation:T},f.flowLayout(k.axis,k.minSeparation)}f.avoidOverlaps(i.avoidOverlap).handleDisconnected(i.handleDisconnected).start(i.unconstrIter,i.userConstIter,i.allConstIter),t.trigger({type:"layoutstart",layout:t}),i.infinite||setTimeout(function(){f.stop()},i.maxSimulationTime)}),this},t.prototype.stop=function(){return this.adaptor&&(this.manuallyStopped=!0,this.adaptor.stop()),this},e("layout","cola",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,padding:30,startAngle:1.5*Math.PI,counterclockwise:!1,minNodeSpacing:10,boundingBox:void 0,avoidOverlap:!0,height:void 0,width:void 0,concentric:function(){return this.degree()},levelWidth:function(e){return e.maxDegree()/4},animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){for(var t=this.options,i=t,r=t.cy,n=i.eles,a=n.nodes().not(":parent"),o=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:r.width(),h:r.height()}),s={x:o.x1+o.w/2,y:o.y1+o.h/2},l=[],u=i.startAngle,c=0,d=0;d<a.length;d++){var p,h=a[d];p=i.concentric.call(h),l.push({value:p,node:h}),h._private.layoutData.concentric=p}a.updateStyle();for(var d=0;d<a.length;d++){var h=a[d];c=Math.max(c,h.outerWidth(),h.outerHeight())}l.sort(function(e,t){return t.value-e.value});for(var v=i.levelWidth(a),g=[[]],f=g[0],d=0;d<l.length;d++){var y=l[d];if(f.length>0){var m=Math.abs(f[0].value-y.value);m>=v&&(f=[],g.push(f))}f.push(y)}var x={},b=0,w=c+i.minNodeSpacing;if(!i.avoidOverlap){var _=g.length>0&&g[0].length>1,E=Math.min(o.w,o.h)/2-w,S=E/(g.length+_?1:0);w=Math.min(w,S)}for(var d=0;d<g.length;d++){var P=g[d],D=2*Math.PI/P.length;if(P.length>1&&i.avoidOverlap){var k=Math.cos(D)-Math.cos(0),C=Math.sin(D)-Math.sin(0),T=Math.sqrt(w*w/(k*k+C*C));b=Math.max(T,b)}for(var N=0;N<P.length;N++){var y=P[N],u=i.startAngle+(i.counterclockwise?1:-1)*D*N,M={x:s.x+b*Math.cos(u),y:s.y+b*Math.sin(u)};x[y.node.id()]=M}b+=w}return a.layoutPositions(this,i,function(){var e=this.id();return x[e]}),this},e("layout","concentric",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend({},r,t)}var i,r={ready:function(){},stop:function(){},animate:!0,refresh:4,fit:!0,padding:30,boundingBox:void 0,randomize:!0,debug:!1,nodeRepulsion:4e5,nodeOverlap:10,idealEdgeLength:10,edgeElasticity:100,nestingFactor:5,gravity:250,numIter:100,initialTemp:200,coolingFactor:.95,minTemp:1};t.prototype.run=function(){var t=this.options,r=t.cy,a=this;a.stopped=!1,a.trigger({type:"layoutstart",layout:a}),i=!0===t.debug?!0:!1;var o=new Date,d=n(r,a,t);i&&s(d),!0===t.randomize&&l(d,r),m(d,r,t);var p=function(e){return a.stopped?(w("Layout manually stopped. Stopping computation in step "+e),!1):(c(d,r,t,e),d.temperature=d.temperature*t.coolingFactor,w("New temperature: "+d.temperature),d.temperature<t.minTemp?(w("Temperature drop below minimum threshold. Stopping computation in step "+e),!1):!0)},h=function(){u(d,r,t),!0===t.fit&&r.fit(t.padding);var e=new Date;console.info("Layout took "+(e-o)+" ms"),a.one("layoutstop",t.stop),a.trigger({type:"layoutstop",layout:a})};if(t.animate){var v=0,g=function(){for(var i,n=0;n<t.refresh&&v<t.numIter;){var i=p(v);if(i===!1)break;n++,v++}u(d,r,t),t.fit&&r.fit(t.padding),i!==!1&&v+1<t.numIter?e.util.requestAnimationFrame(g):h()};e.util.requestAnimationFrame(g)}else{for(var v=0;v<t.numIter&&p(v)!==!1;v++);h()}return this},t.prototype.stop=function(){return this.stopped=!0,this};var n=function(t,i,r){for(var n=r.eles.edges(),o=r.eles.nodes(),s={layout:i,layoutNodes:[],idToIndex:{},nodeSize:o.size(),graphSet:[],indexToGraph:[],layoutEdges:[],edgeSize:n.size(),temperature:r.initialTemp,clientWidth:t.width(),clientHeight:t.width(),boundingBox:e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:t.width(),h:t.height()})},l=0;l<s.nodeSize;l++){var u={};u.id=o[l].data("id"),u.parentId=o[l].data("parent"),u.children=[],u.positionX=o[l].position("x"),u.positionY=o[l].position("y"),u.offsetX=0,u.offsetY=0,u.height=o[l].height(),u.width=o[l].width(),u.maxX=u.positionX+u.width/2,u.minX=u.positionX-u.width/2,u.maxY=u.positionY+u.height/2,u.minY=u.positionY-u.height/2,u.padLeft=o[l]._private.style["padding-left"].pxValue,u.padRight=o[l]._private.style["padding-right"].pxValue,u.padTop=o[l]._private.style["padding-top"].pxValue,u.padBottom=o[l]._private.style["padding-bottom"].pxValue,s.layoutNodes.push(u),s.idToIndex[u.id]=l}for(var c=[],d=0,p=-1,h=[],l=0;l<s.nodeSize;l++){var v=s.layoutNodes[l],g=v.parentId;null!=g?s.layoutNodes[s.idToIndex[g]].children.push(v.id):(c[++p]=v.id,h.push(v.id))}for(s.graphSet.push(h);p>=d;){var f=c[d++],y=s.idToIndex[f],m=s.layoutNodes[y],x=m.children;if(x.length>0){s.graphSet.push(x);for(var l=0;l<x.length;l++)c[++p]=x[l]}}for(var l=0;l<s.graphSet.length;l++)for(var b=s.graphSet[l],_=0;_<b.length;_++){var E=s.idToIndex[b[_]];s.indexToGraph[E]=l}for(var l=0;l<s.edgeSize;l++){var S=n[l],P={};P.id=S.data("id"),P.sourceId=S.data("source"),P.targetId=S.data("target");var D=r.idealEdgeLength,k=s.idToIndex[P.sourceId],C=s.idToIndex[P.targetId],T=s.indexToGraph[k],N=s.indexToGraph[C];if(T!=N){for(var M=a(P.sourceId,P.targetId,s),B=s.graphSet[M],I=0,u=s.layoutNodes[k];-1===$.inArray(u.id,B);)u=s.layoutNodes[s.idToIndex[u.parentId]],I++;for(u=s.layoutNodes[C];-1===$.inArray(u.id,B);)u=s.layoutNodes[s.idToIndex[u.parentId]],I++;w("LCA of nodes "+P.sourceId+" and "+P.targetId+". Index: "+M+" Contents: "+B.toString()+". Depth: "+I),D*=I*r.nestingFactor}P.idealLength=D,s.layoutEdges.push(P)}return s},a=function(e,t,i){var r=o(e,t,0,i);return 2>r.count?0:r.graph},o=function(e,t,i,r){var n=r.graphSet[i];if(-1<$.inArray(e,n)&&-1<$.inArray(t,n))return{count:2,graph:i};for(var a=0,s=0;s<n.length;s++){var l=n[s],u=r.idToIndex[l],c=r.layoutNodes[u].children;if(0!==c.length){var d=r.indexToGraph[r.idToIndex[c[0]]],p=o(e,t,d,r);if(0!==p.count){if(1!==p.count)return p;if(a++,2===a)break}}}return{count:a,graph:i}},s=function(e){if(i){console.debug("layoutNodes:");for(var t=0;t<e.nodeSize;t++){var r=e.layoutNodes[t],n="\\nindex: "+t+"\\nId: "+r.id+"\\nChildren: "+r.children.toString()+"\\nparentId: "+r.parentId+"\\npositionX: "+r.positionX+"\\npositionY: "+r.positionY+"\\nOffsetX: "+r.offsetX+"\\nOffsetY: "+r.offsetY+"\\npadLeft: "+r.padLeft+"\\npadRight: "+r.padRight+"\\npadTop: "+r.padTop+"\\npadBottom: "+r.padBottom;console.debug(n)}console.debug("idToIndex");for(var t in e.idToIndex)console.debug("Id: "+t+"\\nIndex: "+e.idToIndex[t]);console.debug("Graph Set");for(var a=e.graphSet,t=0;t<a.length;t++)console.debug("Set : "+t+": "+a[t].toString());for(var n="IndexToGraph",t=0;t<e.indexToGraph.length;t++)n+="\\nIndex : "+t+" Graph: "+e.indexToGraph[t];console.debug(n),n="Layout Edges";for(var t=0;t<e.layoutEdges.length;t++){var o=e.layoutEdges[t];n+="\\nEdge Index: "+t+" ID: "+o.id+" SouceID: "+o.sourceId+" TargetId: "+o.targetId+" Ideal Length: "+o.idealLength}console.debug(n),n="nodeSize: "+e.nodeSize,n+="\\nedgeSize: "+e.edgeSize,n+="\\ntemperature: "+e.temperature,console.debug(n)}},l=function(e){for(var t=e.clientWidth,i=e.clientHeight,r=0;r<e.nodeSize;r++){var n=e.layoutNodes[r];n.positionX=Math.random()*t,n.positionY=Math.random()*i}},u=function(e,t,i){var r="Refreshing positions";w(r);var n=e.layout,a=i.eles.nodes(),o=e.boundingBox,s={x1:1/0,x2:-1/0,y1:1/0,y2:-1/0};i.boundingBox&&(a.forEach(function(t){var i=e.layoutNodes[e.idToIndex[t.data("id")]];s.x1=Math.min(s.x1,i.positionX),s.x2=Math.max(s.x2,i.positionX),s.y1=Math.min(s.y1,i.positionY),s.y2=Math.max(s.y2,i.positionY)}),s.w=s.x2-s.x1,s.h=s.y2-s.y1),a.positions(function(t,n){var a=e.layoutNodes[e.idToIndex[n.data("id")]];if(r="Node: "+a.id+". Refreshed position: ("+a.positionX+", "+a.positionY+").",w(r),i.boundingBox){var l=(a.positionX-s.x1)/s.w,u=(a.positionY-s.y1)/s.h;return{x:o.x1+l*o.w,y:o.y1+u*o.h}}return{x:a.positionX,y:a.positionY}}),!0!==e.ready&&(r="Triggering layoutready",w(r),e.ready=!0,n.one("layoutready",i.ready),n.trigger({type:"layoutready",layout:this}))},c=function(e,t,i,r){var n="\\n\\n###############################";n+="\\nSTEP: "+r,n+="\\n###############################\\n",w(n),d(e,t,i),g(e,t,i),f(e,t,i),y(e,t,i),m(e,t,i)},d=function(e,t,i){var r="calculateNodeForces";w(r);for(var n=0;n<e.graphSet.length;n++){var a=e.graphSet[n],o=a.length;r="Set: "+a.toString(),w(r);for(var s=0;o>s;s++)for(var l=e.layoutNodes[e.idToIndex[a[s]]],u=s+1;o>u;u++){var c=e.layoutNodes[e.idToIndex[a[u]]];p(l,c,e,t,i)}}},p=function(e,t,i,r,n){var a="Node repulsion. Node1: "+e.id+" Node2: "+t.id,o=t.positionX-e.positionX,s=t.positionY-e.positionY;if(a+="\\ndirectionX: "+o+", directionY: "+s,0===o&&0===s)return void(a+="\\nNodes have the same position.");var l=v(e,t,o,s);if(l>0){a+="\\nNodes DO overlap.",a+="\\nOverlap: "+l;var u=n.nodeOverlap*l,c=Math.sqrt(o*o+s*s);a+="\\nDistance: "+c;var d=u*o/c,p=u*s/c}else{a+="\\nNodes do NOT overlap.";var g=h(e,o,s),f=h(t,-1*o,-1*s),y=f.x-g.x,m=f.y-g.y,x=y*y+m*m,c=Math.sqrt(x);a+="\\nDistance: "+c;var u=n.nodeRepulsion/x,d=u*y/c,p=u*m/c}e.offsetX-=d,e.offsetY-=p,t.offsetX+=d,t.offsetY+=p,a+="\\nForceX: "+d+" ForceY: "+p,w(a)},h=function(e,t,i){var r=e.positionX,n=e.positionY,a=e.height,o=e.width,s=i/t,l=a/o,u="Computing clipping point of node "+e.id+" . Height:  "+a+", Width: "+o+"\\nDirection "+t+", "+i,c={};do{if(0===t&&i>0){c.x=r,u+="\\nUp direction",c.y=n+a/2;break}if(0===t&&0>i){c.x=r,c.y=n+a/2,u+="\\nDown direction";break}if(t>0&&s>=-1*l&&l>=s){c.x=r+o/2,c.y=n+o*i/2/t,u+="\\nRightborder";break}if(0>t&&s>=-1*l&&l>=s){c.x=r-o/2,c.y=n-o*i/2/t,u+="\\nLeftborder";break}if(i>0&&(-1*l>=s||s>=l)){c.x=r+a*t/2/i,c.y=n+a/2,u+="\\nTop border";break}if(0>i&&(-1*l>=s||s>=l)){c.x=r-a*t/2/i,c.y=n-a/2,u+="\\nBottom border";break}}while(!1);return u+="\\nClipping point found at "+c.x+", "+c.y,w(u),c},v=function(e,t,i,r){if(i>0)var n=e.maxX-t.minX;else var n=t.maxX-e.minX;if(r>0)var a=e.maxY-t.minY;else var a=t.maxY-e.minY;return n>=0&&a>=0?Math.sqrt(n*n+a*a):0},g=function(e,t,i){for(var r=0;r<e.edgeSize;r++){var n=e.layoutEdges[r],a=e.idToIndex[n.sourceId],o=e.layoutNodes[a],s=e.idToIndex[n.targetId],l=e.layoutNodes[s],u=l.positionX-o.positionX,c=l.positionY-o.positionY;if(0===u&&0===c)return;var d=h(o,u,c),p=h(l,-1*u,-1*c),v=p.x-d.x,g=p.y-d.y,f=Math.sqrt(v*v+g*g),y=Math.pow(n.idealLength-f,2)/i.edgeElasticity;if(0!==f)var m=y*v/f,x=y*g/f;else var m=0,x=0;o.offsetX+=m,o.offsetY+=x,l.offsetX-=m,l.offsetY-=x;var b="Edge force between nodes "+o.id+" and "+l.id;b+="\\nDistance: "+f+" Force: ("+m+", "+x+")",w(b)}},f=function(e,t,i){var r="calculateGravityForces";w(r);for(var n=0;n<e.graphSet.length;n++){var a=e.graphSet[n],o=a.length;if(r="Set: "+a.toString(),w(r),0===n)var s=e.clientHeight/2,l=e.clientWidth/2;else var u=e.layoutNodes[e.idToIndex[a[0]]],c=e.layoutNodes[e.idToIndex[u.parentId]],s=c.positionX,l=c.positionY;r="Center found at: "+s+", "+l,w(r);for(var d=0;o>d;d++){var p=e.layoutNodes[e.idToIndex[a[d]]];r="Node: "+p.id;var h=s-p.positionX,v=l-p.positionY,g=Math.sqrt(h*h+v*v);if(g>1){var f=i.gravity*h/g,y=i.gravity*v/g;p.offsetX+=f,p.offsetY+=y,r+=": Applied force: "+f+", "+y}else r+=": skypped since it\'s too close to center";w(r)}}},y=function(e){var t=[],i=0,r=-1;for(w("propagateForces"),t.push.apply(t,e.graphSet[0]),r+=e.graphSet[0].length;r>=i;){var n=t[i++],a=e.idToIndex[n],o=e.layoutNodes[a],s=o.children;if(0<s.length){var l=o.offsetX,u=o.offsetY,c="Propagating offset from parent node : "+o.id+". OffsetX: "+l+". OffsetY: "+u;c+="\\n Children: "+s.toString(),w(c);for(var d=0;d<s.length;d++){var p=e.layoutNodes[e.idToIndex[s[d]]];p.offsetX+=l,p.offsetY+=u,t[++r]=s[d]}o.offsetX=0,o.offsetY=0}}},m=function(e){var t="Updating positions";w(t);for(var i=0;i<e.nodeSize;i++){var r=e.layoutNodes[i];0<r.children.length&&(w("Resetting boundaries of compound node: "+r.id),r.maxX=void 0,r.minX=void 0,r.maxY=void 0,r.minY=void 0)}for(var i=0;i<e.nodeSize;i++){var r=e.layoutNodes[i];if(0<r.children.length)w("Skipping position update of node: "+r.id);else{t="Node: "+r.id+" Previous position: ("+r.positionX+", "+r.positionY+").";var n=x(r.offsetX,r.offsetY,e.temperature);r.positionX+=n.x,r.positionY+=n.y,r.offsetX=0,r.offsetY=0,r.minX=r.positionX-r.width,r.maxX=r.positionX+r.width,r.minY=r.positionY-r.height,r.maxY=r.positionY+r.height,t+=" New Position: ("+r.positionX+", "+r.positionY+").",w(t),b(r,e)}}for(var i=0;i<e.nodeSize;i++){var r=e.layoutNodes[i];0<r.children.length&&(r.positionX=(r.maxX+r.minX)/2,r.positionY=(r.maxY+r.minY)/2,r.width=r.maxX-r.minX,r.height=r.maxY-r.minY,t="Updating position, size of compound node "+r.id,t+="\\nPositionX: "+r.positionX+", PositionY: "+r.positionY,t+="\\nWidth: "+r.width+", Height: "+r.height,w(t))}},x=function(e,t,i){var r="Limiting force: ("+e+", "+t+"). Max: "+i,n=Math.sqrt(e*e+t*t);if(n>i)var a={x:i*e/n,y:i*t/n};else var a={x:e,y:t};return r+=".\\nResult: ("+a.x+", "+a.y+")",w(r),a},b=function(e,t){var i="Propagating new position/size of node "+e.id,r=e.parentId;if(null==r)return i+=". No parent node.",void w(i);var n=t.layoutNodes[t.idToIndex[r]],a=!1;return(null==n.maxX||e.maxX+n.padRight>n.maxX)&&(n.maxX=e.maxX+n.padRight,a=!0,i+="\\nNew maxX for parent node "+n.id+": "+n.maxX),(null==n.minX||e.minX-n.padLeft<n.minX)&&(n.minX=e.minX-n.padLeft,a=!0,i+="\\nNew minX for parent node "+n.id+": "+n.minX),(null==n.maxY||e.maxY+n.padBottom>n.maxY)&&(n.maxY=e.maxY+n.padBottom,a=!0,i+="\\nNew maxY for parent node "+n.id+": "+n.maxY),(null==n.minY||e.minY-n.padTop<n.minY)&&(n.minY=e.minY-n.padTop,a=!0,i+="\\nNew minY for parent node "+n.id+": "+n.minY),a?(w(i),b(n,t)):(i+=". No changes in boundaries/position of parent node "+n.id,void w(i))},w=function(e){i&&console.debug(e)};e("layout","cose",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={nodeSep:void 0,edgeSep:void 0,rankSep:void 0,rankDir:void 0,minLen:function(){return 1},fit:!0,padding:30,animate:!1,animationDuration:500,boundingBox:void 0,ready:function(){},stop:function(){}};t.prototype.run=function(){var t=this.options,i=this;return e.util.require("dagre",function(r){for(var n=t.cy,a=t.eles,o=e.util.makeBoundingBox(t.boundingBox?t.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()}),s=new r.Digraph,l=a.nodes().not(":parent"),u=0;u<l.length;u++){var c=l[u];s.addNode(c.id(),{width:c.width(),height:c.height()})}for(var d=a.edges(),u=0;u<d.length;u++){var p=d[u];s.addEdge(p.id(),p.source().id(),p.target().id(),{minLen:e.is.fn(t.minLen)?t.minLen.apply(p,[p]):t.minLen})}var h=r.layout();t.nodeSep&&h.nodeSep(t.nodeSep),t.edgeSep&&h.edgeSep(t.edgeSep),t.rankSep&&h.rankSep(t.rankSep),t.rankDir&&h.rankDir(t.rankDir),h=h.run(s),h.eachNode(function(e,t){n.getElementById(e).scratch().dagre=t});var v;t.boundingBox?(v={x1:1/0,x2:-1/0,y1:1/0,y2:-1/0},l.forEach(function(e){var t=e.scratch().dagre;v.x1=Math.min(v.x1,t.x),v.x2=Math.max(v.x2,t.x),v.y1=Math.min(v.y1,t.y),v.y2=Math.max(v.y2,t.y)}),v.w=v.x2-v.x1,v.h=v.y2-v.y1):v=o;var g=function(e){if(t.boundingBox){var i=(e.x-v.x1)/v.w,r=(e.y-v.y1)/v.h;return{x:o.x1+i*o.w,y:o.y1+r*o.h}}return e};l.layoutPositions(i,t,function(){var e=this.scratch().dagre;return g({x:e.x,y:e.y})})}),this},e("layout","dagre",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,padding:30,boundingBox:void 0,avoidOverlap:!0,rows:void 0,columns:void 0,position:function(){},animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){var t=this.options,i=t,r=t.cy,n=i.eles,a=n.nodes().not(":parent"),o=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:r.width(),h:r.height()});if(0===o.h||0===o.w)a.layoutPositions(this,i,function(){return{x:o.x1,y:o.y1}});else{var s=a.size(),l=Math.sqrt(s*o.h/o.w),u=Math.round(l),c=Math.round(o.w/o.h*l),d=function(e){if(null==e)return Math.min(u,c);var t=Math.min(u,c);t==u?u=e:c=e},p=function(e){if(null==e)return Math.max(u,c);var t=Math.max(u,c);t==u?u=e:c=e};if(null!=i.rows&&null!=i.columns)u=i.rows,c=i.columns;else if(null!=i.rows&&null==i.columns)u=i.rows,c=Math.ceil(s/u);else if(null==i.rows&&null!=i.columns)c=i.columns,u=Math.ceil(s/c);else if(c*u>s){var h=d(),v=p();(h-1)*v>=s?d(h-1):(v-1)*h>=s&&p(v-1)}else for(;s>c*u;){var h=d(),v=p();(v+1)*h>=s?p(v+1):d(h+1)}var g=o.w/c,f=o.h/u;if(i.avoidOverlap)for(var y=0;y<a.length;y++){var m=a[y],x=m.outerWidth(),b=m.outerHeight();g=Math.max(g,x),f=Math.max(f,b)}for(var w={},_=function(e,t){return w["c-"+e+"-"+t]?!0:!1},E=function(e,t){w["c-"+e+"-"+t]=!0},S=0,P=0,D=function(){P++,P>=c&&(P=0,S++)},k={},y=0;y<a.length;y++){var m=a[y],C=i.position(m);if(C&&(void 0!==C.row||void 0!==C.col)){var T={row:C.row,col:C.col};if(void 0===T.col)for(T.col=0;_(T.row,T.col);)T.col++;else if(void 0===T.row)for(T.row=0;_(T.row,T.col);)T.row++;k[m.id()]=T,E(T.row,T.col)}}var N=function(e,t){var i,r;if(t.locked()||t.isFullAutoParent())return!1;var n=k[t.id()];if(n)i=n.col*g+g/2+o.x1,r=n.row*f+f/2+o.y1;else{for(;_(S,P);)D();i=P*g+g/2+o.x1,r=S*f+f/2+o.y1,E(S,P),D()}return{x:i,y:r}};a.layoutPositions(this,i,N)}return this},e("layout","grid",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={ready:function(){},stop:function(){}};t.prototype.run=function(){{var e=this.options,t=e.eles,i=this;e.cy}return i.trigger("layoutstart"),t.nodes().positions(function(){return{x:0,y:0}}),i.one("layoutready",e.ready),i.trigger("layoutready"),i.one("layoutstop",e.stop),i.trigger("layoutstop"),this},t.prototype.stop=function(){return this},e("layout","null",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={positions:void 0,zoom:void 0,pan:void 0,fit:!0,padding:30,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){function t(e){if(null==i.positions)return null;if(a)return i.positions.apply(e,[e]);var t=i.positions[e._private.data.id];return null==t?null:t}var i=this.options,r=i.eles,n=r.nodes(),a=e.is.fn(i.positions);return n.layoutPositions(this,i,function(e,i){var r=t(i);return i.locked()||null==r?!1:r}),this},e("layout","preset",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={fit:!0,padding:30,boundingBox:void 0,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){var t=this.options,i=t.cy,r=t.eles,n=r.nodes().not(":parent"),a=e.util.makeBoundingBox(t.boundingBox?t.boundingBox:{x1:0,y1:0,w:i.width(),h:i.height()}),o=function(){return{x:a.x1+Math.round(Math.random()*a.w),y:a.y1+Math.round(Math.random()*a.h)}};return n.layoutPositions(this,t,o),this},e("layout","random",t)}(cytoscape),function(e){"use strict";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={animate:!0,maxSimulationTime:4e3,ungrabifyWhileSimulating:!1,fit:!0,padding:30,boundingBox:void 0,random:!1,infinite:!1,ready:void 0,stop:void 0,stiffness:400,repulsion:400,damping:.5};t.prototype.run=function(){var t=this,i=this,r=this.options;return e.util.require("Springy",function(n){function a(e){var t=e.scratch("springy").model.id,i=w.layout.nodePoints[t].p,r=e.position(),n=null!=r.x&&null!=r.y?y(e.position()):{x:4*Math.random()-2,y:4*Math.random()-2};i.x=n.x,i.y=n.y}function o(){r.ungrabifyWhileSimulating&&E.ungrabify(),w.start()}var s=!1,l=r.cy;t.trigger({type:"layoutstart",layout:t});var u=r.eles,c=u.nodes().not(":parent"),d=u.edges(),p=e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:l.width(),h:l.height()}),h=new n.Graph;c.each(function(e,t){t.scratch("springy",{model:h.newNode({element:t})})}),d.each(function(e,t){var i=t.source().scratch("springy").model,r=t.target().scratch("springy").model;t.scratch("springy",{model:h.newEdge(i,r,{element:t})})});var v=window.sim=new n.Layout.ForceDirected(h,r.stiffness,r.repulsion,r.damping);r.infinite&&(v.minEnergyThreshold=-1/0);var g=v.getBoundingBox(),f=function(e){g=v.getBoundingBox();var t=g.topright.subtract(g.bottomleft),i=e.subtract(g.bottomleft).divide(t.x).x*p.w+p.x1,r=e.subtract(g.bottomleft).divide(t.y).y*p.h+p.x1;return new n.Vector(i,r)},y=function(e){g=v.getBoundingBox();var t=g.topright.subtract(g.bottomleft),i=(e.x-p.x1)/p.w*t.x+g.bottomleft.x,r=(e.y-p.y1)/p.h*t.y+g.bottomleft.y;return new n.Vector(i,r)},m=l.collection(),x=l.nodes().size(),b=1,w=new n.Renderer(v,function(){m.length>0&&r.animate&&(s=!0,m.rtrigger("position"),r.fit&&l.fit(r.padding),m=l.collection(),s=!1)},function(){},function(e,i){var n=f(i),a=e.data.element;a.locked()||a.grabbed()||(a._private.position={x:n.x,y:n.y},m.merge(a)),b==x&&(t.one("layoutready",r.ready),t.trigger({type:"layoutready",layout:t})),b++});c.each(function(e,t){r.random||a(t)});var _;c.on("position",_=function(){s||a(this)});var E=c.filter(":grabbable");i.stopSystem=function(){h.filterNodes(function(){return!1}),r.ungrabifyWhileSimulating&&E.grabify(),r.fit&&l.fit(r.padding),c.off("drag position",_),t.one("layoutstop",r.stop),t.trigger({type:"layoutstop",layout:t}),i.stopSystem=null},o(),r.infinite||setTimeout(function(){i.stop()},r.maxSimulationTime)}),this},t.prototype.stop=function(){return null!=this.stopSystem&&this.stopSystem(),this},e("layout","springy",t)}(cytoscape),function(e){"use strict";function t(e){this.options=e}t.prototype.recalculateRenderedStyle=function(){},t.prototype.notify=function(){},e("renderer","null",t)}(cytoscape);\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/cytoscape/dist/cytoscape.min.js\n ** module id = 6\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///../~/cytoscape/dist/cytoscape.min.js?')
},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Service for providing access the backend API via HTTP and WebSockets.\r\n */\r\n\r\nangular.module('qibud.common').factory('api', function ($rootScope, $http, $window) {\r\n\r\n  var apiBase = 'api' /* base /api uri */,\r\n      token = ($window.sessionStorage.token || $window.localStorage.token),\r\n      headers = {Authorization: 'Bearer ' + token},\r\n      wsHost = ($window.document.location.origin || ($window.location.protocol + '//' + $window.location.host)).replace(/^http/, 'ws'),\r\n      api = {events: {}};\r\n\r\n  // initiate the websocket connection to the host\r\n  var ws = api.ws = new WebSocket(wsHost + '?access_token=' + token);\r\n  $window.setInterval(function () {\r\n    ws.send('ping');\r\n  }, 1000 * 25); // keep-alive signal (needed for heroku)\r\n\r\n  // utilize jQuery's callbacks as an event system\r\n  function event() {\r\n    var callbacks = $.Callbacks();\r\n    return {\r\n      subscribe: function ($scope, fn) {\r\n        if (fn) {\r\n          // unsubscribe from event on controller destruction to prevent memory leaks\r\n          $scope.$on('$destroy', function () {\r\n            callbacks.remove(fn);\r\n          });\r\n        } else {\r\n          fn = $scope;\r\n        }\r\n        callbacks.add(fn);\r\n      },\r\n      unsubscribe: callbacks.remove,\r\n      publish: callbacks.fire\r\n    };\r\n  }\r\n\r\n  // websocket connected disconnected events\r\n  api.connected = event();\r\n  ws.onopen = function () {\r\n    api.connected.publish.apply(this, arguments);\r\n    $rootScope.$apply();\r\n  };\r\n\r\n  api.disconnected = event();\r\n  ws.onclose = function () {\r\n    api.disconnected.publish.apply(this, arguments);\r\n    $rootScope.$apply();\r\n  };\r\n\r\n  api.userupdate = event();\r\n\r\n  // api http endpoints and websocket events\r\n  api.buds = {\r\n    search: function (query) {\r\n      return $http({method: 'GET', url: apiBase + '/buds/search/'+ query,headers: headers});\r\n    },\r\n    childrenByType: function (budId,type) {\r\n      return $http({method: 'GET', url: apiBase + '/buds/'+ budId + '/child/' + type, headers: headers});\r\n    },\r\n    parentByType: function (budId,type) {\r\n      return $http({method: 'GET', url: apiBase + '/buds/'+ budId + '/parent/' + type, headers: headers});\r\n    },\r\n    list: function () {\r\n      return $http({method: 'GET', url: apiBase + '/buds', headers: headers});\r\n    },\r\n    view: function (budId) {\r\n      return $http({method: 'GET', url: apiBase + '/buds/' + budId + '/view', headers: headers});\r\n    },\r\n    update: function (bud) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/update', data: bud, headers: headers});\r\n    },\r\n    updated: event(),\r\n    delete: function (budId) {\r\n      return $http({method: 'DELETE', url: apiBase + '/buds/' + budId, headers: headers});\r\n    },\r\n    create: function (bud) {\r\n      return $http({method: 'POST', url: apiBase + '/buds', data: bud, headers: headers});\r\n    },\r\n    createSub: function (parentBudId, bud) {\r\n      return $http({method: 'POST', url: apiBase + '/buds/' + parentBudId, data: bud, headers: headers});\r\n    },\r\n    created: event(),\r\n    evolve: function (budId, type) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + budId + '/evolve/' + type, headers: headers});\r\n    },\r\n    evolved: event(),\r\n    follow : function(bud) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/follow', data: bud, headers: headers});\r\n    },\r\n    unfollow : function(bud) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/unfollow', data: bud, headers: headers});\r\n    },\r\n    followersChanged: event(),\r\n    sponsor : function(bud) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/sponsor', data: bud, headers: headers});\r\n    },\r\n    unsponsor : function(bud) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/unsponsor', data: bud, headers: headers});\r\n    },\r\n    sponsorsChanged: event(),\r\n    support : function(bud) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/support', data: bud, headers: headers});\r\n    },\r\n    unsupport : function(bud) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/unsupport', data: bud, headers: headers});\r\n    },\r\n    supportersChanged: event(),\r\n    share : function(bud, users) {\r\n      return $http({method: 'PUT', url: apiBase + '/buds/' + bud.id + '/share', data: users, headers: headers});\r\n    },\r\n    sharesChanged: event(),\r\n    budPacksData: {\r\n      create : function (budId, packData, type) {\r\n        return $http({method: 'POST', url: apiBase + '/buds/' + budId + '/packdata/' + type, data: packData, headers: headers});\r\n      },\r\n      get: function (budId, type) {\r\n        return $http({method: 'GET', url: apiBase + '/buds/' + budId + '/packdata/' + type, headers: headers});\r\n      },\r\n      set: function (budId, packData, type) {\r\n        return $http({method: 'PUT', url: apiBase + '/buds/' + budId + '/packdata/' + type, data: packData, headers: headers});\r\n      },\r\n      created: event(),\r\n      updated: event()\r\n    },\r\n    comments: {\r\n      create: function (budId, comment) {\r\n        return $http({method: 'POST', url: apiBase + '/buds/' + budId + '/comments', data: comment, headers: headers});\r\n      },\r\n      created: event()\r\n    },\r\n    sendByMail: function (budId, to) {\r\n      return $http({method: 'POST', url: apiBase + '/buds/' + budId + '/mailto/' + to, headers: headers});\r\n    }\r\n  };\r\n\r\n  api.qi = {\r\n    updated: event()\r\n  };\r\n\r\n  api.mailboxes = {\r\n    get: function () {\r\n      return $http({method: 'GET', url: apiBase + '/user/mailboxes/emails', headers: headers});\r\n    },\r\n    incoming: event()\r\n  };\r\n\r\n  api.links = {\r\n    createB2B : function (budId, type, budId2) {\r\n      return $http({method: 'POST', url: apiBase + '/links/b2b/' + budId + '/' + type + '/' + budId2, headers: headers});\r\n    },\r\n    createB2U : function (budId, type, userId) {\r\n      return $http({method: 'POST', url: apiBase + '/links/b2u/' + budId + '/' + type + '/' + userId, headers: headers});\r\n    },\r\n    createU2B : function (userId, type, budId) {\r\n      return $http({method: 'POST', url: apiBase + '/links/u2b/' + userId + '/' + type + '/' + budId, headers: headers});\r\n    },\r\n    deleteU2B : function (userId, type, budId) {\r\n      return $http({method: 'DELETE', url: apiBase + '/links/u2b/' + userId + '/' + type + '/' + budId, headers: headers});\r\n    },\r\n    findU2B : function (userId, type) {\r\n      return $http({method: 'GET', url: apiBase + '/links/u2b/' + userId + '/' + type, headers: headers});\r\n    }\r\n  };\r\n\r\n  api.users = {\r\n    list: function () {\r\n      return $http({method: 'GET', url: apiBase + '/users', headers: headers});\r\n    },\r\n    get: function (userId) {\r\n      return $http({method: 'GET', url: apiBase + '/users/' + userId, headers: headers});\r\n    },\r\n  };\r\n\r\n  api.actors = {\r\n    list: function (includeMe) {\r\n      var me = false;\r\n      if(includeMe) {\r\n        me = includeMe;\r\n      }\r\n      return $http({method: 'GET', url: apiBase + '/actors/' + me, headers: headers});\r\n    }\r\n  };\r\n\r\n  api.events = {\r\n    list: function () {\r\n      return $http({method: 'GET', url: apiBase + '/events', headers: headers});\r\n    }\r\n  };\r\n\r\n  api.types = {\r\n    get: function (type) {\r\n      return $http({method: 'GET', url: apiBase + '/types/' + type, headers: headers})\r\n    },\r\n    list: function () {\r\n      return $http({method: 'GET', url: apiBase + '/types', headers: headers});\r\n    }\r\n  };\r\n\r\n  api.debug = {\r\n    clearDatabase: function () {\r\n      return $http({method: 'POST', url: apiBase + '/debug/clearDatabase', headers: headers});\r\n    }\r\n  };\r\n\r\n  // websocket data event (which transmits json-rpc payloads)\r\n  function index(obj, i) {\r\n    return obj[i];\r\n  } // convert dot notation string into an actual object index\r\n  ws.onmessage = function (event /* websocket event object */) {\r\n    var data = JSON.parse(event.data /* rpc event object (data) */);\r\n    if (!data.method) {\r\n      throw 'Malformed event data received through WebSocket. Received event data object was: ' + data;\r\n    } else if (!data.method.split('.').reduce(index, api)) {\r\n      throw 'Undefined event type received through WebSocket. Received event data object was: ' + data;\r\n    }\r\n    data.method.split('.').reduce(index, api).publish(data.params);\r\n    $rootScope.$apply();\r\n  };\r\n\r\n  return api;\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/common/api-service.js\n ** module id = 38\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/common/api-service.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Module definition for common components used by other all other app modules.\r\n */\r\n\r\nangular.module('qibud.common', ['ui.bootstrap']);\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/common/common.js\n ** module id = 39\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/common/common.js?")},function(module,exports,__webpack_require__){eval("\r\nangular.module('qibud.common').controller('MailConverterCtrl',\r\nfunction ($scope, $modalInstance, email) {\r\n\r\n  $scope.email = email;\r\n\r\n  $scope.ok = function () {\r\n    $modalInstance.close($scope.selectedUsers);\r\n  };\r\n\r\n  $scope.cancel = function () {\r\n    $modalInstance.dismiss('cancel');\r\n  };\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/common/mail-controller.js\n ** module id = 40\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/common/mail-controller.js?")},function(module,exports,__webpack_require__){eval("\r\nangular.module('qibud.common').controller('MailboxCtrl',\r\nfunction ($scope, $modal, api)\r\n{\r\n  $scope.emails = {};\r\n  api.mailboxes.get().success(function (emails) {\r\n    $scope.emails = emails;\r\n  });\r\n\r\n  $scope.openEmail = function (email) {\r\n    var modalInstance = $modal.open({\r\n      templateUrl: 'mail.html',\r\n      controller: 'MailConverterCtrl',\r\n      size: 'lg',\r\n      resolve: {\r\n        email: function () {\r\n          return email;\r\n        }\r\n      }\r\n    });\r\n\r\n    modalInstance.result.then(function (budId) {\r\n      //view bud\r\n\r\n    }, function () {\r\n      //dismiss\r\n    });\r\n  };\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/common/mailbox-controller.js\n ** module id = 41\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/common/mailbox-controller.js?")},function(module,exports,__webpack_require__){eval("\r\nangular.module('qibud.common').controller('SearchCtrl',\r\nfunction ($scope, api) {\r\n  $scope.results = [];\r\n  $scope.displayedBuds = [];\r\n  $scope.visible = false;\r\n  $scope.update = function () {\r\n    $scope.displayedBuds = [].concat($scope.results);\r\n    console.log ($scope.displayedBuds);\r\n    $scope.visible = true;\r\n  };\r\n  $scope.hide = function ()\r\n  {\r\n    $scope.visible = false;\r\n  };\r\n\r\n  $scope.show = function ()\r\n  {\r\n    $scope.visible = true;\r\n  };\r\n  $scope.search = function(query) {\r\n    if(query) {\r\n      api.buds.search(query).success(function (results) {\r\n        if(results.hits){\r\n          if(results.hits.total > 0) {\r\n            $scope.results = results.hits.hits.map(function(item){\r\n              return item;\r\n            });\r\n            $scope.update ();\r\n          } else {\r\n            $scope.results = {}\r\n          }\r\n        }\r\n      });\r\n    }\r\n  };\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/common/search-controller.js\n ** module id = 42\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/common/search-controller.js?")},function(module,exports,__webpack_require__){eval("angular.module('qibud.dashboard',[]).controller('DashboardCtrl', ['$scope', '$cookieStore', DashboardCtrl]);\nfunction DashboardCtrl($scope, $cookieStore) {\n    /**\n     * Sidebar Toggle & Cookie Control\n     *\n     */\n\n    var mobileView = 992;\n    $scope.getWidth = function() { return window.innerWidth; };\n\n    $scope.$watch($scope.getWidth, function(newValue, oldValue)\n    {\n        if(newValue >= mobileView)\n        {\n            if(angular.isDefined($cookieStore.get('toggle')))\n            {\n                if($cookieStore.get('toggle') == false)\n                {\n                    $scope.toggle = false;\n                }\n                else\n                {\n                    $scope.toggle = true;\n                }\n            }\n            else\n            {\n                $scope.toggle = true;\n            }\n        }\n        else\n        {\n            $scope.toggle = false;\n        }\n\n    });\n\n    $scope.toggleSidebar = function()\n    {\n        $scope.toggle = ! $scope.toggle;\n\n        $cookieStore.put('toggle', $scope.toggle);\n    };\n\n    window.onresize = function() { $scope.$apply(); };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/dashboard/dashboard.js\n ** module id = 43\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/dashboard/dashboard.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Editor controller provide a good way to edit/write buds\r\n */\r\n\r\nangular.module('qibud.editor').controller('EditorCtrl',\r\nfunction ($scope, $state, $stateParams, $modal, $location, api)\r\n{\r\n  var user       = $scope.common.user;\r\n\r\n  if($stateParams.budId)\r\n  {\r\n    api.buds.view($stateParams.budId).success(function (bud)\r\n    {\r\n      $scope.editedBud = bud;\r\n      $scope.budBox = {\r\n        title: bud.title,\r\n        content: bud.content,\r\n        privacy: bud.privacy,\r\n        type : bud.type,\r\n        disabled: false,\r\n        action: 'update'\r\n      };\r\n\r\n      $scope.setType(bud.type);\r\n    });\r\n  }\r\n  else\r\n  {\r\n    $scope.budBox  = {\r\n      title: null,\r\n      content: null,\r\n      type: 'Bud',\r\n      disabled: false,\r\n      privacy: 'Private',\r\n      action: 'create'\r\n    };\r\n  }\r\n\r\n  if($stateParams.parentBudId)\r\n  {\r\n    api.buds.view($stateParams.parentBudId).success(function (bud)\r\n    {\r\n      $scope.parentBud = bud;\r\n    });\r\n\r\n    $scope.budBox.action = 'subbud';\r\n  }\r\n\r\n  if($stateParams.content)\r\n  {\r\n    $scope.budBox.content = $stateParams.content;\r\n  }\r\n\r\n  $scope.editorOptions = {uiColor: '#000000'};\r\n\r\n  // add bud creation functions to scope\r\n  $scope.createBud = function ($event)\r\n  {\r\n\r\n    // don't let the user type in blank lines or submit empty/whitespace only bud, or type in something when bud is being created\r\n    if (!$scope.budBox.content.length || $scope.budBox.disabled)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    var modalInstance = $modal.open ({\r\n      templateUrl: 'evolvebox.html',\r\n      controller: 'EvolveCtrl',\r\n      size: 'lg',\r\n      resolve: {\r\n        availableTypes: function () {\r\n          return $scope.common.availableTypes;\r\n        }\r\n      }\r\n    });\r\n\r\n    var createSubBud = function (selectedType)\r\n    {\r\n      // disable the bud box and push the new bud to server\r\n      $scope.budBox.disabled = true;\r\n      api.buds.createSub($scope.parentBud.id,{\r\n        title: $scope.budBox.title,\r\n        content: $scope.budBox.content,\r\n        privacy: $scope.budBox.privacy,\r\n        type   : $scope.budBox.type\r\n      })\r\n      .success(function (budId)\r\n        {\r\n          // clear the bud box and enable it\r\n          $scope.budBox.title = '';\r\n          $scope.budBox.content = '';\r\n          $scope.budBox.disabled = false;\r\n\r\n          console.info ('subbud created');\r\n          if (selectedType !== null) {//evolve if needed\r\n            api.buds.evolve(budId, selectedType).success(function () {\r\n              console.info ('bud evolve in ' + selectedType);\r\n              $state.go('bud.viewer',{budId : budId},{ reload: true });\r\n            });\r\n          } else {\r\n            $state.go('bud.viewer',{budId : budId},{ reload: true });\r\n          }\r\n        })\r\n        .error(function ()\r\n        {\r\n          // don't clear the bud box but enable it so the user can re-try\r\n          $scope.budBox.disabled = false;\r\n        });\r\n    };\r\n\r\n    var createBud = function (selectedType) {\r\n      // disable the bud box and push the new bud to server\r\n      $scope.budBox.disabled = true;\r\n      api.buds.create({\r\n        title: $scope.budBox.title,\r\n        content: $scope.budBox.content,\r\n        privacy: $scope.budBox.privacy,\r\n        type   : $scope.budBox.type\r\n      })\r\n      .success(function (budId)\r\n          {\r\n            // clear the bud box and enable it\r\n            $scope.budBox.title = '';\r\n            $scope.budBox.content = '';\r\n            $scope.budBox.disabled = false;\r\n\r\n            console.info ('bud created');\r\n            if (selectedType !== null) {//evolve if needed\r\n              api.buds.evolve(budId, selectedType).success(function () {\r\n                console.info ('bud evolve in ' + selectedType);\r\n                $state.go('bud.viewer',{budId : budId},{ reload: true });\r\n              });\r\n            } else {\r\n              $state.go('bud.viewer',{budId : budId},{ reload: true });\r\n            }\r\n        })\r\n        .error(function ()\r\n        {\r\n          // don't clear the bud box but enable it so the user can re-try\r\n          $scope.budBox.disabled = false;\r\n        });\r\n    };\r\n\r\n    modalInstance.result.then(function (selectedType) {\r\n      if ($scope.parentBud) {\r\n        createSubBud (selectedType);\r\n      } else {\r\n        createBud (selectedType);\r\n      }\r\n\r\n    }, function () {\r\n      if ($scope.parentBub) {\r\n        createSubBud (null);\r\n      } else {\r\n        createBud (null);\r\n      }\r\n    });\r\n  };\r\n\r\n\r\n  $scope.updateBud = function ($event)\r\n  {\r\n    // don't let the user type in blank lines or submit empty/whitespace only bud, or type in something when bud is being created\r\n    if (!$scope.budBox.content.length || $scope.budBox.disabled)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    // disable the bud box and push the new bud to server\r\n    $scope.budBox.disabled = true;\r\n\r\n    $scope.editedBud.title   = $scope.budBox.title;\r\n    $scope.editedBud.content = $scope.budBox.content;\r\n    $scope.editedBud.privacy = $scope.budBox.privacy;\r\n\r\n    api.buds.update($scope.editedBud).success(function (bud)\r\n    {\r\n      //redirect\r\n      $state.go('bud.viewer', {budId: $scope.editedBud.id},{ reload: true });\r\n    })\r\n    .error(function ()\r\n    {\r\n      // don't clear the bud box but enable it so the user can re-try\r\n      $scope.budBox.disabled = false;\r\n    });\r\n  };\r\n\r\n\r\n\r\n  // subscribe to websocket events to receive new buds, comments, etc.\r\n  api.buds.created.subscribe($scope, function (bud)\r\n  {\r\n\r\n  });\r\n\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/editor/editor-controller.js\n ** module id = 44\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/editor/editor-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nangular.module('qibud.editor').controller('EvolveCtrl', function ($scope, $modalInstance, availableTypes) {\n\n  $scope.availableTypes = availableTypes;\n  $scope.selectedType = 'Bud';\n\n  $scope.setSelected = function (type) {\n    $scope.selectedType = type;\n  };\n  \n  $scope.ok = function () {\n    $modalInstance.close($scope.selectedType);\n  };\n\n  $scope.cancel = function () {\n    $modalInstance.dismiss('cancel');\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/editor/editor-evolve-controller.js\n ** module id = 45\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/editor/editor-evolve-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Editor module for buds\r\n */\r\n\r\nangular\r\n    .module('qibud.editor', [\r\n      'ui.router',\r\n      'qibud.common'\r\n    ])\r\n    .config(function ($stateProvider, $urlRouterProvider) {\r\n      $stateProvider\r\n          .state('bud.editor', {\r\n            title: 'Qibud Editor',\r\n            url: \"/editor/:budId/:parentBudId/:content\",\r\n            breadcrumb: {\r\n              class: 'highlight',\r\n              text: 'Bud Editor',\r\n              stateName: 'bud.editor'\r\n            },\r\n            templateUrl: 'modules/editor/editor.html',\r\n            controller: 'EditorCtrl'\r\n      });\r\n    });\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/editor/editor.js\n ** module id = 46\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/editor/editor.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Display actore assignement for current user\r\n */\r\n\r\nangular.module('qibud.home').controller('AssignmentsCtrl',\r\nfunction ($scope, $state, $filter, api)\r\n{\r\n  var user             = $scope.common.user;\r\n  $scope.itemsByPage   = 10;\r\n  $scope.displayedBuds = [];\r\n\r\n  api.links.findU2B(user.id, 'ASSIGNED').success(function (buds)\r\n  {\r\n    $scope.buds = buds;\r\n    $scope.displayedBuds = [].concat($scope.buds);\r\n  });\r\n\r\n\r\n  // subscribe to websocket events to receive new buds, comments, etc.\r\n  api.buds.created.subscribe($scope, function (bud)\r\n  {\r\n    // only add the bud if we don't have it already in the buds list to avoid dupes\r\n    if (!_.some($scope.buds, function (b)\r\n    {\r\n      return b.id === bud.id;\r\n    }))\r\n    {\r\n      $scope.buds.unshift(bud);\r\n      $scope.displayedBuds = [].concat($scope.buds);\r\n    }\r\n  });\r\n\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/assignments-controller.js\n ** module id = 47\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/assignments-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Home controller simply lists all the buds from everyone on the front page.\r\n */\r\n\r\nangular.module('qibud.home').controller('BudgraphCtrl',\r\nfunction ($scope, $state, api, budGraph)\r\n{\r\n  var user       = $scope.common.user;\r\n  var cy; // maybe you want a ref to cy\r\n  // (usually better to have the srv as intermediary)\r\n\r\n  var budsById = {};\r\n  // retrieve buds from server\r\n  api.buds.list().success(function (buds)\r\n  {\r\n    $scope.buds = buds;\r\n    for( var i = 0; i < $scope.buds.length; i++ ){\r\n      var p = $scope.buds[i];\r\n\r\n      budsById[ p.id ] = p;\r\n    }\r\n\r\n    // you would probably want some ui to prevent use of budsCtrl until cy is loaded\r\n    budGraph( $scope.buds ).then(function( budsCy ){\r\n      cy = budsCy;\r\n      // use this variable to hide ui until cy loaded if you want\r\n      $scope.cyLoaded = true;\r\n    });\r\n  });\r\n\r\n\r\n  budGraph.onClick(function(id){\r\n    $state.go('bud.viewer',{budId : id});\r\n  });\r\n\r\n  // subscribe to websocket events to receive new buds, comments, etc.\r\n  api.buds.created.subscribe($scope, function (bud)\r\n  {\r\n    // only add the bud if we don't have it already in the buds list to avoid dupes\r\n    if (!_.some($scope.buds, function (b)\r\n    {\r\n      return b.id === bud.id;\r\n    }))\r\n    {\r\n      bud.comments = [];\r\n      bud.commentBox = {message: '', disabled: false};\r\n      $scope.buds.unshift(bud);\r\n    }\r\n  });\r\n\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/budgraph-controller.js\n ** module id = 48\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/budgraph-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\nvar cytoscape = __webpack_require__(4);\r\n/**\r\n * Home module for displaying home page content.\r\n */\r\n\r\nangular\r\n    .module('qibud.home')\r\n    .factory('budGraph', [ '$q', function( $q ) {\r\n      var cy;\r\n\r\n      var budGraph = function(buds) {\r\n        var deferred = $q.defer();\r\n\r\n        // put buds model in cy.js\r\n        var eles = [];\r\n        for( var i = 0; i < buds.length; i++ ){\r\n          var bud = buds[i];\r\n          var info;\r\n\r\n\r\n          if (bud.dataCache.state) {\r\n            info = bud.title + ' (' + bud.dataCache.state + ')';\r\n          }  else {\r\n            info = bud.title;\r\n          }\r\n\r\n          eles.push({\r\n            group: 'nodes',\r\n            data: {\r\n              id: bud.id,\r\n              type: bud.typeInfo,\r\n              weight: bud.qi,\r\n              size: 100,\r\n              picture: 'url(/images/'+ bud.type + '.svg)',\r\n              name: info,\r\n              faveColor: '#30426a',\r\n              faveShape: 'roundrectangle'\r\n            }\r\n          });\r\n        }\r\n\r\n        for( var i = 0; i < buds.length; i++ ){\r\n          if(buds[i].subBuds) {\r\n            for( var s = 0; s < buds[i].subBuds.length; s++ ) {\r\n              eles.push({\r\n                group: 'edges',\r\n                data: {\r\n                  source: buds[i].id,\r\n                  target: buds[i].subBuds[s].id,\r\n                  faveColor: '#30426a',\r\n                  strength: 0.1\r\n                }\r\n              });\r\n            }\r\n          }\r\n\r\n        }\r\n\r\n        $(function(){ // on dom ready\r\n\r\n          cy = cytoscape({\r\n            container: $('#cy')[0],\r\n\r\n            style: cytoscape.stylesheet()\r\n              .selector('node')\r\n                .css({\r\n                  'shape': 'data(faveShape)',\r\n                  'width': 'data(size)',\r\n                  'height': 100,\r\n                  'content': 'data(name)',\r\n                  'text-valign': 'top',\r\n                  'text-outline-width': 2,\r\n                  'background-image': 'data(picture)',\r\n                  'background-fit': 'cover',\r\n                  'color': '#ffffff',\r\n                  'box-shadow': '0 10px 18px rgba(0,0,0,.22),0 14px 45px rgba(0,0,0,.25)'\r\n                })\r\n              .selector(':selected')\r\n                .css({\r\n                  'border-width': 3,\r\n                  'border-color': '#333'\r\n                })\r\n              .selector('edge')\r\n                .css({\r\n                  'opacity': 0.666,\r\n                  'width': 'mapData(strength, 35, 50, 2, 6)',\r\n                  'target-arrow-shape': 'triangle',\r\n                  'source-arrow-shape': 'circle',\r\n                  'line-color': 'data(faveColor)',\r\n                  'source-arrow-color': 'data(faveColor)',\r\n                  'target-arrow-color': 'data(faveColor)'\r\n                })\r\n              .selector('.faded')\r\n                .css({\r\n                  'opacity': 0.25,\r\n                  'text-opacity': 0\r\n                }),\r\n\r\n            layout: {\r\n              name: 'breadthfirst',\r\n              directed: true,\r\n              padding: 5\r\n            },\r\n\r\n            elements: eles,\r\n\r\n            ready: function() {\r\n              deferred.resolve( this );\r\n\r\n              cy.on('cxtdrag', 'node', function(e){\r\n                var node = this;\r\n              });\r\n\r\n              cy.on('tap', 'node', function(e){\r\n                var node = this;\r\n                fire('onClick', [ node.id() ]);\r\n              });\r\n\r\n\r\n            }\r\n          });\r\n\r\n        }); // on dom ready\r\n\r\n        return deferred.promise;\r\n      };\r\n\r\n      budGraph.listeners = {};\r\n\r\n      function fire(e, args){\r\n        var listeners = budGraph.listeners[e];\r\n\r\n        for( var i = 0; listeners && i < listeners.length; i++ ){\r\n          var fn = listeners[i];\r\n\r\n          fn.apply( fn, args );\r\n        }\r\n      }\r\n\r\n      function listen(e, fn){\r\n        var listeners = budGraph.listeners[e] = budGraph.listeners[e] || [];\r\n\r\n        listeners.push(fn);\r\n      }\r\n\r\n      budGraph.onClick = function(fn){\r\n        listen('onClick', fn);\r\n      };\r\n\r\n      return budGraph;\r\n\r\n    }]);\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/budgraph-factory.js\n ** module id = 49\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/budgraph-factory.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Home controller simply lists all the buds from everyone on the front page.\r\n */\r\n\r\nangular.module('qibud.home').controller('HomeCtrl',\r\nfunction ($scope, $state, $filter, api)\r\n{\r\n  var user             = $scope.common.user;\r\n  $scope.itemsByPage   = 10;\r\n  $scope.displayedBuds = [];\r\n\r\n  api.buds.list().success(function (buds)\r\n  {\r\n    $scope.buds = buds;\r\n    $scope.displayedBuds = [].concat($scope.buds);\r\n  });\r\n\r\n\r\n  // subscribe to websocket events to receive new buds, comments, etc.\r\n  api.buds.created.subscribe($scope, function (bud)\r\n  {\r\n    // only add the bud if we don't have it already in the buds list to avoid dupes\r\n    if (!_.some($scope.buds, function (b)\r\n    {\r\n      return b.id === bud.id;\r\n    }))\r\n    {\r\n      $scope.buds.unshift(bud);\r\n      $scope.displayedBuds = [].concat($scope.buds);\r\n    }\r\n  });\r\n\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/home-controller.js\n ** module id = 50\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/home-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Home module for displaying home page content.\r\n */\r\n\r\nangular\r\n    .module('qibud.home', [\r\n      'ui.router',\r\n      'qibud.common'\r\n    ])\r\n    .config(function ($stateProvider, $urlRouterProvider) {\r\n      $stateProvider\r\n      .state('home.budlist', {\r\n        title: 'Bud list',\r\n        breadcrumb: {\r\n          class: 'highlight',\r\n          text: 'Bud list',\r\n          stateName: 'home.budlist'\r\n        },\r\n        url: \"/list\",\r\n        templateUrl: 'modules/home/home-list.html',\r\n        controller: 'HomeCtrl'\r\n      })\r\n      .state('home.invitations', {\r\n        title: 'Invitations',\r\n        breadcrumb: {\r\n          class: 'highlight',\r\n          text: 'Invitations list',\r\n          stateName: 'home.invitations'\r\n        },\r\n        url: \"/invitations\",\r\n        templateUrl: 'modules/home/invitations-list.html',\r\n        controller: 'InvitationsCtrl'\r\n      })\r\n      .state('home.assignments', {\r\n        title: 'Assignments',\r\n        breadcrumb: {\r\n          class: 'highlight',\r\n          text: 'Assignments list',\r\n          stateName: 'home.assignments'\r\n        },\r\n        url: \"/assignments\",\r\n        templateUrl: 'modules/home/assignments-list.html',\r\n        controller: 'AssignmentsCtrl'\r\n      })\r\n      .state('home.budgraph', {\r\n        title: 'Bud Graph',\r\n        breadcrumb: {\r\n          class: 'highlight',\r\n          text: 'Bud Graph',\r\n          stateName: 'home.budgraph'\r\n        },\r\n        url: \"/budgraph\",\r\n        templateUrl: 'modules/home/home-budgraph.html',\r\n        controller: 'BudgraphCtrl'\r\n      })\r\n      .state('home.socialgraph', {\r\n        title: 'Social Graph',\r\n        breadcrumb: {\r\n          class: 'highlight',\r\n          text: 'Social Graph',\r\n          stateName: 'bud.home.socialgraph'\r\n        },\r\n        url: \"/socialgraph\",\r\n        templateUrl: 'modules/home/home-socialgraph.html',\r\n        controller: 'SocialgraphCtrl'\r\n      })\r\n      .state('home.timeline', {\r\n        title: 'Bud Timeline',\r\n        breadcrumb: {\r\n          class: 'highlight',\r\n          text: 'Bud Timeline',\r\n          stateName: 'bud.home.timeline'\r\n        },\r\n        url: \"/timeline\",\r\n        templateUrl: 'modules/home/home-timeline.html',\r\n        controller: 'TimelineCtrl'\r\n      });\r\n    });\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/home.js\n ** module id = 51\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/home.js?")
},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Display meeting invitations for user\r\n */\r\n\r\nangular.module('qibud.home').controller('InvitationsCtrl',\r\nfunction ($scope, $state, $filter, api)\r\n{\r\n  var user             = $scope.common.user;\r\n  $scope.itemsByPage   = 10;\r\n  $scope.displayedBuds = [];\r\n\r\n  api.links.findU2B(user.id, 'INVITED').success(function (buds)\r\n  {\r\n    $scope.buds = buds;\r\n    $scope.displayedBuds = [].concat($scope.buds);\r\n  });\r\n\r\n\r\n  // subscribe to websocket events to receive new buds, comments, etc.\r\n  api.buds.created.subscribe($scope, function (bud)\r\n  {\r\n    // only add the bud if we don't have it already in the buds list to avoid dupes\r\n    if (!_.some($scope.buds, function (b)\r\n    {\r\n      return b.id === bud.id;\r\n    }))\r\n    {\r\n      $scope.buds.unshift(bud);\r\n      $scope.displayedBuds = [].concat($scope.buds);\r\n    }\r\n  });\r\n\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/invitations-controller.js\n ** module id = 52\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/invitations-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Home controller simply lists all the buds from everyone on the front page.\r\n */\r\n\r\nangular.module('qibud.home').controller('SocialgraphCtrl',\r\nfunction ($scope, $state, api, socialGraph)\r\n{\r\n  var user       = $scope.common.user;\r\n  var cy; // maybe you want a ref to cy\r\n  // (usually better to have the srv as intermediary)\r\n\r\n  // retrieve actors from server\r\n  api.actors.list(true).success(function (actors)\r\n  {\r\n    $scope.actors = actors;\r\n    // you would probably want some ui to prevent use of budsCtrl until cy is loaded\r\n    socialGraph( $scope.actors ).then(function( budsCy ){\r\n      cy = budsCy;\r\n      // use this variable to hide ui until cy loaded if you want\r\n      $scope.cyLoaded = true;\r\n    });\r\n  });\r\n\r\n\r\n  socialGraph.onClick(function(id){\r\n    \r\n  });\r\n\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/socialgraph-controller.js\n ** module id = 53\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/socialgraph-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\nvar cytoscape = __webpack_require__(4);\r\n/**\r\n * Home module for displaying home page content.\r\n */\r\n\r\nangular\r\n    .module('qibud.home')\r\n    .factory('socialGraph', [ '$q', function( $q ) {\r\n      var cy;\r\n\r\n      var socialGraph = function(actors) {\r\n        var deferred = $q.defer();\r\n        var teams = actors.teams;\r\n        var users = actors.users;\r\n        // put actors model in cy.js\r\n        var eles = [];\r\n        for( var i = 0; i < teams.length; i++ ){\r\n          var team = teams[i];\r\n\r\n          eles.push({\r\n            group: 'nodes',\r\n            data: {\r\n              id: team.id,\r\n              type: 'Team',\r\n              size: 100,\r\n              name: team.name,\r\n              picture: 'url(/images/Team.svg)',\r\n              faveColor: '#30426a',\r\n              faveShape: 'roundrectangle'\r\n            }\r\n          });\r\n          console.log (team.name + ' ' + team.id);\r\n        }\r\n\r\n        for( var i = 0; i < users.length; i++ ){\r\n          var user = users[i];\r\n\r\n          eles.push({\r\n            group: 'nodes',\r\n            data: {\r\n              id: 'x' + user.id,\r\n              type: 'Member',\r\n              size: 100,\r\n              name: user.name,\r\n              picture: 'url(data:image/png;base64,' + user.picture + ')',\r\n              faveColor: '#45322a',\r\n              faveShape: 'ellipse'\r\n            }\r\n          });\r\n\r\n          console.log (user.name + ' ' + user.id);\r\n        }\r\n\r\n        for( var i = 0; i < teams.length; i++ ){\r\n          for( var s = 0; s < teams[i].members.length; s++ ) {\r\n            eles.push({\r\n              group: 'edges',\r\n              data: {\r\n                source: teams[i].id,\r\n                target: 'x' + teams[i].members[s].id,\r\n                faveColor: '#30426a',\r\n                strength: 1\r\n              }\r\n            });\r\n            console.log (teams[i].id + ' ->' + teams[i].members[s].id);\r\n          }\r\n        }\r\n\r\n        $(function(){ // on dom ready\r\n\r\n          cy = cytoscape({\r\n            container: $('#cy')[0],\r\n\r\n            style: cytoscape.stylesheet()\r\n              .selector('node')\r\n                .css({\r\n                  'shape': 'data(faveShape)',\r\n                  'width': 'data(size)',\r\n                  'height': 100,\r\n                  'text-valign': 'top',\r\n                  'content': 'data(name)',\r\n                  'text-outline-width': 2,\r\n                  'background-image': 'data(picture)',\r\n                  'background-fit': 'cover',\r\n                  'color': '#ffffff',\r\n                  'box-shadow': '0 10px 18px rgba(0,0,0,.22),0 14px 45px rgba(0,0,0,.25)'\r\n                })\r\n              .selector(':selected')\r\n                .css({\r\n                  'border-width': 3,\r\n                  'border-color': '#333'\r\n                })\r\n              .selector('edge')\r\n                .css({\r\n                  'opacity': 0.666,\r\n                  'width': 'mapData(strength, 35, 50, 2, 6)',\r\n                  'target-arrow-shape': 'circle',\r\n                  'source-arrow-shape': 'triangle',\r\n                  'line-color': 'data(faveColor)',\r\n                  'source-arrow-color': 'data(faveColor)',\r\n                  'target-arrow-color': 'data(faveColor)'\r\n                })\r\n              .selector('.faded')\r\n                .css({\r\n                  'opacity': 0.25,\r\n                  'text-opacity': 0\r\n                }),\r\n\r\n            layout: {\r\n              name: 'circle',\r\n              fit: true, // whether to fit the viewport to the graph\r\n              padding: 30 // the padding on fit\r\n            },\r\n\r\n            elements: eles,\r\n\r\n            ready: function() {\r\n              deferred.resolve( this );\r\n\r\n              cy.on('cxtdrag', 'node', function(e){\r\n                var node = this;\r\n              });\r\n\r\n              cy.on('tap', 'node', function(e){\r\n                var node = this;\r\n                fire('onClick', [ node.id() ]);\r\n              });\r\n\r\n\r\n            }\r\n          });\r\n\r\n        }); // on dom ready\r\n\r\n        return deferred.promise;\r\n      };\r\n\r\n      socialGraph.listeners = {};\r\n\r\n      function fire(e, args){\r\n        var listeners = socialGraph.listeners[e];\r\n\r\n        for( var i = 0; listeners && i < listeners.length; i++ ){\r\n          var fn = listeners[i];\r\n\r\n          fn.apply( fn, args );\r\n        }\r\n      }\r\n\r\n      function listen(e, fn){\r\n        var listeners = socialGraph.listeners[e] = socialGraph.listeners[e] || [];\r\n\r\n        listeners.push(fn);\r\n      }\r\n\r\n      socialGraph.onClick = function(fn){\r\n        listen('onClick', fn);\r\n      };\r\n\r\n      return socialGraph;\r\n\r\n    }]);\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/socialgraph-factory.js\n ** module id = 54\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/socialgraph-factory.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n *\r\n */\r\n\r\nangular.module('qibud.home').controller('TimelineCtrl',\r\nfunction ($scope, $state, api, budGraph)\r\n{\r\n  var user       = $scope.common.user;\r\n\r\n  api.events.list().success(function (events)\r\n  {\r\n    $scope.events = events;\r\n  });\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/home/timeline-controller.js\n ** module id = 55\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/home/timeline-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Profile controller gives the user the means to view/edit their public profile info.\r\n */\r\n\r\nangular.module('qibud.profile').controller('ProfileCtrl', function ($scope) {\r\n  $scope.user = $scope.common.user;\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/profile/profile-controller.js\n ** module id = 56\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/profile/profile-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Profile module for user profile and related content.\r\n */\r\n\r\nangular\r\n    .module('qibud.profile', [\r\n      'ui.router',\r\n      'qibud.common'\r\n    ])\r\n    .config(function ($stateProvider, $urlRouterProvider) {\r\n      $stateProvider\r\n          .state('profile', {\r\n            url: \"/profile\",\r\n            title: 'User Profile',\r\n            breadcrumb: {\r\n              class: 'highlight',\r\n              text: 'User Profile',\r\n              stateName: 'profile'\r\n            },\r\n            templateUrl: 'modules/profile/profile.html',\r\n            controller: 'ProfileCtrl'\r\n      });\r\n    });\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/profile/profile.js\n ** module id = 57\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/profile/profile.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nangular.module('qibud.viewer').controller('AssignboxCtrl', function ($scope, $modalInstance, users, actor) {\n\n  $scope.users = users;\n  $scope.selectedUser = actor;\n\n  $scope.assignUser = function (user) {\n    if ($scope.selectedUser) {\n      $scope.users.push($scope.selectedUser);\n    }\n    $scope.selectedUser = user;\n    _.remove($scope.users, function(u) { return u.id === user.id; });\n  };\n\n  $scope.unassignUser = function (user) {\n    $scope.users.push(user);\n    $scope.selectedUser = undefined;\n  };\n\n  $scope.ok = function () {\n    $modalInstance.close($scope.selectedUser);\n  };\n\n  $scope.cancel = function () {\n    $modalInstance.dismiss('cancel');\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/viewer/viewer-assignbox-controller.js\n ** module id = 58\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/viewer/viewer-assignbox-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Viewer controller provide a good way to read buds\r\n */\r\n\r\nangular.module('qibud.viewer').controller('ViewerCtrl',\r\nfunction ($scope, $state, $stateParams, $modal, api)\r\n{\r\n\r\n  var user       = $scope.common.user;\r\n  $scope.typeInfo = null;\r\n  $scope.ready = false;\r\n  $scope.mailSended = false;\r\n  $scope.mailErrored = false;\r\n  $scope.follower = false;\r\n  $scope.actionInProgress = false;\r\n  $scope.followersCount = 0;\r\n  $scope.sponsorsCount = 0;\r\n  $scope.supportersCount = 0;\r\n  $scope.supportValue = 0;\r\n  $scope.shareCount = 0;\r\n\r\n  // Helpers for bud packs\r\n\r\n  $scope.startParentIfNeeded = function (type) {\r\n    if($scope.bud.parentBud !== undefined) {\r\n      var parentBudId = $scope.bud.parentBud.id;\r\n      api.buds.budPacksData.get($scope.bud.parentBud.id, type)\r\n      .success (function (packData) {\r\n        if (packData.state == 'Waiting') {\r\n          packData.state = 'Started';\r\n          api.buds.budPacksData.set(parentBudId, packData, type);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  $scope.getParentPackData = function (type, callback) {\r\n    if($scope.bud.parentBud !== undefined) {\r\n      var parentBudId = $scope.bud.parentBud.id;\r\n      api.buds.budPacksData.get($scope.bud.parentBud.id, type)\r\n      .success (function (packData) {\r\n        callBack (packData);\r\n      });\r\n    } else {\r\n      callBack (null);\r\n    }\r\n  };\r\n\r\n  $scope.isActor = function ()\r\n  {\r\n    if ($scope.bud.dataCache.actor !== undefined) {\r\n      if($scope.bud.dataCache.actor.id === user.id) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  $scope.isCreator = function ()\r\n  {\r\n    if ($scope.bud.creator !== undefined) {\r\n      if($scope.bud.creator.id === user.id) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  $scope.isActorOrCreator = function ()\r\n  {\r\n    return ($scope.isActor() || $scope.isCreator());\r\n  }\r\n\r\n  $scope.setActor = function ($event, newState, packData, callback)\r\n  {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    $scope.actionInProgress = true;\r\n\r\n    packData.actor = user;\r\n    packData.state = newState;\r\n    api.buds.budPacksData.set($scope.bud.id, packData, $scope.bud.type);\r\n    api.links.createU2B(user.id,'ACTOR',$scope.bud.id)\r\n    .success (function () {\r\n      $scope.actionInProgress = false;\r\n      callback ();\r\n    });\r\n  };\r\n\r\n  $scope.assignActor = function ($event, newState, packData, callback)\r\n  {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    $scope.actionInProgress = true;\r\n\r\n    $scope.assign (function (actor) {\r\n      packData.actor = actor;\r\n      packData.state = newState;\r\n      api.links.createU2B(actor.id,'ACTOR',$scope.bud.id);\r\n      api.buds.budPacksData.set($scope.bud.id, packData, $scope.bud.type)\r\n      .success (function () {\r\n        $scope.actionInProgress = false;\r\n        callback ();\r\n      });\r\n    });\r\n  };\r\n\r\n  $scope.unsetActor = function ($event, newState, packData, callback)\r\n  {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    $scope.actionInProgress = true;\r\n    api.links.deleteU2B(packData.actor.id,'ASSIGNED',$scope.bud.id);\r\n    api.links.deleteU2B(packData.actor.id,'ACTOR',$scope.bud.id);\r\n    packData.actor = undefined;\r\n    packData.state = newState;\r\n    api.buds.budPacksData.set($scope.bud.id, packData, 'Action')\r\n    .success (function () {\r\n      $scope.actionInProgress = false;\r\n      callback ();\r\n    });\r\n\r\n  };\r\n\r\n  $scope.subscribeAll = function () {\r\n    api.buds.comments.created.subscribe($scope, function (comment) {\r\n      // only add the comment if we don't have it already in the bud's comments list to avoid dupes\r\n      if ($scope.bud && !_.some($scope.bud.comments, function (c)\r\n      {\r\n        return c.id === comment.id;\r\n      }))\r\n      {\r\n        $scope.bud.comments.push(comment);\r\n      }\r\n    });\r\n\r\n    api.buds.updated.subscribe($scope, function (bud) {\r\n      if ($scope.bud.id === bud.id)\r\n      {\r\n        $scope.load ();\r\n      }\r\n    });\r\n\r\n    api.buds.evolved.subscribe($scope, function (bud) {\r\n      if ($scope.bud.id === bud.id)\r\n      {\r\n        $scope.load ();\r\n      }\r\n    });\r\n\r\n    api.qi.updated.subscribe($scope, function (bud) {\r\n      if ($scope.bud.id === bud.id)\r\n      {\r\n        $scope.load ();\r\n      }\r\n    });\r\n\r\n    api.buds.sharesChanged.subscribe($scope, function (bud) {\r\n      if ($scope.bud.id === bud.id)\r\n      {\r\n        $scope.load ();\r\n      }\r\n    });\r\n\r\n    api.buds.followersChanged.subscribe($scope, function (bud) {\r\n      if ($scope.bud.id === bud.id)\r\n      {\r\n        $scope.bud.followers = bud.followers;\r\n        $scope.followersCount = bud.followers.length;\r\n        if(bud.followers.indexOf(user.id)!== -1)\r\n        {\r\n          $scope.follower = true;\r\n        }\r\n        else\r\n        {\r\n          $scope.follower = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    api.buds.supportersChanged.subscribe($scope, function (bud) {\r\n      if ($scope.bud.id === bud.id)\r\n      {\r\n        $scope.bud.supporters = bud.supporters;\r\n        $scope.supportersCount = bud.supporters.length;\r\n\r\n        if(bud.supporters.indexOf(user.id) !== -1)\r\n        {\r\n          $scope.supporter = true;\r\n        }\r\n        else\r\n        {\r\n          $scope.supporter = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    api.buds.sponsorsChanged.subscribe($scope, function (bud) {\r\n      if ($scope.bud.id === bud.id)\r\n      {\r\n        $scope.bud.sponsors = bud.sponsors;\r\n        $scope.sponsorsCount = bud.sponsors.length;\r\n        if(bud.sponsors.indexOf(user.id) !== -1)\r\n        {\r\n          $scope.sponsorer = true;\r\n        }\r\n        else\r\n        {\r\n          $scope.sponsorer = false;\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  //Init view\r\n  $scope.init = function (bud) {\r\n    bud.commentBox = {message: '', disabled: false};\r\n    bud.comments   = bud.comments || [];\r\n\r\n    $scope.bud = bud;\r\n    if(bud.followers)\r\n    {\r\n      $scope.followersCount = bud.followers.length;\r\n      if(bud.followers.indexOf(user.id)!== -1)\r\n      {\r\n        $scope.follower = true;\r\n      }\r\n      else\r\n      {\r\n        $scope.follower = false;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      $scope.follower = false;\r\n    }\r\n\r\n    if(bud.sponsors)\r\n    {\r\n      $scope.sponsorsCount = bud.sponsors.length;\r\n      if(bud.sponsors.indexOf(user.id)!== -1)\r\n      {\r\n        $scope.sponsorer = true;\r\n      }\r\n      else\r\n      {\r\n        $scope.sponsorer = false;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      $scope.sponsorer = false;\r\n    }\r\n\r\n    if(bud.supporters)\r\n    {\r\n      $scope.supportersCount = bud.supporters.length;\r\n      if(bud.supporters.indexOf(user.id)!== -1)\r\n      {\r\n        $scope.supporter = true;\r\n      }\r\n      else\r\n      {\r\n        $scope.supporter = false;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      $scope.supporter = false;\r\n    }\r\n\r\n    if(bud.shares)\r\n    {\r\n      $scope.shareCount = bud.shares.length;\r\n    } else {\r\n      $scope.shareCount = 0;\r\n    }\r\n  };\r\n  // retrieve one bud from server\r\n  $scope.load = function (callback)\r\n  {\r\n    console.info ('loading...');\r\n    $scope.actionInProgress = true;\r\n    $scope.ready = false;\r\n    api.buds.view($stateParams.budId).success(function (bud)\r\n    {\r\n      console.info ('init...');\r\n      $scope.init (bud);\r\n      console.info ('subscribe...');\r\n      $scope.subscribeAll ();\r\n      $scope.ready = true;\r\n      console.info ('load budpack view...');\r\n      $scope.showType ($scope.bud.type, false);\r\n      console.info ('loaded!');\r\n\r\n      if (callback) {\r\n        callback(function () {\r\n          $scope.actionInProgress = false;\r\n        });\r\n      } else {\r\n        $scope.actionInProgress = false;\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n\r\n  //Bud (re)loader\r\n  $scope.load();\r\n\r\n  $scope.showType = function (type, reload) {\r\n    if (type != 'Bud') {\r\n      $state.go('bud.viewer.' + type, $state.params, { reload: reload });\r\n    } else {\r\n      $state.go('bud.viewer',$state.params, { reload: reload });\r\n    }\r\n  };\r\n\r\n  $scope.sendByMail = function ($event) {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n    $scope.actionInProgress = true;\r\n    $scope.mailSended = false;\r\n    $scope.mailErrored = false;\r\n\r\n    var modalInstance = $modal.open ({\r\n      templateUrl: 'sendbymail.html',\r\n      controller: 'SendByMailCtrl',\r\n      size: 'lg',\r\n      resolve: {}\r\n    });\r\n\r\n    modalInstance.result.then(function (to) {\r\n      //sendemail\r\n      api.buds.sendByMail ($scope.bud.id, to)\r\n      .success (function (){\r\n        $scope.mailSended       = true;\r\n        $scope.actionInProgress = false;\r\n      })\r\n      .error (function (){\r\n        $scope.mailErrored      = true;\r\n        $scope.actionInProgress = false;\r\n      });\r\n    }, function () {\r\n      //dismiss\r\n      $scope.actionInProgress = false;\r\n    });\r\n  };\r\n\r\n  $scope.evolve = function ($event) {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n    $scope.actionInProgress = true;\r\n\r\n    var modalInstance = $modal.open ({\r\n      templateUrl: 'evolvebox.html',\r\n      controller: 'EvolveCtrl',\r\n      size: 'lg',\r\n      resolve: {\r\n        availableTypes: function () {\r\n          return $scope.common.availableTypes;\r\n        }\r\n      }\r\n    });\r\n\r\n    modalInstance.result.then(function (selectedType) {\r\n      api.buds.evolve($scope.bud.id, selectedType).success(function () {\r\n        $scope.actionInProgress = false;\r\n      })\r\n      .error(function ()\r\n      {\r\n        $scope.actionInProgress = false;\r\n      });\r\n    }, function () {\r\n      //dismiss\r\n      $scope.actionInProgress = false;\r\n    });\r\n  };\r\n\r\n  $scope.canEvolve = function ()\r\n  {\r\n    if(!$scope.bud) {\r\n      return false;\r\n    }\r\n\r\n    if($scope.bud.typeInfo.evolve === true && $scope.bud.creator.id === user.id) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  $scope.edit = function () {\r\n    $state.go('bud.editor',{budId : $scope.bud});\r\n  };\r\n\r\n  $scope.canEdit = function ()\r\n  {\r\n    if(!$scope.bud) {\r\n      return false;\r\n    }\r\n\r\n    if($scope.bud.creator.id === user.id) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  $scope.editSubBud = function () {\r\n    $state.go('bud.editor',{parentBud : $scope.bud});\r\n  };\r\n\r\n  $scope.budify = function (content) {\r\n    $state.go('bud.editor',{parentBud : $scope.bud, content: content});\r\n  };\r\n\r\n  $scope.delete = function () {\r\n    api.buds.delete($scope.bud.id).success(function (){\r\n      $state.go('home.budlist');\r\n    });\r\n  };\r\n\r\n  $scope.canDelete = function () {\r\n    if(!$scope.bud) {\r\n      return false;\r\n    }\r\n    var goodUser = ($scope.bud.creator.id == $scope.common.user.id);\r\n    var noSubBuds = (!$scope.bud.subBuds || $scope.bud.subBuds.length == 0);\r\n    return goodUser && noSubBuds;\r\n  }\r\n\r\n  $scope.share = function () {\r\n    api.actors.list().success(function (actors)\r\n    {\r\n      var modalInstance = $modal.open({\r\n        templateUrl: 'sharebox.html',\r\n        controller: 'ShareboxCtrl',\r\n        size: 'lg',\r\n        resolve: {\r\n          shares: function () {\r\n            return $scope.bud.shares;\r\n          },\r\n          users: function () {\r\n            return actors.users;\r\n          },\r\n          teams: function () {\r\n            return actors.teams;\r\n          }\r\n        }\r\n      });\r\n\r\n      modalInstance.result.then(function (actors) {\r\n        //share to ->\r\n        api.buds.share($scope.bud, actors).success(function (bud) {\r\n          console.info ('shared!');\r\n        });\r\n\r\n      }, function () {\r\n        //dismiss\r\n      });\r\n    });\r\n  };\r\n\r\n  $scope.assign = function (callback) {\r\n    api.actors.list().success(function (actors)\r\n    {\r\n      var modalInstance = $modal.open({\r\n        templateUrl: 'assignbox.html',\r\n        controller: 'AssignboxCtrl',\r\n        size: 'lg',\r\n        resolve: {\r\n          users: function () {\r\n            return actors.users;\r\n          },\r\n          actor: function () {\r\n            return $scope.bud.dataCache.actor;\r\n          }\r\n        }\r\n      });\r\n\r\n      modalInstance.result.then(function (actor) {\r\n        if($scope.bud.dataCache.actor) {\r\n          api.links.deleteU2B($scope.dataCache.actor.id,'ASSIGNED',$scope.bud.id);\r\n        }\r\n        //assign actor to bud ->\r\n        api.links.createU2B(actor.id,'ASSIGNED',$scope.bud.id);\r\n        callback (actor);\r\n      }, function () {\r\n        //dismiss\r\n      });\r\n    });\r\n  };\r\n\r\n  $scope.canShare = function ()\r\n  {\r\n    var sharable = false;\r\n    if(!$scope.bud) {\r\n      return sharable;\r\n    }\r\n\r\n    var creatorId = $scope.bud.creator.id;\r\n\r\n    //TODO: Add a watch on privacy changes check actor\r\n    switch($scope.bud.privacy)\r\n    {\r\n      case 'Private':\r\n        if(creatorId === user.id)\r\n        {\r\n          sharable = true;\r\n        }\r\n      break;\r\n      case 'Private2Share':\r\n        if(creatorId === user.id)\r\n        {\r\n          sharable = true;\r\n        }\r\n      break;\r\n    case 'Free2Share':\r\n        sharable = true;\r\n      break;\r\n    }\r\n\r\n    return sharable;\r\n  };\r\n\r\n\r\n  $scope.followBud = function ($event)\r\n  {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    $scope.actionInProgress = true;\r\n    if(!$scope.follower)\r\n    {\r\n      api.buds.follow($scope.bud)\r\n        .success(function (budId)\r\n        {\r\n          $scope.actionInProgress = false;\r\n        })\r\n        .error(function ()\r\n        {\r\n          $scope.actionInProgress = false;\r\n        });\r\n    }\r\n    else\r\n    {\r\n      api.buds.unfollow($scope.bud)\r\n        .success(function (budId)\r\n        {\r\n          $scope.actionInProgress = false;\r\n        })\r\n        .error(function ()\r\n        {\r\n          $scope.actionInProgress = false;\r\n        });\r\n    }\r\n  }\r\n\r\n  $scope.supportBud = function ($event)\r\n  {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    $scope.actionInProgress = true;\r\n\r\n    if(!$scope.supporter)\r\n    {\r\n      api.buds.support($scope.bud, $scope.supportValue)\r\n        .success(function (budId)\r\n        {\r\n          $scope.actionInProgress = false;\r\n        })\r\n        .error(function ()\r\n        {\r\n          $scope.actionInProgress = false;\r\n        });\r\n    }\r\n    else\r\n    {\r\n      api.buds.unsupport($scope.bud)\r\n        .success(function (budId)\r\n        {\r\n          $scope.actionInProgress = false;\r\n        })\r\n        .error(function ()\r\n        {\r\n          $scope.actionInProgress = false;\r\n        });\r\n    }\r\n  }\r\n\r\n  $scope.sponsorBud = function ($event)\r\n  {\r\n    if ($scope.actionInProgress)\r\n    {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n    $scope.actionInProgress = true;\r\n\r\n    if(!$scope.sponsorer)\r\n    {\r\n      api.buds.sponsor($scope.bud)\r\n        .success(function (budId)\r\n        {\r\n          $scope.actionInProgress = false;\r\n        })\r\n        .error(function ()\r\n        {\r\n          $scope.actionInProgress = false;\r\n        });\r\n    }\r\n    else\r\n    {\r\n      api.buds.unsponsor($scope.bud)\r\n        .success(function (budId)\r\n        {\r\n          $scope.actionInProgress = false;\r\n        })\r\n        .error(function ()\r\n        {\r\n          $scope.actionInProgress = false;\r\n        });\r\n    }\r\n  }\r\n\r\n  $scope.createComment = function ($event, bud)\r\n  {\r\n    // submit the message in the comment box only if user hits 'Enter (keycode 13)'\r\n    if ($event.keyCode !== 13)\r\n    {\r\n      return;\r\n    }\r\n\r\n    // don't let the user type in blank lines or submit empty/whitespace only comment, or type in something when comment is being created\r\n    if (!bud.commentBox.message.length || bud.commentBox.disabled) {\r\n      $event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    // disable the comment box and push the new comment to server\r\n    bud.commentBox.disabled = true;\r\n    //follow bud automaticly\r\n    if (!$scope.follower) {\r\n      console.log ('follow');\r\n      $scope.followBud ();\r\n    }\r\n    api.buds.comments.create(bud.id, {message: bud.commentBox.message})\r\n        .success(function (commentId)\r\n        {\r\n          // only add the comment if we don't have it already in the bud's comments list to avoid dupes\r\n          if (!_.some(bud.comments, function (c) {\r\n            return c.id === commentId;\r\n          }))\r\n          {\r\n            bud.comments.push({\r\n              id: commentId,\r\n              from: user,\r\n              message: bud.commentBox.message,\r\n              createdTime: new Date()\r\n            });\r\n          }\r\n\r\n          // clear the comment field and enable it\r\n          bud.commentBox.message  = '';\r\n          bud.commentBox.disabled = false;\r\n        })\r\n        .error(function ()\r\n        {\r\n          // don't clear the comment box but enable it so the user can re-try\r\n          bud.commentBox.disabled = false;\r\n        });\r\n\r\n    // prevent default 'Enter' button behavior (create new line) as we want 'Enter' button to do submission\r\n    $event.preventDefault();\r\n  };\r\n\r\n});\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/viewer/viewer-controller.js\n ** module id = 59\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/viewer/viewer-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nangular.module('qibud.viewer').controller('EvolveCtrl', function ($scope, $modalInstance, availableTypes) {\n\n  $scope.availableTypes = availableTypes;\n  $scope.selectedType = 'Bud';\n\n  $scope.setSelected = function (type) {\n    $scope.selectedType = type;\n  };\n\n  $scope.ok = function () {\n    $modalInstance.close($scope.selectedType);\n  };\n\n  $scope.cancel = function () {\n    $modalInstance.dismiss('cancel');\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/viewer/viewer-evolve-controller.js\n ** module id = 60\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/viewer/viewer-evolve-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nangular.module('qibud.viewer').controller('SendByMailCtrl', function ($scope, $modalInstance) {\n\n  $scope.to = null;\n\n  $scope.ok = function () {\n    $modalInstance.close($scope.to);\n  };\n\n  $scope.cancel = function () {\n    $modalInstance.dismiss('cancel');\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/viewer/viewer-sendbymail-controller.js\n ** module id = 61\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/viewer/viewer-sendbymail-controller.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nangular.module('qibud.viewer').controller('ShareboxCtrl', function ($scope, $modalInstance, shares, users, teams) {\n\n  $scope.users = users;\n  $scope.teams = teams;\n  $scope.selectedUsers = [];\n  if(shares) {\n    angular.forEach(shares[0], function (share){\n      _.remove($scope.users, function(u) { return u.id === share.id; });\n    });\n  }\n\n  $scope.addUser = function (user) {\n    $scope.selectedUsers.push(user);\n    _.remove($scope.users, function(u) { return u.id === user.id; });\n  };\n\n  $scope.addTeam = function (team) {\n    angular.forEach(team.members, function (user) {\n      var canShare = true;\n      if(shares) {\n        angular.forEach(shares[0], function (share){\n          if (user.id === share.id) {\n            canShare = false;\n          }\n        });\n      }\n\n      if(canShare) {\n        $scope.selectedUsers.push(user);\n        _.remove($scope.users, function(u) { return u.id === user.id; });\n      }\n    });\n  };\n\n  $scope.rmUser = function (user) {\n    $scope.users.push(user);\n    _.remove($scope.selectedUsers, function(u) { return u.id === user.id; });\n  };\n\n  $scope.ok = function () {\n    $modalInstance.close($scope.selectedUsers);\n  };\n\n  $scope.cancel = function () {\n    $modalInstance.dismiss('cancel');\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/viewer/viewer-sharebox-controller.js\n ** module id = 62\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/viewer/viewer-sharebox-controller.js?")
},function(module,exports,__webpack_require__){eval("'use strict';\r\n\r\n/**\r\n * Editor module for buds\r\n */\r\n\r\nangular\r\n    .module('qibud.viewer', [\r\n      'ui.router',\r\n      'ui.bootstrap',\r\n      'qibud.common'\r\n    ])\r\n    .config(function ($stateProvider, $urlRouterProvider) {\r\n\r\n      var types  = ['Team'];\r\n      var states = [];\r\n      var availableViews = {};\r\n\r\n      availableViews['@'] = {\r\n        controller: 'ViewerCtrl',\r\n        templateUrl: 'modules/viewer/viewer.html',\r\n      };\r\n\r\n\r\n      states.push({\r\n        name: 'bud.viewer',\r\n        sticky: true,\r\n        url: '/viewer/:budId',\r\n        views: availableViews,\r\n        breadcrumb: {\r\n          class: 'highlight',\r\n          text: 'Bud Viewer',\r\n          stateName: 'bud.viewer'\r\n        } });\r\n\r\n      angular.forEach(states, function(state) { $stateProvider.state(state); });\r\n    });\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./modules/viewer/viewer.js\n ** module id = 63\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./modules/viewer/viewer.js?")}]);